## Funções da família apply()

Algumas funções da família `apply()` são muito úteis na manipulação de dados e descrição de dados.
Essas funções são muito poderosas, porque permitem você fazer iterações de forma simples, ou seja, você pode aplicar uma função a vários objetos simultaneamente com funções dessa família.
O que você faz com essas funções você também faz com as iterações que fazem uso da expressão `for(){}` (veja seção \@ref(iteracoes)), mas essas funções simplificam e aceleram o processo.  

### Em uma matriz

A função `apply()` poderia ser traduzida como: 

> aplique uma função (FUN) a todas as linhas ou colunas (MARGIN) de uma matriz (X):

```{r, opts.label='evalF'}
?apply #Veja o help
#os argumentos dessa função são:
#X = matrix 
#MAGRIN = 1 indica linha, 2 indica colunas
#FUN = a função que você deseja aplicar
#... ARGUMENTOS DESSA FUNCAO SE FOR O CASO
 
#TOTAIS MARGINAIS
#crie uma matriz
X = matrix(1:36,nrow=4,ncol=9)
colnames(X) = paste('col',1:ncol(X))
rownames(X) = paste('ln',1:nrow(X))
head(X) #cabeça da matriz criada
 
#calcule para todas as linhas:
#a soma dos valores
apply(X,MARGIN=1,FUN=sum)
#o valor máximo
apply(X,MARGIN=1,FUN=max)
#a média
apply(X,MARGIN=1,FUN=mean)
#o desvio padrão
apply(X,MARGIN=1,FUN=sd)
 
#para todas as colunas
#a soma dos valores
apply(X,MARGIN=2,FUN=sum)
#o valor máximo
apply(X,MARGIN=2,FUN=max)
#a média
apply(X,MARGIN=2,FUN=mean)
#o desvio padrão
apply(X,MARGIN=2,FUN=sd)
```

As funções `rowSums()`, `rowMeans()`, `colSums()`, ou `colMeans()` são equivalentes à função `apply()`.
Elas simplificam o uso para somas (em inglês, *sum*) e médias (em inglês, *mean*) de linhas (em inglês, *rows*) e colunas (em inglês, *columns*).
Se você conhece bem a função `apply()`, você pode fazer o que essas funções fazem e muito mais.
Portanto, ao dominar a função `apply()`, você acaba por não precisar se preocupar em aprender essas funções mais específicas.

```{r, opts.label='evalF'}
?rowSums
rowSums(X) #soma de cada linha
rowMeans(X) #media de cada linha
colSums(X) #soma de cada coluna
colMeans(X) #média de cada coluna
```

### Em um vetor ou lista

A função `lapply()` aplica uma função `FUN` para cada elemento de um vetor ou de uma lista, e retorna um objeto de classe `list`.

```{r}
#muito simples, imprime algo linha por linha
ll = lapply(LETTERS,print)
class(ll)
str(ll)
 
#suponha três vetores de tamanhos diferentes
v1=sample(1:1000,50)
length(v1)
v2= sample(1:100,30)
length(v2)
v3= sample(1000:2000,90)
length(v3)
#imagina que isso esteja numa lista
ml = list(v1,v2,v3)
class(ml)
length(ml)
 
#posso usar lapply para calcular a media desses vetores
lapply(ml,mean) #note que retorna uma lista
lt = lapply(ml,mean) #podemos guardar
lt = as.vector(lt, mode='numeric') #e transformar num vetor. MODE neste caso é fundamental usar
lt
```

### Por categoria de um fator

A função `tapply()` aplica uma função `FUN` em uma coluna numérica individualizando os resultados para cada categoria de um determinado fator.

```{r, opts.label='evalF'}
#vamos usar os dados de Iris novamente
?iris
#calculando o comprimento médio de sepálas pelas categorias de um fator (especies)
class(iris$Sepal.Length) #variavel numerica
class(iris$Species) #fator com categorias que correspondem a especies
tapply(iris$Sepal.Length,iris$Species,FUN=mean)
 
#calculando o comprimento máximo por especie
tapply(iris$Sepal.Length,iris$Species,FUN=max)
 
#a amplitude de variacao
tapply(iris$Sepal.Length,iris$Species,FUN=range)
 
#note que essa funcao sempre retorna um array (que é uma lista de fato, neste caso)
tm = tapply(iris$Sepal.Length,iris$Species,FUN=min)
class(tm)
names(tm)
tm[['setosa']] #indexadores de lista
 
tr = tapply(iris$Sepal.Length,iris$Species,FUN=range)
class(tr)
names(tr)
tr[['setosa']]
```
