[["index.html", "Curso básico de introdução à linguagem R 1 Introdução", " Curso básico de introdução à linguagem R Alberto Vicentini (INPA) Ricardo de Oliveira Perdiz 2021-01-31 1 Introdução Este livro foi criado inicialmente para servir como um material de apoio básico aos estudantes da disciplina Preparação de dados para Análises Estatísticas - Introdução ao R (BOT-89) do Programa de Pós-Graduação em Ciências Biológicas (Botânica) do INPA. Porém, devido ao seu conteúdo abrangente, pode ser utilizado por qualquer pessoa que escolha conhecer esta linguagem para utilizá-la no dia a dia. Nosso meta é prover uma introdução básica da linguagem de programação R, que é extremamente poderosa para manipulação de dados, análises estatísticas, produção de gráficos e de documentos dinâmicos, e cujo domínio oferece um grande ganho de produtividade a todo cientista e facilita o entendimento de métodos analíticos. Ressaltamos que isto não é um curso de estatística. "],["pré-requisitos.html", "2 Pré-requisitos 2.1 Caso você possua um computador 2.2 Caso você não possua um computador", " 2 Pré-requisitos Devido ao modo como foi construído, este livro pode ser tanto lido quanto “executado”, uma vez que seus arquivos são o que chamamos de Rmarkdown, uma linguagem que mistura texto com código. Sendo assim, o livro pode ser visualizado em computadores, em celulares modernos, e em tablets. Não é necessário ter um computador próprio, apesar de que possuir um facilita o aprendizado. Entendemos que nosso país ainda carece de muito investimento na melhora da qualidade de vida da população em geral, o que inclui acesso facilitado aos bens de informática. Desta forma, providenciamos duas maneiras de o leitor deste livro fazer bem uso das informações aqui contidas. 2.1 Caso você possua um computador 2.1.1 Instale o R Baixe e instale o R, próprio para o seu sistema operacional. 2.1.2 Instale um ambiente de desenvolvimento integrado Recomendamos que o software RStudio seja instalado no seu computador, pois ele foi criado facilitar a interação do usuário com os múltiplos recursos oferecidos pela linguagem, em especial os inúmeros pacotes desenvolvidos por funcionários desta empresa, entre os quais se inclui o pacote bookdown, utilizado para construir este livro online. Ademais, ambientes de desenvolvimento integrado (do inglês Integrated Development Environment, IDE) como este software têm o objetivo de prover ao usuário mais ferramentas na interação entre o código e o resultado da execução do código, além de facilitar o uso de ferramentas alternativas para construção de texto mesclado com códigos (e.g., LaTeX, Markdown etc), o que permite uma dinamicidade na construção de textos acadêmicos. Existem outras alternativas de software, tais como o Atom e o Visual Studio Code. Fique à vontade para escolher. 2.2 Caso você não possua um computador O Google oferece um serviço chamado Google Colab que pode ser utilizado em computadores, em celulares modernos com acesso à internet e possuídores de um navegador, e em tablets. Em breve, importaremos todos os capítulos deste livro para esta plataforma, assim o usuário poderá baixá-los para sua conta Google e praticar as aulas por meios de telefones e tablets. Até lá, copie o conteúdo do livro, particularmente os códigos, e vá praticando. É muito fácil de usar. "],["conceitos-introdutórios.html", "3 Conceitos introdutórios 3.1 Console e scripts 3.2 Linguagem objeto-orientada 3.3 R-Base e pacotes 3.4 Ajuda no R 3.5 Área de trabalho vs. Pasta de Trabalho 3.6 Dicas de organização do trabalho 3.7 O R como calculadora", " 3 Conceitos introdutórios 3.1 Console e scripts As figuras abaixo mostram imagens relativamente similares ao que os usuários do R padrão (Figura 3.1) e RStudio (Figura 3.2) verão. Figura 3.1: Imagem de uma sessão do R para Mac OSX com um janela de script aberta além do console. Figura 3.2: Imagem de uma sessão do R studio com três painéis abertos. 3.2 Linguagem objeto-orientada A chave para entender o R é que trata-se de uma linguagem. Uma linguagem para manipular objetos (Venables e Ripley 2002). Um objeto é identificado por uma palavra e veremos ao longo do curso que existem vários tipos de objetos. Este é o conceito mais importante para entender o R. Para começar, digite algumas coisas no Console do seu R ou RStudio: #Por exemplo, digite uma fórmula matemática simples e pressione enter: 3+5+10 #o console retornou 18 - veremos como o R funciona como calculadora, portanto, números são interpretados como números pelo console #Agora vamos criar um objeto simples. objum = &quot;vou colocar um texto dentro do meu primeiro objeto&quot; #enter objum #enter #vejam que objum é o nome do meu primeiro objeto, e tem como conteúdo o texto que eu coloquei dentro #eu poderia ter chamado objum de qualquer coisa (sem espaços em branco) banana = &quot;vou colocar um texto dentro do meu primeiro objeto&quot; banana #mesma coisa né? #um objeto também pode virar outro objeto objdois = objum objdois #pegou o conteúdo que eu coloquei em objum #e posso colocar o resultado da minha conta objtres = 3+5+10 objtres Note que o código exposto acima é geralmente o que está contido em um script, ou seja a sequência de códigos que você escreveu e que o R interpretará para realizar o que foi dito. Se você copiar e colar o trecho (ou os trechos) de código acima em um arquivo .R, você poderá executá-los tantas vezes quanto quiser. Copie então todos os trechos de código expostos até então para a janela do script e salve-o como “script01.R” em alguma pasta no seu computador. Note também que dependendo do objeto, o código acima tem cores diferentes. Em vermelho e entre aspas estão textos, os números em roxo e objetos criados em preto. Isso ajuda a entender os elementos da sintaxe (vocabulário e gramática do R). Suítes gráficas IDE’s também mostram isso de forma colorida. Note também que, à direita do símbolo #, o texto no código acima fica cinza. Este símbolo indica ao R que todo texto começando no # deve ser interpretado como texto apenas, e não como código. Comentar códigos é uma prática que deve ser tornar rotineira a fim de facilitar o entendimento de cada script. Se você já está escrevendo um script num arquivo e não no console, selecione todo o texto na sua janela de script e digite Control+R (Windows), ou Command+Enter (Mac). O conteúdo do script será executado no Console. Note que o símbolo # não é interpretado pelo console. O R vem com vários scripts prontos, que são funções que executam alguma coisa. Esses scripts são objetos de classe função, pois eles contêm um conjunto de códigos que utilizam parâmetros para executar um conjunto de passos. Parâmetros são objetos que a função utiliza segundo as suas especificações. Por exemplo, vamos listar os objetos criados no passo anterior: #digite ls() #note os parênteses (); a função ls() lista os objetos criados por você: [1] &quot;banana&quot; &quot;objdois&quot; &quot;objtres&quot; &quot;objum&quot; #adicione um parâmetro à função, especificando o que você quer listar, apenas aqueles que contém no nome o padrão &quot;obj&quot; ls(pattern=&quot;obj&quot;) #[1] &quot;objdois&quot; &quot;objtres&quot; &quot;objum&quot; #agora veja o que a função ls é ls #note que não digitei os parênteses e ao digitar isso verei o script que está dentro da função ls que começa assim: function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE) { .... #note que os argumentos da função são os objetos que vão dentro do () da função e são utilizados pela função para executar alguma coisa, neste caso, lista objetos. Experimente mudando parâmetros: ls(sorted=FALSE) #ele mostra os objetos na ordem que foram criados 3.3 R-Base e pacotes Como vimos acima, um script do tipo função é um objeto que executa um conjunto de comandos e recebe argumentos que modificam o que o script realiza. Existem dois tipos de funções: Funções do pacote Base - funções que vêm junto com o R quando você faz o download do programa; Funções de pacotes - pacotes (library, packages) são funções criadas por colaboradores e organizadas em pacotes que você pode baixar dos repositórios do R. As funções do pacote base vêm junto com o programa e você não precisa se preocupar com isso. Pacotes, por outro lado, devem ser instalados pelo usuário conforme a necessidade. Por exemplo, para trabalhar com dados filogenéticos, você pode necessitar do pacote ape (Analyses of Phylogenetic and Evolution), que já tem várias funções preparadas para análises filogenéticas. Para trabalhar com pacotes você primeiro precisa definir um repositório, ou seja, um servidor, de vários disponíveis (espelhos do repositório oficial), de onde o R buscará o pacote desejado. Pode-se também o menu do R ou do RStudio para instalar pacotes e definir um repositório padrão para sua instalação. Como tudo no R, você pode executar comandos que estão no menu usando funções. Por exemplo, ao invés de usarmos o menu do R para definir um repositório e instalar um pacote, vamos executar estas ações por meio de um script: #isso pode não funcionar se estiver no INPA por causa do Proxy. chooseCRANmirror() #seleciona repositório install.packages(&quot;ape&quot;,dependencies = TRUE) #instala o pacote Ape 3.4 Ajuda no R Toda função no R, oriunda tanto do pacote base ou dos pacotes extras, possui um pedaço de texto chamado de “ajuda” e que possui uma instrução sobre a utilização da mesma. Para obter esta instrução, é muito fácil. Basta executar uma das seguintes opções: #como exemplo vamos usar a função ls() ?ls #ou seja o comando é ?+&quot;nome da função&quot; #ou então help(topic=&quot;ls&quot;) #nome da função como argumento da topic da função help Ao digitar uma das opções acima, o R vai abrir uma janela (no RStudio, vai colocar esse resultado num dos painéis) contendo a página com a explicação da função (Veja abaixo). Todos esses trechos de ajuda (?) do R têm a mesma estrutura. ?ls ls R Documentation List Objects Description ls and objects return a vector of character strings giving the names of the objects in the specified environment. When invoked with no argument at the top level prompt, ls shows what data sets and functions a user has defined. When invoked with no argument inside a function, ls returns the names of the function’s local variables: this is useful in conjunction with browser. Usage ls(name, pos = -1L, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE) objects(name, pos= -1L, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE) Arguments name which environment to use in listing the available objects. Defaults to the current environment. Although called name for back compatibility, in fact this argument can specify the environment in any form; see the ‘Details’ section. pos an alternative argument to name for specifying the environment as a position in the search list. Mostly there for back compatibility. envir an alternative argument to name for specifying the environment. Mostly there for back compatibility. all.names a logical value. If TRUE, all object names are returned. If FALSE, names which begin with a . are omitted. pattern an optional regular expression. Only names matching pattern are returned. glob2rx can be used to convert wildcard patterns to regular expressions. sorted logical indicating if the resulting character should be sorted alphabetically. Note that this is part of ls() may take most of the time. Details The name argument can specify the environment from which object names are taken in one of several forms: as an integer (the position in the search list); as the character string name of an element in the search list; or as an explicit environment (including using sys.frame to access the currently active function calls). By default, the environment of the call to ls or objects is used. The pos and envir arguments are an alternative way to specify an environment, but are primarily there for back compatibility. Note that the order of strings for sorted = TRUE is locale dependent, see Sys.getlocale. If sorted = FALSE the order is arbitrary, depending if the environment is hashed, the order of insertion of objects, …. References Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth &amp; Brooks/Cole. See Also glob2rx for converting wildcard patterns to regular expressions. ls.str for a long listing based on str. apropos (or find) for finding objects in the whole search path; grep for more details on ‘regular expressions’; class, methods, etc., for object-oriented programming. Examples .Ob &lt;- 1 ls(pattern = \"O\") ls(pattern= \"O\", all.names = TRUE) # also shows \".[foo]\" # shows an empty list because inside myfunc no variables are defined myfunc &lt;- function() {ls()} myfunc() # define a local variable inside myfunc myfunc &lt;- function() {y &lt;- 1; ls()} myfunc() # shows \"y\" 3.5 Área de trabalho vs. Pasta de Trabalho Dois conceitos são fundamentais para trabalhar no R: Área de Trabalho - é o local dentro do R onde você coloca os objetos criados durante a execução de scripts. Você pode visualizar/apagar os objetos no Console: ls() #ls= listar - já vimos que isso lista os objetos criados por você e que estão na área de trabalho ?rm #veja o help desta função rm(objum) #rm = remover - esta função apaga objetos da área de trabalho. No exemplo estamos apagando o objeto chamado objum, criado anteriormente ls() #note agora que o objeto não existe mais rm(list=ls()) #desse jeito apagamos todos os objetos que criamos anteriormente ls() #note que não sobrou nenhum objeto Pasta de Trabalho - é o local (pasta) no seu computador que o R usa para salvar arquivos. É o caminho padrão para o R encontrar arquivos de dados, scripts, etc. Você pode trabalhar no R sem definir uma “Pasta de Trabalho” mas é muito mais simples se você usa este recurso. Experimente a seguinte script: getwd() #o nome desta função é abreviação de &quot;get working directory&quot; ou seja &quot;pega a pasta de trabalho definida&quot;. A resposta deste código varia dependendo do seu sistema operacional. Mas a função retorna o caminho completo da pasta de trabalho atual Toda vez que você usar o R, é uma boa prática primeiramente definir a pasta de trabalho, que é o local no seu computador onde você guarda os arquivos relacionados ao seu projeto (dados, scripts, resultados etc.). Você pode definir a pasta de trabalho usando o menu do R (Arquivo ⇒ Diretório de Trabalho no Windows; ou Misc ⇒ Muda Pasta de Trabalho no Mac). Ou você pode usar uma função: ?setwd #veja o help da função que iremos utilizar minhapasta = &quot;/Users/BetoVicentini/Desktop/bot89-2016&quot; #se estiver usando windows: #minhapasta = &quot;c:/Users/BetoVicentini/Documents/bot89-2016&quot; #minhapasta = &quot;c:\\\\/Users\\\\/BetoVicentini\\\\/Documents\\\\/bot89-2016&quot; #talvez precise usar barras invertidas setwd(dir=minhapasta) #usa a funçao &quot;set working directory&quot; para especificar o diretório (pasta) de trabalho #note que eu defini dir primeiramente como o objeto &quot;minhapasta&quot; usei esse objeto para especificar o objeto &quot;dir&quot;, que é o único argumento da função setwd() Objetos criados no R por você podem ser salvos como um arquivo no seu computador. Você pode usar o menu do R ou RStudio para isso ou pode usar o comando abaixo: ?save #veja o help desta função que vamos utilizar ?save.image #veja o help desta função que vamos utilizar #se sua área de trabalho estiver vazia ls() #se nao retorna nada porque voce apagou acima #crie alguns objetos para o exercício objum = &quot;um objeto de texto qualquer&quot; objum objdois = 18 #um objeto com um número qualquer objdois banana = objum #um objeto idêntico a objum #pronto, agora mostre todos os objetos na sua AREA DE TRABALHO ls() #agora salve esse objetos como um arquivo na sua PASTA DE TRABALHO getwd() #veja onde o arquivo será salvo #se voce quer salvar todos os objetos save.image(file=&#39;meusObjetos.Rdata&#39;) #se voce quer salvar apenas alguns objetos save(objum,banana,file=&#39;meusObjetos2.Rdata&#39;) #veja que na sua pasta de trabalho getwd() voce tem esses arquivos dir() #lista arquivos na sua pasta de trabalho (análoga a função ls() que lista objetos) dir(pattern=&quot;Rdata&quot;) #lista apenas arquivos que tem no nome &quot;.Rdata&quot; #apaga os objetos todos rm(list=ls()) ls() #note que não tem mais objetos na sua área de trabalho, mas pode resgatar objetos que salvou num arquivo Rdata: load(file=&quot;meusObjetos2.Rdata&quot;) #puxa os objetos neste arquivo que está na sua pasta de trabalho ls() #note que ele puxou os objetos objum e banana que salvamos acima neste arquivo #puxe o outro arquivo gerado load(file=&quot;meusObjetos.Rdata&quot;) #puxa os objetos neste arquivo que está na sua pasta de trabalho ls() #veja novamente os objetos na sua área de trabalho: Todos os objetos são listados. Se fizer isso e já houver objetos com o mesmo nome na sua área de trabalho, estes serão sobrepostos. Portanto, Área de Trabalho e Pasta de Trabalho são dois conceitos fundamentais que você precisa entender bem, pois define como e onde você estará salvando informação quando usar o R, tanto em termos de objetos (área de trabalho) como em termos de arquivos (pasta de trabalho). Se você digita q(), que é a função para sair do R, ele geralmente lhe pergunta se você quer salvar os objetos numa área de trabalho padrão (que o R puxa quando você o inicia): q() #sai do R #vai perguntar no Console algo do tipo &quot;Save workspace image to ~/Desktop/bot89-2016/.RData? [y/n/c]:&quot; #note que o arquivo não tem nome apenas extensão &quot;.RData&quot; e é salvo na pasta de trabalho definida com setwd(). Códigos de scripts podem ser executados no console sem necessidade de abrir o script. Por exemplo, suponha que eu tenha salvo o seguinte script num arquivo script01.R: objum = &quot;meu primeiro objeto de texto&quot; objdois = 18 #meu primeiro objeto numérico banana = objum Se este arquivo Scrip01.R está na minha pasta de trabalho, então posso executá-lo com a função source(): dir(pattern=&quot;.R&quot;) #mostra os arquivos .R que estão na pasta de trabalho rm(list=ls()) #apaga todos os objetos, para ver que ele irá criar os objetos indicados no arquivo ls() #nao tem nenhum objeto source(&quot;script01.R&quot;) ls() #os objetos foram criados como especificado no script 3.6 Dicas de organização do trabalho Você irá manipular diversos arquivos durante a execução de qualquer projeto e precisa organizar os arquivos para não se perder e poder voltar a eles quando necessário. A grande vantagem de realizar a análise de dados, produção de figuras, etc no R (e RStudio) é criar um processo replicável, e é preciso ser bem organizado com os arquivos para poder reutilizar o processo com novos dados ou adaptá-lo para novas análises. Isso implica, entre outras coisas, em: Organizar o projeto em uma pasta no seu computador exclusiva para ele; Definir um critério lógico para dar nome aos arquivos do projeto; Organizar arquivos em subpastas segundo a necessidade, por exemplo, uma subpasta para dados, outra para figuras, outras para tabelas geradas e outros resultados. Pode inclusive colocar a criação dessas pastas nos scripts do R, que ele cria na pasta de trabalho (‘getwd()’) que deve ser a pasta do seu projeto através de (funções do R para manipular arquivos e pastas); O código dos seus scripts devem ser escritos de forma genérica para que ele possa ser usado com qualquer outro conjunto de dados que tenha a mesma estrutura que os seus (variáveis). Ou seja, o código deve ser escrito não em função do conteúdo dos seus dados mas apenas na estrutura (i.e. as colunas dos seus dados) deles. Esta é a chave para uma programação eficiente e para a replicabilidade. Isso significa que um resultado obtido a partir dos seus dados não deve ser manualmente atribuído a nenhum objeto no script, apenas atribuído a partir do objeto contendo o resultado. A definição da pasta de trabalho (‘working directory’) é fundamental simplificar a leitura de dados e salvar arquivos sem se preocupar com o caminho completo (‘full path’) para cada arquivo, mas apenas o caminho relativo (‘relative path’). Por exemplo, um arquivo numa pasta de projeto pode ter como caminho completo /home/usuario/Desktop/meuprojeto/dados/morfometricos.xlsx, e o caminho relativo à pasta de trabalho seria apenas dados/morfometricos.xlsx. Da mesma forma para salvar resultados a partir do R. O RStudio facilita esse processo para você, permitindo que você crie um projeto. Um projeto basicamente consiste em definir uma pasta de trabalho para que, toda vez que você abrí-lo, a pasta que contem o arquivo de término .Rproj seja a sua pasta de trabalho. Alternativamente, você pode simplesmente indicar a pasta de trabalho toda vez que iniciar uma atividade utilizando as funções setwd() no console ou em um script. 3.7 O R como calculadora O R é uma calculadora potente. Os exemplos abaixo mostram a informação básica necessária ao uso da ferramenta. 3.7.1 Operadores Operadores de atribuição use = ou &lt;- ou -&gt; para atribuir valor a objeto ou objeto a objeto Operadores matemáticos + e - são respectivamente adição e subtração; * e / são respectivamente multiplicação e divisão; ^ equivale à exponenciação # teste aqui, linha a linha 3+3 3-3 3*3 3/3 3^3 Objetos numéricos podem ser usados nas fórmulas aritméticas: #atribua um valor a um ou mais objetos obj = 3 obj2 = 3 #utilize o objeto para fazer contas obj+obj2 obj-obj2 obj*obj2 obj/obj2 obj^obj2 3.7.2 Precedência de parênteses O uso de parênteses permite construir qualquer lógica de precedência no cálculo: #atribua valores a três objetos o1 = 2 o2 = 4 o3 = 3 #os resultados não serão os mesmos para: o1*o2^o3-1 #=127 o1*o2^(o3-1) #=32 (o1*o2)^o3-1 #=511 (o1*o2)^(o3-1) #=64 3.7.3 Funções &amp; constantes matemáticas Algumas operações aritméticas podem ser realizadas com algumas funções genéricas que apresentamos no exemplo de código abaixo. Veja o help para qualquer uma das funções abaixo e siga os links relacionados para ver todas as possibilidades dessas funções genéricas de uso genérico. Veremos adiante que essas funções e operações matemáticas são aplicáveis à vetores. #Raiz quadrada sqrt(9) #valor absoluto abs(-12) abs(-66) abs(66) #logaritmo log(10) #Logaritmo natural log( 10, base = 10) #Logbase 10 log10(10) #Também log de base 10 #funções trigonométricas pi # é uma constante do R, um objeto chamado &quot;pi&quot; que tem o valor de 3.141593 sin(0.5*pi) #Seno cos(2*pi) # Coseno asin(1) # Arco seno (radianos) asin(1)/pi * 180 #arredondamentos #dois valores a = 3.51 b = 3.49 #para o valor mais alto (ceiling = teto) ceiling(a) ceiling(b) #para o valor mais baixo (floor = chão) floor(a) floor(b) #arredonda dependendo se casa decimal é maior ou menor que 0.5 round(a) round(b) 3.7.4 NA e valores afins Frequentemente no R, quando você realiza uma operação errada ou inválida, o R retorna um dos seguintes códigos (constantes lógicas), que são entendidos pelo R como esses valores e portanto podem ser usados na atribuição à objetos: NA = valores ausentes (faltando); NAN ou not a number = valores inválidos Inf = infinito -Inf = infinito negativo ?NA #veja o help sobre isso #um valor infinito negativo -5/0 #um valor infinito positivo 10/0 #note que o simbolo Inf vale como valor 500000000000000000/Inf #e que posso atribui-lo a um objeto mf = Inf 500/mf #valor inválido/inexistente sqrt(-1) #valores ausentes entram na matemática 2 * NA 2 * NaN Referências "],["objeto-i-vetores.html", "4 Objeto I - Vetores 4.1 Vetores &amp; Operações Vetoriais I 4.2 Operações Matemáticas com Vetores 4.3 Funções com Vetores 4.4 Classes de vetores e fatores 4.5 Indexação 4.6 Vetores e operadores lógicos", " 4 Objeto I - Vetores 4.1 Vetores &amp; Operações Vetoriais I Vetor no R é um tipo de objeto que concatena múltiplos valores de uma mesma classe. É fundamental que você entenda vetores para poder entender objetos mais complexos. 4.1.1 Criação de Vetores A função c() é usada na criação de vetores, ela combina ou concatena elementos: # um vetor de números v1 &lt;- c(3, 3.14, pi, 37.5, 38) v1 # um vetor de texto v2 &lt;- c(&quot;a&quot;, &quot;banana&quot;, &quot;maça&quot;, &quot;pera&quot;, &quot;jabuticaba&quot;) v2 # essas constantes do R são vetores de texto LETTERS # letras maiusculas letters # letras minusculuas month.abb # meses abreviados month.name # meses por extenso # vetor lógico (veremos adiante como isso é importante) v3 &lt;- c(TRUE, TRUE, FALSE, FALSE) v3 # é o mesmo que v3 &lt;- c(T, T, F, F) # note que TRUE e FALSE são valores lógicos e essas palavras são entendidas apenas quando em maiúsculas pelo R v4 &lt;- c(true, true, false, false) # o R não entende isso como valor lógico e o R procura por objetos com esses nomes 4.1.2 Sequências Numéricas &amp; Repetições É possível criar vetores numéricos usando a função seq() ou o operador :. # usando o : 1:10 # cria uma sequencia de números inteiros 1 a 10 20:0 # cria uma sequencia de números inteiros 20 a 0 0:-20 # cria uma sequencia de números inteiros 0 a -20 # usando a função seq() temos maior controle das sequencias ?seq # veja o help da função seq(from = 1, to = 10, by = 0.5) # de 1 a 0 a cada 0.5 seq(from = 10, to = 0, by = -0.5) # de 10 a 0 a cada 0.5 seq(from = 100, to = 0, length.out = 10) # 10 valores igualmente espaçados de 100 a 0 É possível criar vetores repetindo valores através da função rep(): # para números rep(5, times = 3) # cria um vetor com três elementos de valor 5 rep(1:5, times = 3) # cria um vetor com três repetições da sequência de 1 a 5 rep(1:5, each = 3) # cria um vetor repetindo três vezes cada elemento da sequência de 1 a 5 # para textos obj &lt;- c(&quot;banana&quot;, &quot;maça&quot;, &quot;pera&quot;) rep(obj, times = 3) rep(obj, each = 3) 4.2 Operações Matemáticas com Vetores Todas as operações aplicadas a um vetor são aplicadas a cada um de seus elementos: meuvetor &lt;- 1:5 # uma sequencia de 1 a 5 mv2 &lt;- meuvetor * 3 # uma sequencia onde cada valor de meuvetor foi multiplicado por 3 mv2 mv2 &lt;- meuvetor / 3 # uma sequencia onde cada valor de meuvetor foi divido por 3 # se usar uma função matemática com um vetor ela afetará cada elemento indivualmente meuvetor &lt;- c(49, 25, 16, 4, 1) sqrt(meuvetor) # raiz quadrada de cada elemento em meuvetor Operações com dois ou mais vetores são pareadas. Se os vetores têm o mesmo comprimento (mesmo número de elementos), então a operação é feita par a par, na ordem em que os elementos aparecem no vetor: v1 &lt;- c(1, 5, 10, 15) v2 &lt;- c(2, 4, 8, 16) v1 + v2 # soma dos valores individuais e pareados v1 * v2 v1^v2 REGRA DA RECICLAGEM - se os vetores não têm o mesmo comprimento (mesmo número de elementos), então a operação é feita par a par, mas o vetor mais curto é reciclado, i.e. os elementos do vetor mais curto são repetidos sequencialmente até que a operação seja aplicada a todos os elementos do vetor mais longo (o R dará uma aviso quando a operação envolver vetores de tamanhos diferentes, pois às vezes não é isso que queremos). # o mais simples para entender a regra da reciclagem é operação entre um vetor longo e um vetor atômico de um único valor v1 &lt;- c(1, 5, 10, 15) # vetor com 4 elementos v2 &lt;- 2 # vetor com 1 elemento v1 * v2 # cada elemento de v1 é multiplicado pelo único valor do vetor2 # mas a reciclagem se aplica em todos os casos de operação entre vetores de tamanhos diferentes v1 &lt;- c(1, 5, 10, 15) # vetor com 4 elementos v2 &lt;- c(3, 2) # vetor com 2 elemento v1 * v2 # os valores de v1 são multiplicados par a par pelos valores de v2. Como v2 tem apenas 2 elementos, eles são repetidos 1 vez ob &lt;- rep(c(0, 1), each = 5) oc &lt;- 1:3 ob * oc 4.3 Funções com Vetores Algumas funções operam sobre todo o vetor e não sobre cada elemento individualmente. Essas funções são utilizadas constantemente no R e, portanto, devemos conhecer as principais: length() e sort() - comprimento e ordenação de vetores meuvetor &lt;- 10:1 mv2 &lt;- seq(30, 99, by = 3) length(meuvetor) # quantos elementos tem meu vetor1 length(mv2) # quantos elementos tem meu vetor2 length(meuvetor) / length(mv2) # operação com os resultados mvord &lt;- sort(meuvetor) # ordena os elementos em ordem crescente mvord sort(mvord, decreasing = TRUE) # ordena os elementos em ordem decrescentes mean(), sd(), min(), sum() etc. - funções de estatística descritiva: ?mean # veja ajuda de uma dessas funções e navegue por outras v1 &lt;- c(2, 4, 6, 8, 4, 3, 5, 7) sum(v1) # soma de todos os valores mean(v1) # média aritimética dos valores median(v1) # valor da mediana sd(v1) # desvio padrão var(v1) # variância sqrt(var(v1)) # desvio padrão, pois este é a raíz quadrada da variância min(v1) # valor mínimo max(v1) # valor máximo range(v1) # mínimo e máximo diff(v1) # intervalos (diferenças entre valores consecutivos) entre os valores do vetor cumsum(v1) # soma cumulativa dos valores 4.3.1 Para saber mais: Veja nossas vídeoaulas com parte do conteúdo desta seção: Criação de vetores; Sequências numéricas e repetições. 4.4 Classes de vetores e fatores Para entender os conceitos, vamos primeiro conhecer algumas funções úteis no entendimento das classes de objetos do R e algumas funções importantes: class(), is.[class]() e as.[class](). Vetores têm classes diferentes e todos os elementos de um vetor pertencem à mesma classe. As principais classes são: numeric (=double, i.e. inclui casas decimais); integer (numérico mas de valor inteiro); character (texto); logical (verdadeiro ou falso); date (para datas). A função class() nos permite saber a classe de um objeto do R. ?class # veja o help dessa funcao v1 &lt;- 1:20 # um vetor de números inteiros class(v1) v2 &lt;- seq(1, 10, by = 0.5) # um vetor de números class(v2) v3 &lt;- rep(c(&quot;A&quot;, &quot;B&quot;), each = 10) # um vetor de palavras (character) class(v3) v4 &lt;- c(T, T, F, F) # um vetor lógico class(v4) v4 &lt;- c(10, &quot;A&quot;, 20, &quot;B&quot;) # um vetor com misto de números e letras será convertido para texto class(v4) v4 # veja que em v4 os elementos 10 e 20 viraram palavras, porque vetor só aceita elementos da mesma classe e enquanto um número pode ser convertido em texto, um texto não pode ser convertido em número. Por isso tudo é convertido para texto para a informação seja perdida (i.e. vire NA) As funções genéricas is.[class]() permitem você perguntar se um vetor é de uma determinada classe (is?). Vai retornar um vetor lógico, ou seja, verdadeiro ou falso dependendo da classe do objeto: v1 &lt;- 1:20 # um vetor de números inteiros is.integer(v1) # verdadeiro is.numeric(v1) # também verdadeiro porque números inteiros também são números v3 &lt;- rep(c(&quot;A&quot;, &quot;B&quot;), each = 10) # um vetor de palavras is.character(v3) # verdadeiro is.numeric(v3) # falso, porque o vetor contém palavras v4 &lt;- c(10, &quot;A&quot;, 20, &quot;B&quot;) # um vetor com misto de números e letras is.numeric(v4) # falso, porque o vetor contém apenas palavras v4 &lt;- c(T, T, F, F) # um vetor lógico is.logical(v4) # verdadeiro is.numeric(v4) # falso is.character(v4) # falso As funções genéricas as.[class]() (as = ‘como uma?’) permitem você converter um vetor de uma classe para outra. Em alguns casos, isso faz sentido; em outros, o retorno será de valores inexistentes (NA) ou não numéricos (NaN). # conversão total v1 &lt;- 1:20 # um vetor de números inteiros as.character(v1) # converte para texto um vetor numérico # conversão parcial v4 &lt;- c(10, &quot;A&quot;, 20, &quot;B&quot;) # um vetor com misto de números e letras as.numeric(v4) # converte cada elemento separadamente (regra da reciclagem é aplicada), o R vai conseguir mudar os textos que são números, mas as letras serão substituídas por NA e um aviso será dado quando isso acontecer # um vetor de texto não pode virar número v3 &lt;- rep(c(&quot;A&quot;, &quot;B&quot;), each = 10) # um vetor de palavras as.numeric(v3) # todos viram NA pois a conversão é inválida # mas um vetor lógico pode virar número v4 &lt;- c(T, T, F, F) # um vetor lógico as.numeric(v4) # verdadeiro vira 1 e falso vira 0 - isso é muito útil e é por isso que operações matemáticas funcionam com vetores lógicos: sum(v4) mean(v4) min(v4) O factor (=fator) na linguagem do R é um tipo especial de vetor com elementos de texto (classe character), em que os valores de texto são categorias. Isso tem algumas vantagens operacionais e sempre que o R precisa de um vetor de texto no formato de factor, ele converte automaticamente (se possível). No entanto, é muito importante que você entenda a diferença entre um vetor de classe character e um vetor de classe factor. Isso vai aparecer o tempo todo enquanto você usa o R e algumas vezes você precisará converter de um para outro. Funções importantes a serem memorizadas são: levels() - para ver (ou modificar) os níveis ou categorias de um fator; as.factor() e as.vector() - para converter entre fator e vetor. # um exemplo de um vetor de palavras mvv &lt;- c(&quot;abacate&quot;, &quot;banama&quot;, &quot;mamão&quot;, &quot;uva&quot;) # repetindo cada fruta 3 vezes mvv &lt;- rep(mvv, each = 3) # veja conteúdo mvv # qual a classe desse vetor? class(mvv) # vamos converter esse vetor de character para um fator mvv2 &lt;- as.factor(mvv) class(mvv2) # de fato mudou para factor mvv2 # compare a estrutura deste objeto com mvv (apareceu a a palavra Levels:, que mostra as categorias existentes no fator) # por ser um fator você pode levels(mvv2) # você pode ver os níveis do fator, ou seja as categorias que ele contém) levels(mvv2) &lt;- c(&quot;abacate&quot;, &quot;banana&quot;, &quot;mamão&quot;, &quot;uva&quot;) # você pode mudar/corrigir os níveis, aqui corrigindo banama por banana mvv2 # veja como mudaram as categorias e os valores as.numeric(mvv2) # você pode converter o fator em numérico, de forma que cada categoria vire um número (muito útil isso) as.numeric(mvv) # nao pode fazer a mesma coisa com um vetor de palavras A função as.Date() converte um vetor de trecho em um objeto de classe date. Datas são uma classe especial, que permite operações artiméticas para calcular distâncias temporais. # muitas vezes queremos calcular tempo entre duas observações, como por exemplo, entre duas medições consecutivas num estudo sobre crescimento de plantas # Qual a diferença em dias entre duas datas? data1 &lt;- &quot;31/03/1964&quot; data2 &lt;- &quot;17/04/2016&quot; # eu nao posso simplesmente subtrair esses valores data2 - data1 # isso dá um erro porque esses objetos são de classe texto class(data1) class(data2) # mas o R tem um classe para datas # entao fazemos a conversao ?as.Date # veja o help dessa função data1 &lt;- as.Date(data1, format = &quot;%d/%m/%Y&quot;) data2 &lt;- as.Date(data2, format = &quot;%d/%m/%Y&quot;) # agora a classe mudou class(data1) class(data2) # posso fazer matemática com data data2 - data1 # note o argumento format, ele importa para o R possa entender o formato de sua data data3 &lt;- &quot;2016-04-21&quot; # formato americano as.Date(data3, format = &quot;%d/%m/%Y&quot;) # se eu usasse isso com o mesmo formato acima, o resultado é NA, porque está mal especificado # mas mudando a simbologia do argumento format as.Date(data3, format = &quot;%Y-%m-%d&quot;) # ele reconhece 4.5 Indexação Já vimos que vetores são conjuntos de valores da mesma classe (seção 4.1). Esses valores tem uma posição dentro do vetor, ou seja, possuem um índice. Já vimos também que podemos alterar a ordem dos valores, utilizando a função sort(), ou seja, alterar a posição dos elementos no vetor. O índice identifica os elementos do vetor individualmente: pode ser um número equivalente à posição do elemento no vetor, ou pode ser um nome, quando os elementos do vetor tiverem um nome. Entender indexação é fundamental para escrever bons códigos no R, pois isso se aplica também às matrizes e às outras classes de objetos do R. Aqui vamos ver indexação de vetores, que é dada pelo operador []. 4.5.1 Usando índices numéricos #um vetor simples v1 = 1:10 v1[1] #valor na posição/índice 1 v1[8] #valor na posição/índice 8 #em outra ordem v1 = 1:10 v1 = sort(v1,decreasing=TRUE) #ordena decrescente v1[1] #valor na posição/índice 1 v1[8] #valor na posição/índice 8 4.5.2 Usando índices de nomes Índices de nomes são elementos essenciais na manipulação de dados reais, pois nomes de linhas (seus registros) e nomes de colunas (suas variáveis) são nomes dos elementos que compõem a sua matriz. Índice de nomes preservam o identificador dos seus objetos (registros). Podemos atribuir nomes aos elementos do vetor usando a função names(). Uma outra função útil se chama paste(), muito utilizada na manipulação de textos. ?paste #veja o help da função paste ?names #veja o help da função names #um vetor simples v1 = 1:10 #criando um vetor para usar como nomes v2 = paste(&quot;nome&quot;,v1,sep=&quot;&quot;) #significa = use a regra da reciclagem e cole (paste) a palavra &#39;nome&#39; com cada valor do vetor v1, sem separador v2 #é portanto um conjunto de textos #note que é muito mais rápido fazer isso do que escrever nome1, nome2 ... nome10, certo? #agora vamos atribuir v2 como nome dos elementos de v1 #para isso é importante que v1 e v2 tenham o mesmo comprimento length(v1) length(v2) names(v1) #deve ser nulo, pois os elementos não tem nome names(v1) = v2 #atribuimos os nomes v2 #pronto agora os elementos tem nome #posso usar o nome como índice para pegar elementos v1[&#39;nome8&#39;] #valor do elemento que tem nome = nome8 v1[8] #isso deve ser equivalente, pois criamos os nomes assim #mas note a diferença quando reordenamos o vetor e mudamos os valores de posição v3 = sort(v1, decreasing=T) v3[8] #o índice numérico pega outro valor v3[&#39;nome8&#39;] #o indice de nome pega o mesmo valor (PRESERVA) 4.5.3 Para saber mais: Indexação - veja esta vídeoaula com o conteúdo desta seção. 4.6 Vetores e operadores lógicos Para manipular dados no R, entender vetores lógicos e operadores lógicos é fundamental. Vetores lógicos são vetores de verdadeiros (TRUE ou apenas T, sempre em letras maiúsculas) ou falsos (FALSE ou F). Eles podem ser convertidos em vetores numéricos e, portanto, operados matematicamente (T = 1, e F = 0). 4.6.1 Fazendo perguntas à vetores Vetores lógicos podem ser respostas às perguntas feitas por operadores lógicos: &gt; - é maior que? &lt; - é menor que? &gt;= - é maior igual a? &lt;= - é menor igual a? == - é igual a? != - é diferente de? %in% - compara conteúdo de vetores Há ainda a função duplicated() que busca valores repetidos em um vetor. O resultado desta função é um vetor contendo TRUE ou FALSE. Valores que possuam o valor TRUE são duplicados. Para checar os duplicados, devemos filtrar o resultado desta ação (veja na seção 4.6.2). #um vetor numerico v1 = 1:20 #quais valores de v1 são maiores ou iguais a 10 p1 = v1&gt;=10 #vai retornar um vetor lógico p1 #soma dos verdadeiros responde &quot;quantos valores de v1 são maiores ou iguais a 10, pois apenas esses valores são verdadeiros ou seja são 1) sum(p1) #experimente os demais operadores #a regra da reciclagem também se aplica neste conceito v1 = 1:20 v2 = 1:20 p2 = v1==v2 #compara cada par dos vetores que são idênticos p2 #é o vetor lógico resultando, todos os valores são verdadeiros #portanto, as seguintes expressões também são verdadeiras sum(v1==v2)==length(v1) #ou então sum(v1==v2)==length(v2) #valores duplicados vv = c(2,2,2,3,4,5) vv #apenas o dois é duplicado duplicated(vv) #note que esta função retorna TRUE apenas para dois dos três valores 2 (o primeiro não é duplicado) #comparando vetores v1 = c(1,2,3,4) v2 = c(4,4,5,6) v1%in%v2 #quantos elementos de v1 existem em v2 sum(v1%in%v2) #apenas 1 v2%in%v1 #quais elementos de v2 estão em v1 sum(v2%in%v1) #os dois quatro notas.dos.alunos = c(6.0, 5.1, 6.8, 2.8, 6.1, 9.0, 4.3, 10.4,6.0, 7.9, 8.9, 6.8, 9.8, 4.6, 11.3, 8.0, 6.7, 4.5) ##Quantos aprovados? sum(notas.dos.alunos&gt;=5) #Qual a proporção de aprovados? prop = sum(notas.dos.alunos&gt;=5)/length(notas.dos.alunos) prop #ou em texto paste(round(prop*100),&quot;%&quot;,sep=&quot;&quot;) Podemos usar também vetores de texto e fatores em conjunto com operadores lógicos. #E VETORES DE TEXTO? v1 = rep(c(&quot;banana&quot;,&quot;pera&quot;,&quot;laranja&quot;,&quot;limão&quot;),10) v1 #um vetor de palavras #quantos elementos são iguais a banana v1==&quot;banana&quot; sum(v1==&quot;banana&quot;) #também poderia perguntar: quantos elementos de v1 contém banana sum(v1%in%&quot;banana&quot;) v1%in%&quot;banana&quot; #no caso acima == e %in% funcionam igual, mas o operador %in% é util quando quisermos comparar dois vetores de character v2 = c(&quot;banana&quot;,&quot;pera&quot;,&quot;abacate&quot;) v1%in%v2 #quais elementos de v1 correspondem a elementos de v2 sum(v1%in%v2) #quantos são? 10 laranjas e 10 peras v2%in%v1 #quais elementos de v2 estão em v1 sum(v2%in%v1) #quantos são (apenas laranja e pera, abacate não está) Operadores auxiliares permitem combinar perguntas: &amp; equivale a E - essa condição E essa outra; | equivale a OU - essa condição OU essa outra; ! - inverte os valores da pergunta #um vetor v1 = 1:20 v1 p1 = v1&gt;5 &amp; v1&lt;=15 #quais elementos de v1 são maiores que 5 E menores ou iguais a 15 sum(p1) #quantos são? p1 = v1&gt;5 | v1&lt;=15 #quais elementos de v1 são maiores que 5 OU menores ou iguais a 15 sum(p1) #quantos são #!exclamação NEGA ou INVERTE verdadeiros e falsos v1 = 1:20 sum(v1==5) #quantos v1 são iguais a 5? sum(!v1==5) #quantos v1 são diferentes de 5? sum(v1&gt;5) #quantos v1 são maiores que 5? sum(!v1&gt;5) #quantos v1 são menores que 5? #texto v1 = rep(c(&quot;banana&quot;,&quot;pera&quot;,&quot;laranja&quot;,&quot;limão&quot;),10) v1 #um vetor de palavras vl = v1==&quot;banana&quot; &amp; v1==&quot;pera&quot; #quantos elementos de v1 sao banana E sao pera vl sum(vl) #nenhum valor satisfaz as duas condicoes vl = v1==&quot;banana&quot; | v1==&quot;pera&quot; #quantos elementos de v1 sao banana ou sao pera vl sum(vl) #tem 20 valores que satisfazem 1 das condições #isso é o mesmo que pergunta desse outro jeito: sum(v1%in%c(&quot;banana&quot;,&quot;pera&quot;)) 4.6.2 Filtrando dados com vetores lógicos Vetores lógicos podem ser usados como índices (Seção @ref()) para filtrar elementos de um vetor. É através deste conceito que podemos filtrar dados de matrizes e criar subconjunto de dados. #um vetor com sequencia de 1 a 100 v1 = 1:100 p1 = v1&gt;15 #Pergunta 1 quantos são maiores que 15 v1[p1] #valores que satisfazem a pergunta 1 p2 = v1&lt;=20 #Pergunta 2 quantos são menores ou iguais a 20 v1[p2] #valores que satisfazem a pergunta 2 #quantos satisfazem as duas perguntas p3 = p1 &amp; p2 v1[p2] #valores que satisfazem as duas perguntas A função grep() permite a busca de uma palavra (ou pedaço dela) em um vetor de palavras. Mais de uma palavra pode ser buscada ao mesmo tempo. ?grep #veja o help dessa função e seus argumentos #um vetor de palavras v1 = rep(c(&quot;banana&quot;,&quot;pera&quot;,&quot;laranja&quot;,&quot;limão&quot;),5) grep(&quot;an&quot;,v1) #quais elementos tem a palavra &#39;an&#39; no nome? #note que é case.sensitive (depende se é maiusculo ou minúsculo) grep(&quot;An&quot;,v1) #não encontra nada grep(&quot;An&quot;,v1,ignore.case=T) #mas eu posso dizer para ele ignorar se é minusculo ou maiúsculo e ele encontra novamente #quem sao esses elementos vl = grep(&quot;An&quot;,v1,ignore.case=T) #pega os índices desses elementos v1[vl] unique(v1[vl]) #valores únicos desse vetor 4.6.3 Perguntando por valores ausentes - NA Vimos anteriormente como o R codifica valores ausentes (seção 3.7.4): como uma classe lógica definida pela palavra NA em maiúsculo. E nossos dados frequentemente têm valores ausentes. Isso vai gerar avisos indesejáveis e impedir certas análises. Então, muitas vezes precisamos tirar registros com valores ausentes ou colunas com muitos valores ausentes. Perguntar por valores ausentes no R é feito por uma função especial chamada is.na(). A resposta da função é um vetor lógico indicando quem é e quem não é NA. Há uma outra função chamada na.omit() que elimina valores NA de um vetor. ?is.na #veja o help #um vetor com NAs v1 = c(NA,NA,1,2,3,4,5,6) is.na(v1) #quem é NA? v2 = v1[!is.na(v1)] #criar um vetor novo com quem não é NA (note o !) v2 #isso também pode ser feito com na.omit() ?na.omit #veja o help dessa função v3 = na.omit(v1) v3 #a diferença é que criou um objeto de classe na.omit v3 = as.vector(v3) #isso elimina a diferença, convertendo em vetor v3 #agora é idêntico a v2 #agora suponha o seguinte vetor v4 = c(&quot;NA&quot;, &quot;NA&quot;,&quot;pera&quot;,&quot;banana&quot;,&quot;mamão&quot;) is.na(v4) #ops todos são falsos #isso porque &quot;NA&quot; é texto e não um objeto de classe lógica class(NA) class(&quot;NA&quot;) #mas eu poderia corrigir isso v4[v4==&quot;NA&quot;] #vejo v4[v4==&quot;NA&quot;] = NA #corrijo v4 is.na(v4) #agora dois são NAs #note que agora todos são diferentes de &quot;NA&quot; como texto v4[!v4==&quot;NA&quot;] #mas isso de mostra quem não é corretamente v5 = v4[!is.na(v4)] v5 4.6.4 Para saber mais: Vídeoaula - temos uma vídeoaula disponível com o conteúdo desta aula. Acesse-a no link abaixo: Vetores e Operadores Lógicos; "],["objeto-ii-matrizes-e-data-frames.html", "5 Objeto II - Matrizes e data.frames 5.1 Matriz vs. data.frame 5.2 Indexação de matriz e data.frame 5.3 Filtrando e ordenando matrizes e data.frames 5.4 Importanto e exportando dados no R", " 5 Objeto II - Matrizes e data.frames 5.1 Matriz vs. data.frame Objetos de classe matrix ou data.frame são objetos bidimensionais (tem linhas e colunas), e constituem a forma como nossos dados estão organizados. Precisamos entender a diferença entre essas classes e suas propriedades. Objetos de classe matrix contêm linhas e colunas, mas os valores de toda a matriz são da mesma classe (numeric, character, ou logical, por exemplo). Operações matemáticas com matrizes utilizam matrizes numéricas, portanto, de uma única classe, matrix. Objetos de classe data.frame tambêm contém linhas e colunas, mas podem misturar colunas de classes diferentes (numeric e character, factor, e logical, por exemplo). Quando importamos dados ao R, geralmente atribuímos os dados a um objeto de classe data.frame. Podemos converter um objeto de classe matrix para data.frame e vice-versa, usando as funções as.data.frame() ou as.matrix(). Porém, quando convertemos os dados para um objeto de classe matrix, todos os dados passam a ser da mesma classe, geralmente havendo perda de dados. 5.1.1 Criando matrizes Poder criar uma matriz no R é muito útil para várias finalidades como, por exemplo, simular dados em testes de permutação ou preencher uma tabela com resultados de uma análise. Matrizes podem ser criadas de diferentes formas (e.g., pode juntar matrizes pelas linhas e colunas, ou pode extrair sub-matrizes de uma matriz). Para criar matrizes, a função básica se chama matrix(): #veja o help da função ?matrix #a função se usa assim: matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) #onde: # data = NA #um vetor de comprimento igual ao número de células desejadas que é nrow*ncol. # byrow = FALSE #A forma de preenchimento da planilha pelos dados em data. Se byrow=TRUE, então ele preenche pelas linhas, senão pelas # colunas # nrow = número de linhas # ncol = número de colunas # dimnames = um objeto do tipo lista (que ainda não vimos), com dois vetores, um com os nomes das linhas, outro com os nomes das colunas. #exemplo 1 - matriz de 3x3 com zeros mm = matrix(data=0,nrow=3,ncol=3,byrow=F,dimnames=NULL) mm #note que data tem comprimento 1, apenas 1 valor. Pela regra da reciclagem ele é repetido até completar o total necessário dado por nrow*ncol #exemplo2 - matriz de 3x3 com valores dd = 1:9 #nove valores mm = matrix(data=dd,nrow=3,ncol=3,byrow=F,dimnames=NULL) mm #mudando byrow para TRUE preenchemos pelas linhas mm2 = matrix(data=dd,nrow=3,ncol=3,byrow=TRUE,dimnames=NULL) mm2 #exemplo3 - matriz de 3x3 com valores e nomes de colunas e linhas #define dimensao nrow=3 ncol=3 #define data dd = 1:9 #nove valores #define nome de colunas cln = paste(&quot;coluna&quot;,1:ncol,sep=&quot;&quot;) #define nome de linhas lln = paste(&quot;linha&quot;,1:nrow,sep=&quot;&quot;) mm = matrix(data=dd,nrow=nrow,ncol=ncol,byrow=F,dimnames=list(lln,cln)) mm Para unir ou criar matrizes (e data.frames) temos duas funções úteis: rbind(), que vem do inglês row bind, ou seja, cole linhas; cbind(), que vem do inglês column bind, ou seja, cole colunas. # vetores numéricos de mesmo comprimento v1 = 1:10 v2 = 10:1 v3= 11:20 #essas duas condições devem ser verdadeiras length(v1)==length(v2) length(v1)==length(v3) #entao posso criar uma matriz juntando esses vetores em linhas ou colunas mml = rbind(v1,v2,v3) class(mml) #criou um matrix mml #ou mmc = cbind(v1,v2,v3) class(mmc) #ou se eu já tenho uma matriz, posso usar essas funções para adicionar novas linhas ou colunas novovetor = 31:40 #por linha ncol(mml)==length(novovetor) #neste caso o número de colunas da matrix precisa ser igual ao número de elementos no vetor mml = rbind(mml,novovetor) #junto a matrix existente com o novo vetor, adicionando uma nova linha mml #note que a nova linha recebeu como nome o nome do objeto que continha o dado #por coluna nrow(mmc)==length(novovetor) #neste caso o número de linhas da matrix precisa ser igual ao número de elementos no vetor mmc = cbind(mmc,novovetor) #junto a matrix existente com o novo vetor, adicionando uma nova coluna mmc #note que a nova coluna recebeu como nome o nome do objeto que continha o dado 5.1.2 Criando data.frames Objetos de classe data.frame são tabelas de dados, apresentam duas dimensões, e permitem misturar dados de classes diferentes, numéricos, texto (character ou factor) e lógicos. Quando importamos nossos dados ao R, em geral criamos objetos de classe data.frame. Para criar ou converter dados em data.frames, podemos usar as funções data.frame() e as.data.frame(). ?data.frame #veja o help das funções acima # a funcao que cria o objeto é data.frame(..., row.names = NULL, check.rows = FALSE, check.names = TRUE, stringsAsFactors = default.stringsAsFactors()) #de todos os argumentos os mais importantes são: #... #que pode ser vetores ou tag = vetor (os dados da tabela) #stringsAsFactors #que especifica se queremos os textos como vetores ou fatores #exemplo 1 - #Primeiro criamos alguns dados #um vetor numerico v1 = 1:10 #um vetor de letras do mesmo comprimento usando a constante LETTERS v2 = LETTERS[1:10] #um vetor de palavras de mesmo comprimento v3 = rep(c(&#39;fulano&#39;,&#39;jose&#39;,&#39;joaquim&#39;,&#39;martin&#39;), length.out=length(v1)) #Juntamos num data.frame com fatores dd = data.frame(v1,v2,v3,stringsAsFactors = T) class(dd) #é um data frame dim(dd) #dimensoes, linhas e colunas ncol(dd) #numero de colunas nrow(dd) #numero de linhas str(dd) #estrutura do objeto (veja as classes das colunas) #JUNTAMOS SEM FATORES dd2 = data.frame(v1,v2,v3,stringsAsFactors = FALSE) class(dd2) #é um data frame str(dd2) #estrutura do objeto (veja as classes das colunas) #juntamos com nome de colunas (tag = vetor) dd2 = data.frame(RegistorID=v1,CodigoZ=v2,Pessoa=v3,stringsAsFactors = FALSE) dd2 #agora vamos usar o cbind que vimos acima dz = cbind(v1,v2,v3) #ou entao usando tag=vetor para ter nomes das colunas de acordo dz = cbind(RegistorID=v1,CodigoZ=v2,Pessoa=v3) class(dz) #isso cria uma matriz str(dz) #todos os dados são da mesma classe (texto) dz = as.data.frame(dz) #convertemos num data.frame class(dz) #é um data.frame str(dz) #converte numeros para numerico e texto para fator dz = as.data.frame(as.matrix(dz), stringsAsFactors = FALSE) #convertemos num data.frame sem fatores str(dz) #converte numeros para numerico e texto para character 5.1.3 Funções importantes na manipulação de matrizes e data.frames As funções head() e tail() mostram o cabeçalho e rodapé tanto para matrizes como para data.frames, respectivamente. #Primeiro criamos alguns dados #um vetor numerico v1 = 1:10 #um vetor de letras do mesmo comprimento usando a constante LETTERS v2 = LETTERS[1:10] #um vetor de palavras de mesmo comprimento v3 = rep(c(&#39;fulano&#39;,&#39;jose&#39;,&#39;joaquim&#39;,&#39;martin&#39;), length.out=length(v1)) #juntamos com nome de colunas (tag = vetor) e com dd2 = data.frame(RegistorID=v1,CodigoZ=v2,Pessoa=v3,stringsAsFactors = TRUE) #cabeçalho ?head(dd2) #primeiras 6 linhas head(dd2,3) #três primeiras linhas #rodapé tail(dd2) #seis últimas linhas tail(dd2,3) #três últimas linhas As funções dim(), nrow() e ncol() informam as dimensões de matrizes e data.frames, número de linhas, e número de colunas, respectivamente. dim(dd2) #vetor com dois valores, número de linhas e número de colunas nrow(dd2) #número de linhas do data.frame ou matrix ncol(dd2) #número de colunas do data.frame ou matrix nrow(as.matrix(dd2)) ncol(as.matrix(dd2)) As funções str() e summary() informam a estrutura dos data.frames e o resumo dos dados, respectivamente. str(dd2) #mostra a estrutura do objeto, quais colunas, classes de colunas e total de valores summary(dd2) #mostra para cada coluna a variação encontrada: estatística descritiva de variáveis numéricas, contagem por categoria de fatores, etc. Veremos isso adiante. As funções colnames() e rownames() permitem VER e ATRIBUIR valores de nomes de linhas e colunas em data.frames e matrizes. Em um data.frame, os nomes de linhas DEVEM SER ÚNICOS e não podem ter duas linhas com o mesmo nome. São códigos que identificam registros únicos. Isso é muito importante para o entendimento dos identificadores dos seus dados. #vamos criar uma matriz com nomes de linhas e colunas mm = matrix(1:9,nrow=3,ncol=3,dimnames=list(paste(&quot;linha&quot;,1:3,sep=&quot;&quot;),paste(&quot;coluna&quot;,1:3,sep=&quot;&quot;))) #e converter essa matrix para um data.frame dd = as.data.frame(mm) #vamos também criar outra matriz SEM nomes de linhas e colunas mm2 = matrix(1:9,nrow=3,ncol=3) #e converter essa matrix para um data.frame dd2 = as.data.frame(mm2) #para os objetos com nomes podemos ver os nomes rownames(mm) rownames(dd) colnames(mm) colnames(dd) #para os objetos sem nomes rownames(mm2) #nulo, não tem nome rownames(dd2) #números em formato de texto colnames(mm2) #nulo, não tem nome colnames(dd2) #V1 a Vncol(dd) - ele cria nomes das colunas #note que no caso do data.frame dd2, apesar de não ter nome de linha e coluna, o R criou uma para ele. DATA.FRAMES SEMPRE TEM NOME DE LINHAS E COLUNAS. Note que o nome das linhas apesar de números correspondentes aos índices, são de fato TEXTO #essas funções permitem VER mas também permitem ATRIBUIR (modificar) nomes #modificando quem já tem nome (matriz, mas funciona igual para dd) colnames(mm) #nomes atuais colnames(mm) = c(&quot;novonome1&quot;,&quot;novonome2&quot;,&quot;novonome3&quot;) mm #veja como o nome das colunas mudou #mudando apenas o nome da coluna2 colnames(mm)[2] = &quot;colunaDOIS&quot; colnames(mm) #nomes atuais #atribuindo quando não tem nome colnames(mm2) #está vazio ou não existe (NULL) colnames(mm2) = paste(&quot;banana&quot;,1:ncol(mm2),sep=&quot;-&quot;) mm2 #agora tem nome de coluna rownames(mm2) #nomes de linhas também está vazio rownames(mm2) = paste(&quot;chuchu&quot;,1:nrow(mm2),sep=&quot;.&quot;) mm2 #agora tem nomes de linha e coluna #agora tente atribuir um nome repetido rownames(mm2)[1:2] = &quot;teste1&quot; #coloque o nome teste1 para as linhas 1 e 2 FUNCIONA PARA MATRIX rownames(dd)[1:2] = &quot;teste1&quot; #nao funciona, porque ele não aceita nomes repetidos de linhas em DATA.FRAMES 5.2 Indexação de matriz e data.frame Entender indexação é fundamental para manipular dados no R. Em indexação de vetores (seção 4.5), vimos que é possível usar números, códigos/nomes ou valores de verdadeiro ou falso (lógico), como elementos para visualizar, filtrar e mudar dados em vetores unidimensionais. O mesmo operador, [], pode ser usado para indexação de uma matriz ou um data.frame. A única diferença é que, por matrizes e data.frames serem bidimensionais, precisamos indicar a qual dimensão estamos nos referindo. Portanto o operador de indexação para matrizes e data.frame tem a seguinte estrutura, [indiceDeLinha , indiceDeColuna], em que a vírgula separa os índices de linha e coluna. 5.2.1 Matrizes #vamos criar uma matriz mm = matrix(1:9,nrow=3,ncol=3,dimnames=list(paste(&quot;linha&quot;,1:3,sep=&quot;&quot;),paste(&quot;coluna&quot;,1:3,sep=&quot;&quot;))) #veja a matriz criada mm #USANDO INDICE NUMÉRICO mm[1,2] #mostra o elemento da linha 1 e coluna 2 mm[1,ncol(mm)] #mostra o elemento da linha 1 e última coluna mm[nrow(mm),ncol(mm)] #mostra o elemento da última linha e última coluna mm[,1] #mostra a coluna 1 # eu posso juntar indices de matrizes e vetores na mesma linha mm[,1][2] #mostra o segundo elemento do vetor correspondente a primeira coluna mm[1,] #mostra a linha 1 mm[nrow(mm),] #mostra a ultima linha mm[ ,1:2] #mostra as duas primeiras colunas mm[1:2,1:3] #mostra as duas primeiras linhas e duas primeiras colunas mm[3:nrow(mm),] #mostra da linha tres a ultima linha mm[c(3,1),c(3,2)] #mostra as linhas 3 e 1 e colunas 3 e 2 (nessa ordem) #USANDO INDICES DE NOMES mm[&quot;linha1&quot;,] #mostra a linha 1 - note que poderia ser outro nome, poderia ter chamado no inicio do script a linha 1 de &quot;banana&quot; mm[,&quot;coluna1&quot;] #mostra a coluna 1 mm[c(&quot;linha3&quot;,&quot;linha1&quot;),c(&quot;coluna3&quot;,&quot;coluna1&quot;)] #mostra a linhas 3 e 1 e colunas 3 e 1. NOTE QUE POSSO ASSIM INVERTER AS COLUNAS E LINHAS #SE EU POSSO VER EU POSSO MUDAR mm mm[1,3] #elemento da linha 1 coluna 3 mm[1,3] = 33 #mudei o elemento mm[2,2:3] mm[2,2:3] = mm[2,2:3]*10 #mudei os valores das colunas 2 e 3 para a linha 2, multiplicando o original por 10 mm[2,2:3] mm 5.2.2 data.frame O operador [indiceDeLinha , indiceDeColuna] também funciona para data.frames. Outro operador útil na manipulação de data.frames é o $. Ele permite a visualização e atribuição de valores a qualquer coluna. #vamos criar uma matriz com nomes de linhas e colunas mm = matrix(1:9,nrow=3,ncol=3,dimnames=list(paste(&quot;linha&quot;,1:3,sep=&quot;&quot;),paste(&quot;coluna&quot;,1:3,sep=&quot;&quot;))) #veja a matriz criada mm #convertemos para um data.frame dd = as.data.frame(mm) dd$coluna1 #pego a coluna 1 (note que o nome da coluna vai sem &quot;aspas&quot;) mm$coluna1 #veja como não funciona para o objeto matrix dd$coluna1[2] #vejo o segundo elemento da coluna1 #isso é o mesmo que dd[2,&quot;coluna1&quot;] #se eu vejo eu posso mudar dd[2,&quot;coluna1&quot;] = 10 dd$coluna1[3] = 20 dd$coluna3 #pego a coluna tres #também posso adicionar uma nova coluna dd$novacoluna = LETTERS[1:nrow(dd)] dd #agora tenho uma nova coluna #ou poderia usar outra forma dd[,&quot;nova2&quot;] = LETTERS #nao vai funcionar por estou atribuindo um vetor muito mais longo do que tenho linhas length(LETTERS)&gt;nrow(dd) #essa expressão é verdadeira dd[,&quot;nova2&quot;] = LETTERS[1:nrow(dd)] #isso tem o mesmo comprimento e funciona dd #posso adicionar uma coluna vazia dd$outracoluna = NA dd #e ainda outra (lógica) dd$maisuma = TRUE dd #NO CASO DE MATRIZES ISSO ADICIONAR NOVAS COLUNAS É UM POUCO DIFERENTE #primeiro nao posso usar $ porque matrix não entende isso class(mm) #é uma matrix mm$colun3 #isso nao funciona mm[,&quot;coluna3&quot;] #isso funciona #adicionando uma coluna mm[,4] #isso nao existe mm[,4] = log(mm[,&quot;coluna3&quot;]) #isso não funciona #poderia usar a função cbind que vimos anteriormente mm = cbind(mm, LOGCOLUNA3 =log(mm[,&quot;coluna3&quot;]) ) #assim eu posso 5.2.3 Para saber mais: Indexação de matrizes e data.frames - vídeoaula com o conteúdo desta seção. 5.3 Filtrando e ordenando matrizes e data.frames 5.3.1 Filtragem de dados Já vimos como fazer perguntas sobre vetores (Seção 4.6.1) e obter vetores lógicos ou valores de índices que nos permitem extrair ou filtrar de vetores os dados que satisfazem às condições das perguntas feitas. Aqui vamos estender isso para objetos de classe matrix e data.frame, porque é através de vetores lógicos ou de matrizes lógicas que podemos filtrar dados de objetos bidimensionais. ?iris #veja o help do R sobre Edgar Anderson&#39;s Iris Data que explica esses dados que vem com o R class(iris) str(iris) #estrutura, veja as colunas #vamos filtrar os dados de uma das especies unique(iris$Species) #vemos os valores únicos #ou, tendo em vista que é um fator levels(iris$Species) sp1 = levels(iris$Species)[1] #quais linhas correspondem a essa especie vl = iris$Species==sp1 sum(vl) #numero de linhas que satisfazem a pergunta nrow(iris) #numero total de linhas no data.frame #filtrando os dados eu simplesmente uso o vetor lógico como índice de linha. O novo objeto criado terá apenas as linhas em que vl é verdadeiro iris.sp1 = iris[vl,] nrow(iris.sp1)==sum(vl) #entao esta condição é verdadeira #filtrar segundo duas colunas vl = iris$Species==sp1 #seja da especie em sp1 sum(vl) #quantas sao? vl2 = iris$Sepal.Length&lt;=5 #tenha sepala menor ou igual a 5 sum(vl2) #quantas sao? #combinando as duas perguntas vll = vl &amp; vl2 sum(vll) #quantas sao? #filtrando ff = iris[vll,] class(ff) #novo data.frame resultando do filtro realizado nrow(ff)== sum(vll) #isso deve ser verdadeiro 5.3.1.1 Dados com valores ausentes As funçõesis.na() e na.omit() vistas anteriormente (Seção 4.6.3) permitem eliminar linhas e colunas que tenham valores ausentes. A presença de valores às vezes impede certas análises de serem executadas. #vamos fazer uma cópia do objeto iris e modificar ele acrescentando alguns NAs dd = iris #tem algum NA originalmente? sum(is.na(dd)) #não tem #qual a dimensão? dim(dd) #pega 10 valores aletórios entre 1:150 (linhas) v1 = sample(1:nrow(dd),size=10,replace=F) #nessas linhas acrescenta NAs na coluna 2 dd[v1,2] = NA #pega outros 10 valores aletórios entre 1:150 (linhas) v1 = sample(1:nrow(dd),size=10,replace=F) #nessas linhas acrescenta NAs na coluna 3 dd[v1,3] = NA #pronto agora temos um data.frame com NAs sum(is.na(dd)) #tem 20 NAs na tabela #quais linhas tem NA vl = is.na(dd[,2]) | is.na(dd[,3]) #ou é NA em 2 ou em 3 que foi onde mudei dd[vl,] #use na.omit() para eliminar todas as linhas que NA em alguma coluna sum(is.na(dd)) #tem 20 valores dd2 = na.omit(dd) sum(is.na(dd2)) #nao tem mais nenhum 5.3.2 Ordenação de dados Para ordenar matrizes e data.frames, é preciso entender a diferença entre duas funções: sort() ordena um vetor e retorna os valores ordenados; order() ordena um vetor e retorna os índices dos valores ordenados. É isso que deve ser utilizado para ordenar matrizes e data.frames. ?sort ?order #ordenação str(iris) #funcao SORT() o1 = sort(iris$Sepal.Length) #pega os valores ordenados da coluna comprimento de sépala o1 #sao valores de sepalas do menor para o maior #em ordem decrescente o2 = sort(iris$Sepal.Length,decreasing=T) o2 #sao valores de sepalas do maior para o menor #FUNCAO order() #qual o indice dos valores ordenados em ordem crescente? o3 = order(iris$Sepal.Length) o3 #esses valores correspondem aos INDICES dos valores ordenados #entao para ver os valores ordenados iris$Sepal.Length[o3] #então isso deve ser totalmente verdadeiro: iris$Sepal.Length[o3]==sort(iris$Sepal.Length) #as comparações para a par são identicas #então esta expressão também é verdadeira: sum(iris$Sepal.Length[o3]==sort(iris$Sepal.Length))==nrow(iris) #portanto a função sort ordena os valores e funcao order mostra apenas os indices dos valores ordenados. Assim, posso usar a funcao order() para ordenar data.frames, matrizes e vetores idx = order(iris$Sepal.Length) #indice das linhas ordenadas segundo o comprimento das sepalas #compara com o original: sum(iris$Sepal.Length[idx]==iris$Sepal.Length)==nrow(iris) #é FALSO porque em iris as linhas não estão originalmente ordenadas segundo o comprimento. #vamos mudar isso novo.iris = iris[idx,] #pego o vetor de indices dos valores ordenados e uso na indexacao para ordenar o objeto original segunda a coluna escolhida idx2 = order(novo.iris$Sepal.Length) #indice das linhas ordenadas segundo o comprimento das sepalas #note que agora essa expressão é verdadeira, porque o original já está ordenado segundo essa coluna sum(novo.iris$Sepal.Length[idx2]==novo.iris$Sepal.Length)==nrow(novo.iris) #é FALSO #AGORA ORDENANDO POR MULTIPLAS COLUNAS idx = order(iris$Species,iris$Sepal.Length, decreasing=TRUE) #por especie e por sepala em ordem decrescente #ordena segundo essas duas colunas novo.iris = iris[idx,] novo.iris[,c(&quot;Species&quot;,&quot;Sepal.Length&quot;)] #para cada especie esta ordenado por sepala: novo.iris[novo.iris$Species==&quot;versicolor&quot;,]$Sepal.Length novo.iris[novo.iris$Species==&quot;virginica&quot;,]$Sepal.Length 5.4 Importanto e exportando dados no R ATENÇÃO! Se você utiliza Windows, e no seu gerenciador de arquivos os arquivos aparecem sem extensão (.csv, .txt, .doc etc.), mude nas suas preferências para não ocultar extensões de arquivos conhecidos. Dessa forma você consegue ver os arquivos pelo tipo (extensão). Existem diversas funções para importar dados para objetos do R, incluindo funções para ler arquivos do Excel (.xls, ou .xlsx), arquivos XML, arquivos *.DBF etc. O R também tem pacotes que interagem diretamente com bancos de dados (mysql, postgres, sql etc.). Não cobriremos a importação desses tipos aqui, mas você pode pesquisar sozinho no rede. É frequente encontrarmos problemas de acentuação e na transferibilidade entre sistemas operacionais diferentes (Mac, Linux, Windows). A palavra chave aqui é codificação de caracteres (em inglês, “character encoding”). 5.4.1 Arquivos de texto simples para estocar dados Muitos dados que obtemos online e os próprios scripts do R são do formato mais simples que existe, que são arquivos de texto, geralmente arquivos salvos com extensões .csv ou .txt. Arquivos desse tipo podem ser abertos em qualquer editor de texto, em qualquer sistema operacional e em qualquer versão. Isso garante arquivamento, longevidade e transferibilidade. Portanto, é a melhor forma de salvar seus dados e compartilhá-los. Qualquer arquivo desse tipo pode ser lido pelos os editores de script do R ou RStudio. Pode também exportar planilhas do Excel ou LibreOffice (e afins) para esse formato. Vamos nos concentrar neste curso em lidar com arquivos deste tipo. É importante atentar em arquivos de texto contendo dados tabulados para: O separador das colunas pode ser ;, tabulação (no R = ’‘’), ,, ou qualquer símbolo que indique a separação das colunas (ou seja não está nas células); Casas decimais podem ser separadas por . ou ,. DICA: Procure saber como seus dados estão antes de tentar importá-los, de forma a indicar corretamente o delimitador e o separador das casas decimais adequados. Você evitará assim muita dor de cabeça! Datas - colunas com datas constituem um objeto de classe date no R, que a converte em número que pode ser usado em operações matemáticas. Dependendo de como seus dados estão formatados no original, é comum a inversão de mês com dia entre, por exemplo, o sistema inglês (MM-DD-YYYY) e o sistema português (DD-MM-YYYY). Tenha controle disso! Por isso, recomenda-se que: Defina um padrão que você sempre usará para formatar seus dados ANTES de importá-los ao R. Dessa forma você irá memorizar rapidamente como importar os dados do jeito que você sempre prepara; Padronize a codificação dos caracteres (UTF8 é padrão Mac e Linux; Latin1 é padrão Windows) em arquivos .txt; Padronize o separador de casa decimal (ponto ou vírgula?); Pradonize a quebra de linha, i.e., o que indica no texto o início de uma nova linha (novamente, isso é diferente entre Mac, Linux e Windows); Padronize se colunas de texto vão entre aspas; Padronize como você dá nome às colunas; nome de colunas e de linhas não devem ser muito longos, e deve-se evitar acentos ou espaços em branco em nomes de colunas. Isso é muito importante! Se você usa planilhas, recomendamos usar uma versão de software livre da família LibreOffice/OpenOffice pois eles permitem um maior controle da exportação dos dados, o que inclui controlar o tipo de codificação de caracter dos dados de saída e também separadores das colunas, anto para ler como para salvar arquivos de planilhas. 5.4.2 Importando dados 5.4.2.1 Pacote base do R A principal função para importar dados no R é read.table(). Ela funciona para importar arquivos em formato de texto simples (.csv, .txt). Vamos utilizar um arquivo contendo as coordenadas geográficas dos municípios brasileiros para praticar a importação dos dados (http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=disciplinas:bot89_2013:exercicio08:municipiosbrasil.csv). Baixe-o para a sua pasta de trabalho. Em seguida, abra o arquivo com um editor de texto simples (Bloco de Notas, Notepad++, TextWrangler, Gedit, etc.) e veja como ele está formatado. Verifique: Qual é o separador de colunas?; Qual é a codificação dos caracteres? (consegue ver e editar isso no seu editor?); Qual é a quebra de linha? (consegue ver e editar isso no seu editor? Aspas duplas ou simples definem colunas? (este arquivo não tem nenhuma aspas!) Vamos agora abrir este arquivo no LibreOffice (ou similar, como o Excel). Busque os comandos de importação para poder importar o arquivo de texto1. Veja os controles na importação quanto aos elementos acima: Salve o arquivo como *.ods; Salve novamente como *.csv - veja como você tem controle na exportação quanto aos elementos acima. # se você colocou o arquivo na sua pasta de trabalho, ele deve estar visível por dir(pattern = &quot;csv&quot;) # então posso ler sem precisar especificar o caminho até o arquivo # veja o help da função antes de começar ?read.table # os seguintes argumentos são mais importantes: # sep = &quot; &quot; #o codigo que separa as colunas, o padrão é espaço # quote = &quot;\\&quot;&#39;&quot; #o que define células de texto - o padrão é interpretar tanto aspa simples como dupla presentes # dec = &quot;.&quot; #ponto é a casa decimal padrão # header = FALSE #a primeira linha não tem o nome de colunas # as.is = FALSE #o padrão é converter texto em fatores, se usar T não fará isso # na.strings #se definir, pode informar aqui que símbolos em células inteiras que sejam interpretados como valores ausentes (NA) # encoding #codificação da acentuação. o padrão é &#39;unknown&#39; (desconhecido), na qual ele reconhece segundo o sistema operacional. As opções mais usadas são &#39;latin1&#39; ou &#39;utf8&#39; e alterne com isso se você tem problemas com acentos. # o arquivo original tem os seguintes formatos: # colunas separadas por tabulação (no R isso é definido pela expressão regular &quot;\\t&quot;) # decimal com ponto # não tem aspas definindo as colunas de texto. # a primeira linha é o nome das colunas. # Então, para ler posso usar: dd &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = T) class(dd) # data.frame dim(dd) # dimensão do objeto head(dd) # cabeçalho do data.frame # veja o que aconteceria se eu achasse que no meu arquivo as colunas são separadas por vírgula dd2 &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;,&quot;, header = T) head(dd2) dim(dd2) # apenas 1 coluna, porque o separador informado não é o mesmo dos dados # e se o encoding do meu arquivo estiver errado? dd3 &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = T, encoding = &quot;latin1&quot;) dd3[5562,] # veja o que aconteceu com os acentos nessa linha dd[5562,] # no original o encoding não é &quot;latin1&quot; # veja a estrutura do objeto correto str(dd) # Poxa, todas as colunas são fatores, mesmo as colunas Latitude e Longitude que são numéricas. # Deve ter algum valor nessas colunas que não são numéricos. # Quais são? vl &lt;- is.na(as.numeric(as.vector(dd$Latitude))) # quais são NA quando eu converto para numérico? Pois esses devem ser valores de texto e não numéricos. Note que converti o fator para vetor antes de converter para numérico. A função is.na pergunta o que é NA, pois os textos que não podem ser convertidos para número serão valores ausentes (NA) sum(vl) dd[vl,] # essas linhas tem a palavra &quot;NULL&quot; para Latitude e Longitude no arquivo original (volte lá para confirmar), e o R não reconheceu isso como ausente NA. Como vetores devem ser da mesma classe, os números dessas colunas foram codificados como texto e as colunas convertidas a fatores de texto que é o padrão da função read.table() Podemos usar o argumento na.strings para corrigir isso durante a importação: dd4 &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = T, dec = &quot;.&quot;, na.strings = c(&quot;NULL&quot;, &quot;NA&quot;, &quot;&quot;)) # qualquer CELULA INTEIRA que contenha NULL ou NA ou esteja vazia SERÁ INTERPRETADA COMO VALOR AUSENTE e codificada como NA no R. str(dd4) # note que agora as colunas Latitude e Longitude foram interpretadas como número # mas o que acontece se informamos mal a casa decimal? dd5 &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = T, dec = &quot;,&quot;, na.strings = c(&quot;NULL&quot;, &quot;NA&quot;, &quot;&quot;)) str(dd5) # como tem ponto como definição de casa decimal no arquivo de dados, as colunas numéricas foram novamente interpretadas como texto. # Texto como vetores ou fatores? dd4 &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = T, dec = &quot;.&quot;, na.strings = c(&quot;NULL&quot;, &quot;NA&quot;, &quot;&quot;)) str(dd4) # todas as colunas de texto neste objeto foram interpretadas como fatores # o argumento as.is permite corrigir isso. &quot;as is&quot; significa &quot;como está&quot; nos dados originais, então valores de texto são lidos como vetores de caracteres não codificados em fatores. dd6 &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = T, dec = &quot;.&quot;, na.strings = c(&quot;NULL&quot;, &quot;NA&quot;, &quot;&quot;), as.is = TRUE ) str(dd6) # diferentemente do objeto anterior, não há mais fatores # Lembram que colocamos o endereco do arquivo mais acima? # podemos usar um endereco da internet para baixar um arquivo dd7 &lt;- read.table( &quot;http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=disciplinas:bot89_2013:exercicio08:municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = TRUE ) dd7 head(dd7) # a função read.table tem vários outros argumentos. Veja o help e entenda isso bem. 5.4.2.2 Pacote readr A principal função para ler arquivos do pacote readr se chama read_delim(). Funciona de maneira parecida com o read.table() com algumas pequenas diferenças: não converte colunas de texto que possam ser categorizadas em fatores (read.table() faz isso por padrão), retorna um tibble no lugar de um data.frame (tibbles são data.frames diferentes na maneira como aparecem no console; além de mostrar apenas uma porção dos dados, para cada coluna há a indicação do tipo de variável presente), assume por padrão que o dado importado possui cabeçalho. Existem outras diferenças que podem ser melhor entendidas na página do pacote (https://github.com/tidyverse/readr). Os argumentos possuem nomes diferentes do que os utilizados em read.table() e, como este, importa arquivos em formato de texto simples (.csv , .txt). # pacote readr # usando como exemplo o mesmo arquivo municipiosbrasil.csv library(&quot;readr&quot;) rr1 &lt;- read_delim(&quot;municipiosbrasil.csv&quot;, delim = &quot;\\t&quot;) rr1 dd7 dim(rr1) dim(dd7) rr2 &lt;- read_delim(&quot;http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=disciplinas:bot89_2013:exercicio08:municipiosbrasil.csv&quot;, delim = &quot;\\t&quot;) rr2 5.4.2.3 Pacote data.table A principal função para ler arquivos do pacote data.table se chama fread(). Este pacote é muito conhecido devido à velocidade de suas ações, funcionando perfeitamente para dados grandes. Esta função possui uma particularidade: o usuário não precisa indicar o separador; automaticamente ele descobre o separador e lê o arquivo. Em casos especiais, é necessário a indicação do separador com o argumento sep, igual ao read.table(). Ao ler um arquivo, a função retorna também um data.frame, porém com certas particularidades quanto à impressão do resultado na tela do console, como acontece com a função read_delim() do pacote readr. Mais informações, leiam atentamente o site do pacote: https://github.com/Rdatatable/data.table. O pacote como um todo é uma excelente ferramenta na manipulação de dados. Como os pacotes citados acima, esta função é capaz de importar arquivos em formato de texto simples (.csv , .txt). # pacote data.table # usando como exemplo o mesmo arquivo municipiosbrasil.csv library(&quot;data.table&quot;) dt1 &lt;- fread(&quot;municipiosbrasil.csv&quot;) dt1 dt2 &lt;- fread(&quot;http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=disciplinas:bot89_2013:exercicio08:municipiosbrasil.csv&quot;) dt2 5.4.2.4 Importando do Excel diretamente Os principais erros aqui podem ser por células unidas, cabeçalhos no topo da planilha, e acentos. Veja o ? das funções usadas para conhecer parâmetros opcionais para resolver esses possíveis problemas. # instale o pacote library(&quot;readxl&quot;) # se o arquivo for xls # Salve o arquivo municipiosbrasil.csv como xlsx ou xls meuxlsx &lt;- &quot;municipiosbrasil.xlsx&quot; dd &lt;- read_excel(path = meuxlsx, sheet = 1) dd dd &lt;- as.data.frame(dd) dd # se o arquivo for xls meuxls &lt;- &quot;municipiosbrasil.xls&quot; dd &lt;- read_excel(path = meuxls, sheet = 1) dd dd &lt;- as.data.frame(dd) dd 5.4.3 Exportando dados 5.4.3.1 Pacote base do R A principal função do pacote base do R se chama write.table() e trata-se da função base para exportar seus dados do R. Ela funciona para exportar arquivos em formato de texto simples (.csv, .txt) e usa basicamente os mesmos argumentos da função read.table(). ?write.table # veja o help - recomendo usar essa função genérica e evitar de usar atalhos tipo write.csv, que no fundo usam esta mesma função # vamos usar o mesmo arquivo dir(pattern = &quot;csv&quot;) # ler o arquivo para o R para ter algo a exportar dd &lt;- read.table(file = &quot;municipiosbrasil.csv&quot;, sep = &quot;\\t&quot;, header = T, dec = &quot;.&quot;, na.strings = c(&quot;NULL&quot;, &quot;NA&quot;, &quot;&quot;), as.is = TRUE) str(dd) # diferentemente do objeto anterior, não há mais fatores # filtrando apenas para municipios do Amazonas: vl &lt;- dd$Province %in% &quot;Amazonas&quot; sum(vl) # quantos são? # ou, desse jeito que é identico: vl &lt;- dd$Province == &quot;Amazonas&quot; sum(vl) dd.am &lt;- dd[vl, ] nrow(dd.am) == sum(vl) # deve ser verdadeiro, certo? # salvando esses dados num novo arquivo com diferentes formatações: # separado por tabulação e textos sem aspas e células NA sem nada write.table(dd.am, file = &quot;muni-am1.csv&quot;, sep = &quot;\\t&quot;, na = &quot;&quot;, quote = FALSE) # separado por tabulação e textos com aspas e células NA sem nada write.table(dd.am, file = &quot;muni-am2.csv&quot;, sep = &quot;\\t&quot;, na = &quot;&quot;, quote = TRUE) # separado por vírgula e textos com aspas e células NA com a palavra valor.ausente write.table(dd.am, file = &quot;muni-am3.csv&quot;, sep = &quot;,&quot;, na = &quot;valor.ausente&quot;, quote = TRUE) # separado por vírgula e textos com aspas e células NA vazios e não adicona nomes das linhas como primeira coluna (row.names=FALSE). Pode deslocar a primeira linha na sua planilha SE você NAO USAR este argumento) write.table(dd.am, file = &quot;muni-am4.csv&quot;, sep = &quot;,&quot;, na = &quot;&quot;, quote = TRUE, row.names = FALSE) # separado por tabulação e textos sem aspas e células NA vazias, sem nomes das linhas, e quebra de linha no formato do windows (eol = &quot;\\r\\n&quot;) write.table(dd.am, file = &quot;muni-am5.csv&quot;, sep = &quot;,&quot;, na = &quot;&quot;, quote = TRUE, row.names = FALSE, eol = &quot;\\r\\n&quot;) # ABRA OS ARQUIVOS GERADOS NO SEU EDITOR DE TEXTO E COMPARE AS FORMATAÇÕES GERADAS 5.4.3.2 Pacote readr A principal função do pacote readr se chama write_delim e exporta data.frames em formato de texto simples (.csv, .txt), utilizando basicamente os mesmos argumentos da função read_delim, pertencente ao mesmo pacote. # exportando dados com pacote readr # utilizando mesmo objeto criado com pacote base write_delim(dd.am, &quot;muni-am6.csv&quot;, delim = &quot;\\t&quot;) write_delim(dd.am, &quot;muni-am7.csv&quot;, delim = &quot;;&quot;) 5.4.3.3 Pacote data.table fwrite - principal função do pacote data.table para exportar data.frames em formato de texto simples (.csv, .txt) e usa basicamente os mesmos argumentos da função read_delim, pertencente ao mesmo pacote. # exportando dados com pacote data.table # utilizando mesmo objeto criado com pacote base fwrite(dd.am, &quot;muni-am8.csv&quot;, sep = &quot;\\t&quot;) 5.4.4 Outras funções úteis A função scan() lê um arquivo de texto em qualquer formato para um vetor ou lista no R. Trata-se de uma função genérica que é bom memorizar. # vamos usar o mesmo arquivo dir(pattern = &quot;csv&quot;) # esta função é muito util para ler linha por linha um arquivo de texto que você quer explorar. dd &lt;- scan(file = &quot;municipiosbrasil.csv&quot;, what = &quot;complex&quot;, sep = &quot;\\n&quot;) class(dd) length(dd) # cada linha é um elemento do vetor dd[1] # usando tabulação dd2 &lt;- scan(file = &quot;municipiosbrasil.csv&quot;, what = &quot;complex&quot;, sep = &quot;\\t&quot;) class(dd2) length(dd2) # cada célula é um elemento deste vetor dd2[1:5] # nao faz muito sentido com esses dados que tem formato de tabela, mas essa função pode ser usada com qualquer arquivo de tipo texto, por exemplo: # de um artigo no qual você quer buscar palavras e tabular palavras chaves? # num log de uma análise feita por outro software (nao no R) do qual você quer extrair resultados a partir da lógica complicada do texto de resultado) # etc. Isso é mais fácil de ser feito no LibreOffice/OpenOffice↩︎ "],["objeto-iii-listas-e-objetos-complexos.html", "6 Objeto III - Listas e objetos complexos 6.1 Listas 6.2 Objetos complexos", " 6 Objeto III - Listas e objetos complexos 6.1 Listas O resultado de muitas análises são objetos de classe list e você precisa entender o que isso significa. Listas permitem organizar diferentes classes de objetos numa estrutura hierárquica organizada. Uma mesma lista pode incluir elementos que são vetores de qualquer classe, matrizes, data.frames etc. Listas são criadas pela função list(). A indexação de listas é dado pelo operador [[indice_ou_nome]] ou lista$ seguida do nome (se os elementos da lista tem nome; e.g. lista$nomeDeUmElementoDaLista). ?list #veja o help list R Documentation Lists – Generic and Dotted Pairs Description Functions to construct, coerce and check for both kinds of R lists. Usage list(...) pairlist(...) as.list(x, ...) ## S3 method for class 'environment' as.list(x, all.names = FALSE, sorted = FALSE, ...) as.pairlist(x) is.list(x) is.pairlist(x) alist(...) Arguments … objects, possibly named. x object to be coerced or tested. all.names a logical indicating whether to copy all values or (default) only those whose names do not begin with a dot. sorted a logical indicating whether the names of the resulting list should be sorted (increasingly). Note that this is somewhat costly, but may be useful for comparison of environments. Details Almost all lists in R internally are Generic Vectors, whereas traditional dotted pair lists (as in LISP) remain available but rarely seen by users (except as formals of functions). The arguments to list or pairlist are of the form value or tag = value. The functions return a list or dotted pair list composed of its arguments with each value either tagged or untagged, depending on how the argument was specified. alist handles its arguments as if they described function arguments. So the values are not evaluated, and tagged arguments with no value are allowed whereas list simply ignores them. alist is most often used in conjunction with formals. as.list attempts to coerce its argument to a list. For functions, this returns the concatenation of the list of formal arguments and the function body. For expressions, the list of constituent elements is returned. as.list is generic, and as the default method calls as.vector(mode = “list”) for a non-list, methods for as.vector may be invoked. as.list turns a factor into a list of one-element factors. Attributes may be dropped unless the argument already is a list or expression. (This is inconsistent with functions such as as.character which always drop attributes, and is for efficiency since lists can be expensive to copy.) is.list returns TRUE if and only if its argument is a list or a pairlist of length &gt; 0. is.pairlist returns TRUE if and only if the argument is a pairlist or NULL (see below). The “environment” method for as.list copies the name-value pairs (for names not beginning with a dot) from an environment to a named list. The user can request that all named objects are copied. Unless sorted = TRUE, the list is in no particular order (the order depends on the order of creation of objects and whether the environment is hashed). No enclosing environments are searched. (Objects copied are duplicated so this can be an expensive operation.) Note that there is an inverse operation, the as.environment() method for list objects. An empty pairlist, pairlist() is the same as NULL. This is different from list(): some but not all operations will promote an empty pairlist to an empty list. as.pairlist is implemented as as.vector(x, “pairlist”), and hence will dispatch methods for the generic function as.vector. Lists are copied element-by-element into a pairlist and the names of the list used as tags for the pairlist: the return value for other types of argument is undocumented. list, is.list and is.pairlist are primitive functions. References Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth &amp; Brooks/Cole. See Also vector(“list”, length) for creation of a list with empty components; c, for concatenation; formals. unlist is an approximate inverse to as.list(). ‘plotmath’ for the use of list in plot annotation. Examples require(graphics) # create a plotting structure pts &lt;- list(x = cars[,1], y = cars[,2]) plot(pts) is.pairlist(.Options) # a user-level pairlist ## \"pre-allocate\" an empty list of length 5 vector(\"list\", 5) # Argument lists f &lt;- function() x # Note the specification of a \"...\" argument: formals(f) &lt;- al &lt;- alist(x = , y = 2+3, ... = ) f al ## environment-&gt;list coercion e1 &lt;- new.env() e1$a &lt;- 10 e1$b &lt;- 20 as.list(e1) #um vetor simples v1 = 1:10 class(v1) ## [1] &quot;integer&quot; #outro vetor simples v2 = LETTERS class(v2) ## [1] &quot;character&quot; #uma matriz simples mm = matrix(1:9,nrow=3,ncol=3) class(mm) ## [1] &quot;matrix&quot; &quot;array&quot; #um data.frame dd = iris dd Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa 5.4 3.4 1.7 0.2 setosa 5.1 3.7 1.5 0.4 setosa 4.6 3.6 1.0 0.2 setosa 5.1 3.3 1.7 0.5 setosa 4.8 3.4 1.9 0.2 setosa 5.0 3.0 1.6 0.2 setosa 5.0 3.4 1.6 0.4 setosa 5.2 3.5 1.5 0.2 setosa 5.2 3.4 1.4 0.2 setosa 4.7 3.2 1.6 0.2 setosa 4.8 3.1 1.6 0.2 setosa 5.4 3.4 1.5 0.4 setosa 5.2 4.1 1.5 0.1 setosa 5.5 4.2 1.4 0.2 setosa 4.9 3.1 1.5 0.2 setosa 5.0 3.2 1.2 0.2 setosa 5.5 3.5 1.3 0.2 setosa 4.9 3.6 1.4 0.1 setosa 4.4 3.0 1.3 0.2 setosa 5.1 3.4 1.5 0.2 setosa 5.0 3.5 1.3 0.3 setosa 4.5 2.3 1.3 0.3 setosa 4.4 3.2 1.3 0.2 setosa 5.0 3.5 1.6 0.6 setosa 5.1 3.8 1.9 0.4 setosa 4.8 3.0 1.4 0.3 setosa 5.1 3.8 1.6 0.2 setosa 4.6 3.2 1.4 0.2 setosa 5.3 3.7 1.5 0.2 setosa 5.0 3.3 1.4 0.2 setosa 7.0 3.2 4.7 1.4 versicolor 6.4 3.2 4.5 1.5 versicolor 6.9 3.1 4.9 1.5 versicolor 5.5 2.3 4.0 1.3 versicolor 6.5 2.8 4.6 1.5 versicolor 5.7 2.8 4.5 1.3 versicolor 6.3 3.3 4.7 1.6 versicolor 4.9 2.4 3.3 1.0 versicolor 6.6 2.9 4.6 1.3 versicolor 5.2 2.7 3.9 1.4 versicolor 5.0 2.0 3.5 1.0 versicolor 5.9 3.0 4.2 1.5 versicolor 6.0 2.2 4.0 1.0 versicolor 6.1 2.9 4.7 1.4 versicolor 5.6 2.9 3.6 1.3 versicolor 6.7 3.1 4.4 1.4 versicolor 5.6 3.0 4.5 1.5 versicolor 5.8 2.7 4.1 1.0 versicolor 6.2 2.2 4.5 1.5 versicolor 5.6 2.5 3.9 1.1 versicolor 5.9 3.2 4.8 1.8 versicolor 6.1 2.8 4.0 1.3 versicolor 6.3 2.5 4.9 1.5 versicolor 6.1 2.8 4.7 1.2 versicolor 6.4 2.9 4.3 1.3 versicolor 6.6 3.0 4.4 1.4 versicolor 6.8 2.8 4.8 1.4 versicolor 6.7 3.0 5.0 1.7 versicolor 6.0 2.9 4.5 1.5 versicolor 5.7 2.6 3.5 1.0 versicolor 5.5 2.4 3.8 1.1 versicolor 5.5 2.4 3.7 1.0 versicolor 5.8 2.7 3.9 1.2 versicolor 6.0 2.7 5.1 1.6 versicolor 5.4 3.0 4.5 1.5 versicolor 6.0 3.4 4.5 1.6 versicolor 6.7 3.1 4.7 1.5 versicolor 6.3 2.3 4.4 1.3 versicolor 5.6 3.0 4.1 1.3 versicolor 5.5 2.5 4.0 1.3 versicolor 5.5 2.6 4.4 1.2 versicolor 6.1 3.0 4.6 1.4 versicolor 5.8 2.6 4.0 1.2 versicolor 5.0 2.3 3.3 1.0 versicolor 5.6 2.7 4.2 1.3 versicolor 5.7 3.0 4.2 1.2 versicolor 5.7 2.9 4.2 1.3 versicolor 6.2 2.9 4.3 1.3 versicolor 5.1 2.5 3.0 1.1 versicolor 5.7 2.8 4.1 1.3 versicolor 6.3 3.3 6.0 2.5 virginica 5.8 2.7 5.1 1.9 virginica 7.1 3.0 5.9 2.1 virginica 6.3 2.9 5.6 1.8 virginica 6.5 3.0 5.8 2.2 virginica 7.6 3.0 6.6 2.1 virginica 4.9 2.5 4.5 1.7 virginica 7.3 2.9 6.3 1.8 virginica 6.7 2.5 5.8 1.8 virginica 7.2 3.6 6.1 2.5 virginica 6.5 3.2 5.1 2.0 virginica 6.4 2.7 5.3 1.9 virginica 6.8 3.0 5.5 2.1 virginica 5.7 2.5 5.0 2.0 virginica 5.8 2.8 5.1 2.4 virginica 6.4 3.2 5.3 2.3 virginica 6.5 3.0 5.5 1.8 virginica 7.7 3.8 6.7 2.2 virginica 7.7 2.6 6.9 2.3 virginica 6.0 2.2 5.0 1.5 virginica 6.9 3.2 5.7 2.3 virginica 5.6 2.8 4.9 2.0 virginica 7.7 2.8 6.7 2.0 virginica 6.3 2.7 4.9 1.8 virginica 6.7 3.3 5.7 2.1 virginica 7.2 3.2 6.0 1.8 virginica 6.2 2.8 4.8 1.8 virginica 6.1 3.0 4.9 1.8 virginica 6.4 2.8 5.6 2.1 virginica 7.2 3.0 5.8 1.6 virginica 7.4 2.8 6.1 1.9 virginica 7.9 3.8 6.4 2.0 virginica 6.4 2.8 5.6 2.2 virginica 6.3 2.8 5.1 1.5 virginica 6.1 2.6 5.6 1.4 virginica 7.7 3.0 6.1 2.3 virginica 6.3 3.4 5.6 2.4 virginica 6.4 3.1 5.5 1.8 virginica 6.0 3.0 4.8 1.8 virginica 6.9 3.1 5.4 2.1 virginica 6.7 3.1 5.6 2.4 virginica 6.9 3.1 5.1 2.3 virginica 5.8 2.7 5.1 1.9 virginica 6.8 3.2 5.9 2.3 virginica 6.7 3.3 5.7 2.5 virginica 6.7 3.0 5.2 2.3 virginica 6.3 2.5 5.0 1.9 virginica 6.5 3.0 5.2 2.0 virginica 6.2 3.4 5.4 2.3 virginica 5.9 3.0 5.1 1.8 virginica class(dd) ## [1] &quot;data.frame&quot; #criamos uma lista simples v1 ## [1] 1 2 3 4 5 6 7 8 9 10 v2 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; mm ## Warning in kable_pipe(x = structure(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, : The ## table should have a header (column names) 1 4 7 2 5 8 3 6 9 dd Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa 5.4 3.4 1.7 0.2 setosa 5.1 3.7 1.5 0.4 setosa 4.6 3.6 1.0 0.2 setosa 5.1 3.3 1.7 0.5 setosa 4.8 3.4 1.9 0.2 setosa 5.0 3.0 1.6 0.2 setosa 5.0 3.4 1.6 0.4 setosa 5.2 3.5 1.5 0.2 setosa 5.2 3.4 1.4 0.2 setosa 4.7 3.2 1.6 0.2 setosa 4.8 3.1 1.6 0.2 setosa 5.4 3.4 1.5 0.4 setosa 5.2 4.1 1.5 0.1 setosa 5.5 4.2 1.4 0.2 setosa 4.9 3.1 1.5 0.2 setosa 5.0 3.2 1.2 0.2 setosa 5.5 3.5 1.3 0.2 setosa 4.9 3.6 1.4 0.1 setosa 4.4 3.0 1.3 0.2 setosa 5.1 3.4 1.5 0.2 setosa 5.0 3.5 1.3 0.3 setosa 4.5 2.3 1.3 0.3 setosa 4.4 3.2 1.3 0.2 setosa 5.0 3.5 1.6 0.6 setosa 5.1 3.8 1.9 0.4 setosa 4.8 3.0 1.4 0.3 setosa 5.1 3.8 1.6 0.2 setosa 4.6 3.2 1.4 0.2 setosa 5.3 3.7 1.5 0.2 setosa 5.0 3.3 1.4 0.2 setosa 7.0 3.2 4.7 1.4 versicolor 6.4 3.2 4.5 1.5 versicolor 6.9 3.1 4.9 1.5 versicolor 5.5 2.3 4.0 1.3 versicolor 6.5 2.8 4.6 1.5 versicolor 5.7 2.8 4.5 1.3 versicolor 6.3 3.3 4.7 1.6 versicolor 4.9 2.4 3.3 1.0 versicolor 6.6 2.9 4.6 1.3 versicolor 5.2 2.7 3.9 1.4 versicolor 5.0 2.0 3.5 1.0 versicolor 5.9 3.0 4.2 1.5 versicolor 6.0 2.2 4.0 1.0 versicolor 6.1 2.9 4.7 1.4 versicolor 5.6 2.9 3.6 1.3 versicolor 6.7 3.1 4.4 1.4 versicolor 5.6 3.0 4.5 1.5 versicolor 5.8 2.7 4.1 1.0 versicolor 6.2 2.2 4.5 1.5 versicolor 5.6 2.5 3.9 1.1 versicolor 5.9 3.2 4.8 1.8 versicolor 6.1 2.8 4.0 1.3 versicolor 6.3 2.5 4.9 1.5 versicolor 6.1 2.8 4.7 1.2 versicolor 6.4 2.9 4.3 1.3 versicolor 6.6 3.0 4.4 1.4 versicolor 6.8 2.8 4.8 1.4 versicolor 6.7 3.0 5.0 1.7 versicolor 6.0 2.9 4.5 1.5 versicolor 5.7 2.6 3.5 1.0 versicolor 5.5 2.4 3.8 1.1 versicolor 5.5 2.4 3.7 1.0 versicolor 5.8 2.7 3.9 1.2 versicolor 6.0 2.7 5.1 1.6 versicolor 5.4 3.0 4.5 1.5 versicolor 6.0 3.4 4.5 1.6 versicolor 6.7 3.1 4.7 1.5 versicolor 6.3 2.3 4.4 1.3 versicolor 5.6 3.0 4.1 1.3 versicolor 5.5 2.5 4.0 1.3 versicolor 5.5 2.6 4.4 1.2 versicolor 6.1 3.0 4.6 1.4 versicolor 5.8 2.6 4.0 1.2 versicolor 5.0 2.3 3.3 1.0 versicolor 5.6 2.7 4.2 1.3 versicolor 5.7 3.0 4.2 1.2 versicolor 5.7 2.9 4.2 1.3 versicolor 6.2 2.9 4.3 1.3 versicolor 5.1 2.5 3.0 1.1 versicolor 5.7 2.8 4.1 1.3 versicolor 6.3 3.3 6.0 2.5 virginica 5.8 2.7 5.1 1.9 virginica 7.1 3.0 5.9 2.1 virginica 6.3 2.9 5.6 1.8 virginica 6.5 3.0 5.8 2.2 virginica 7.6 3.0 6.6 2.1 virginica 4.9 2.5 4.5 1.7 virginica 7.3 2.9 6.3 1.8 virginica 6.7 2.5 5.8 1.8 virginica 7.2 3.6 6.1 2.5 virginica 6.5 3.2 5.1 2.0 virginica 6.4 2.7 5.3 1.9 virginica 6.8 3.0 5.5 2.1 virginica 5.7 2.5 5.0 2.0 virginica 5.8 2.8 5.1 2.4 virginica 6.4 3.2 5.3 2.3 virginica 6.5 3.0 5.5 1.8 virginica 7.7 3.8 6.7 2.2 virginica 7.7 2.6 6.9 2.3 virginica 6.0 2.2 5.0 1.5 virginica 6.9 3.2 5.7 2.3 virginica 5.6 2.8 4.9 2.0 virginica 7.7 2.8 6.7 2.0 virginica 6.3 2.7 4.9 1.8 virginica 6.7 3.3 5.7 2.1 virginica 7.2 3.2 6.0 1.8 virginica 6.2 2.8 4.8 1.8 virginica 6.1 3.0 4.9 1.8 virginica 6.4 2.8 5.6 2.1 virginica 7.2 3.0 5.8 1.6 virginica 7.4 2.8 6.1 1.9 virginica 7.9 3.8 6.4 2.0 virginica 6.4 2.8 5.6 2.2 virginica 6.3 2.8 5.1 1.5 virginica 6.1 2.6 5.6 1.4 virginica 7.7 3.0 6.1 2.3 virginica 6.3 3.4 5.6 2.4 virginica 6.4 3.1 5.5 1.8 virginica 6.0 3.0 4.8 1.8 virginica 6.9 3.1 5.4 2.1 virginica 6.7 3.1 5.6 2.4 virginica 6.9 3.1 5.1 2.3 virginica 5.8 2.7 5.1 1.9 virginica 6.8 3.2 5.9 2.3 virginica 6.7 3.3 5.7 2.5 virginica 6.7 3.0 5.2 2.3 virginica 6.3 2.5 5.0 1.9 virginica 6.5 3.0 5.2 2.0 virginica 6.2 3.4 5.4 2.3 virginica 5.9 3.0 5.1 1.8 virginica ml = list(v1,v2,mm,dd) class(ml) #deve ser lista ## [1] &quot;list&quot; length(ml) #número de elementos ## [1] 4 names(ml) #os elementos dessa lista não tem nome ## NULL str(ml) #veja a estrutura do objeto ## List of 4 ## $ : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## $ : chr [1:26] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## $ : int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## $ :&#39;data.frame&#39;: 150 obs. of 5 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..$ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ml[[1]] #o elemento 1 é o vetor ## [1] 1 2 3 4 5 6 7 8 9 10 ml[[2]] #o segundo também ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; ml[[1:2]] #note que retorna apenas o segundo... nao funciona como vetor para pegar mais de um elemento, pois a estrutura é complexa ## [1] 2 ml[[1]][3] #terceiro elemento do vetor que está no elemento 1 da lista ## [1] 3 ml[[3]] #é uma matrix ## Warning in kable_pipe(x = structure(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, : The ## table should have a header (column names) 1 4 7 2 5 8 3 6 9 ml[[3]][1,3] #valor da primeira linha e da terceira coluna da matrix que o objeto 2 da lista ## [1] 7 ml[[4]] #é uma data.frame Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa 5.4 3.4 1.7 0.2 setosa 5.1 3.7 1.5 0.4 setosa 4.6 3.6 1.0 0.2 setosa 5.1 3.3 1.7 0.5 setosa 4.8 3.4 1.9 0.2 setosa 5.0 3.0 1.6 0.2 setosa 5.0 3.4 1.6 0.4 setosa 5.2 3.5 1.5 0.2 setosa 5.2 3.4 1.4 0.2 setosa 4.7 3.2 1.6 0.2 setosa 4.8 3.1 1.6 0.2 setosa 5.4 3.4 1.5 0.4 setosa 5.2 4.1 1.5 0.1 setosa 5.5 4.2 1.4 0.2 setosa 4.9 3.1 1.5 0.2 setosa 5.0 3.2 1.2 0.2 setosa 5.5 3.5 1.3 0.2 setosa 4.9 3.6 1.4 0.1 setosa 4.4 3.0 1.3 0.2 setosa 5.1 3.4 1.5 0.2 setosa 5.0 3.5 1.3 0.3 setosa 4.5 2.3 1.3 0.3 setosa 4.4 3.2 1.3 0.2 setosa 5.0 3.5 1.6 0.6 setosa 5.1 3.8 1.9 0.4 setosa 4.8 3.0 1.4 0.3 setosa 5.1 3.8 1.6 0.2 setosa 4.6 3.2 1.4 0.2 setosa 5.3 3.7 1.5 0.2 setosa 5.0 3.3 1.4 0.2 setosa 7.0 3.2 4.7 1.4 versicolor 6.4 3.2 4.5 1.5 versicolor 6.9 3.1 4.9 1.5 versicolor 5.5 2.3 4.0 1.3 versicolor 6.5 2.8 4.6 1.5 versicolor 5.7 2.8 4.5 1.3 versicolor 6.3 3.3 4.7 1.6 versicolor 4.9 2.4 3.3 1.0 versicolor 6.6 2.9 4.6 1.3 versicolor 5.2 2.7 3.9 1.4 versicolor 5.0 2.0 3.5 1.0 versicolor 5.9 3.0 4.2 1.5 versicolor 6.0 2.2 4.0 1.0 versicolor 6.1 2.9 4.7 1.4 versicolor 5.6 2.9 3.6 1.3 versicolor 6.7 3.1 4.4 1.4 versicolor 5.6 3.0 4.5 1.5 versicolor 5.8 2.7 4.1 1.0 versicolor 6.2 2.2 4.5 1.5 versicolor 5.6 2.5 3.9 1.1 versicolor 5.9 3.2 4.8 1.8 versicolor 6.1 2.8 4.0 1.3 versicolor 6.3 2.5 4.9 1.5 versicolor 6.1 2.8 4.7 1.2 versicolor 6.4 2.9 4.3 1.3 versicolor 6.6 3.0 4.4 1.4 versicolor 6.8 2.8 4.8 1.4 versicolor 6.7 3.0 5.0 1.7 versicolor 6.0 2.9 4.5 1.5 versicolor 5.7 2.6 3.5 1.0 versicolor 5.5 2.4 3.8 1.1 versicolor 5.5 2.4 3.7 1.0 versicolor 5.8 2.7 3.9 1.2 versicolor 6.0 2.7 5.1 1.6 versicolor 5.4 3.0 4.5 1.5 versicolor 6.0 3.4 4.5 1.6 versicolor 6.7 3.1 4.7 1.5 versicolor 6.3 2.3 4.4 1.3 versicolor 5.6 3.0 4.1 1.3 versicolor 5.5 2.5 4.0 1.3 versicolor 5.5 2.6 4.4 1.2 versicolor 6.1 3.0 4.6 1.4 versicolor 5.8 2.6 4.0 1.2 versicolor 5.0 2.3 3.3 1.0 versicolor 5.6 2.7 4.2 1.3 versicolor 5.7 3.0 4.2 1.2 versicolor 5.7 2.9 4.2 1.3 versicolor 6.2 2.9 4.3 1.3 versicolor 5.1 2.5 3.0 1.1 versicolor 5.7 2.8 4.1 1.3 versicolor 6.3 3.3 6.0 2.5 virginica 5.8 2.7 5.1 1.9 virginica 7.1 3.0 5.9 2.1 virginica 6.3 2.9 5.6 1.8 virginica 6.5 3.0 5.8 2.2 virginica 7.6 3.0 6.6 2.1 virginica 4.9 2.5 4.5 1.7 virginica 7.3 2.9 6.3 1.8 virginica 6.7 2.5 5.8 1.8 virginica 7.2 3.6 6.1 2.5 virginica 6.5 3.2 5.1 2.0 virginica 6.4 2.7 5.3 1.9 virginica 6.8 3.0 5.5 2.1 virginica 5.7 2.5 5.0 2.0 virginica 5.8 2.8 5.1 2.4 virginica 6.4 3.2 5.3 2.3 virginica 6.5 3.0 5.5 1.8 virginica 7.7 3.8 6.7 2.2 virginica 7.7 2.6 6.9 2.3 virginica 6.0 2.2 5.0 1.5 virginica 6.9 3.2 5.7 2.3 virginica 5.6 2.8 4.9 2.0 virginica 7.7 2.8 6.7 2.0 virginica 6.3 2.7 4.9 1.8 virginica 6.7 3.3 5.7 2.1 virginica 7.2 3.2 6.0 1.8 virginica 6.2 2.8 4.8 1.8 virginica 6.1 3.0 4.9 1.8 virginica 6.4 2.8 5.6 2.1 virginica 7.2 3.0 5.8 1.6 virginica 7.4 2.8 6.1 1.9 virginica 7.9 3.8 6.4 2.0 virginica 6.4 2.8 5.6 2.2 virginica 6.3 2.8 5.1 1.5 virginica 6.1 2.6 5.6 1.4 virginica 7.7 3.0 6.1 2.3 virginica 6.3 3.4 5.6 2.4 virginica 6.4 3.1 5.5 1.8 virginica 6.0 3.0 4.8 1.8 virginica 6.9 3.1 5.4 2.1 virginica 6.7 3.1 5.6 2.4 virginica 6.9 3.1 5.1 2.3 virginica 5.8 2.7 5.1 1.9 virginica 6.8 3.2 5.9 2.3 virginica 6.7 3.3 5.7 2.5 virginica 6.7 3.0 5.2 2.3 virginica 6.3 2.5 5.0 1.9 virginica 6.5 3.0 5.2 2.0 virginica 6.2 3.4 5.4 2.3 virginica 5.9 3.0 5.1 1.8 virginica ml[[4]][,1] #a primeira coluna deste data.frame ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 ml[[4]]$Sepal.Length #mesma coisa ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 #uma lista pode conter listas mll = list(list(v1,v2),mm,dd) #o primeiro elemento virou uma lista com dois vetores class(mll[[1]]) #é uma lista agora ## [1] &quot;list&quot; mll[[1]][[1]] #a sublista 1 do elemento 1 da lista ## [1] 1 2 3 4 5 6 7 8 9 10 mll[[1]][[2]] #a sublista 2 do elemento 1 da lista ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; #criamos uma lista com nomes ml = list(VETOR1=v1,MATRIZ=mm,TABELA=dd) class(ml) ## [1] &quot;list&quot; str(ml) ## List of 3 ## $ VETOR1: int [1:10] 1 2 3 4 5 6 7 8 9 10 ## $ MATRIZ: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9 ## $ TABELA:&#39;data.frame&#39;: 150 obs. of 5 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..$ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... names(ml) #nome dos elementos ## [1] &quot;VETOR1&quot; &quot;MATRIZ&quot; &quot;TABELA&quot; ml[[&quot;VETOR1&quot;]] ## [1] 1 2 3 4 5 6 7 8 9 10 ml$VETOR1 #ou assim, da mesma forma que uma coluna de um data.frame ## [1] 1 2 3 4 5 6 7 8 9 10 ml[[&#39;TABELA&#39;]][,&quot;Sepal.Length&quot;] #coluna do data.frame em TABELA ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 ml[[&#39;TABELA&#39;]]$Sepal.Length #idem ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 ml$TABELA$Sepal.Length #idem também ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 6.2 Objetos complexos Em alguns casos como, por exemplo, em arquivos de dados espaciais (shapefiles), que apresentam estruturas complexas que incluem as especificações dos polígonos, pontos ou linhas, a projeção espacial e os dados associados, exige-se um objeto que possua uma estrutura de complexidade similar. Nestes casos, é importante que você conheça o operador @, que permite extrair elementos desses objetos. Em alguns casos você terá que usá-lo para entender o objeto ou para pegar elementos dos mesmos objetos. A função slotNames() permite ver os elementos que podem ser extraídos com o operador @. Abaixo mostramos um exemplo através de um mapa dos municípios brasileiros. Para isso, vamos precisar baixar um arquivo (http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=bot89:precurso:2lists:municipiosshape.zip). Baixe este arquivo comprimido que contem os arquivos de um único shapefile. Descomprima-o na sua pasta de trabalho e você perceberá que haverá vários arquivos associados: #vamos precisar de dois pacotes para dados espaciais #se não tiver instalado, instale com as dependencias # install.packages(c(&quot;maps&quot;, &quot;rgdal&quot;), dependencies = TRUE) library(maps) library(rgdal) # agora mudem o diretorio para pasta que contem os arquivos shape # lembre que voces podem tanto utilizar a funcao `setwd()` quanto clicar em Ferramentas/Tools na barra de opcoes do RStudio para mudar o diretorio de trabalho dir(pattern=&quot;shp&quot;) #lista arquivos shape na pasta #veja o help da função para ler shapefiles ?readOGR #le o shape file com objeto espacial no R mp = readOGR(dsn=&quot;MUNICIPIOS.shp&quot;,layer = &quot;MUNICIPIOS&quot;,encoding=&quot;UTF-8&quot;) plot(mp) #veja o mapa class(mp) #é um objeto de classe SpatialPolygonsDataFrame str(mp) #a estrutura é complexa #tem elementos definidos por $, que interpretado diretamente, é corresponde a um data.frame que é o dado associado à cada polígono no arquivo (attribute table do shapefile). names(mp) mp$NOME_MUNI dim(mp) #tem elementos definidos por @ #ver o help da função #?slot #slotNames(mp) #lista quais são esses elementos mp@data #é o mesmo data.frame que é automaticamente reconhecido na expressão acima dim(mp)==dim(mp@data) names(mp)==names(mp@data) #area do mapa dos municipios (os limites em latitude e longitude da área) mp@bbox plot(mp@bbox) #adicionamos o mapa mundi sobre isso map(add=T) #mp@polygons define cada poligono individualmente numa lista class(mp@polygons) mp@polygons[[1]] #um elemento qualquer class(mp@polygons[[1]]) str(mp@polygons[[1]]) #veja que este objeto tem vários elementos definidos por @ #slotNames(mp@polygons[[1]]) #slots desse objeto mp@polygons[[1]]@labpt #o centroid do polígono 1 que é o municipio de: mp@data$NOME_MUNI[1] #Chuí #qual elemento é manaus? gp = grep(&quot;Manaus&quot;,mp@data$NOME_MUNI) #pega o polígono de manaus manaus= mp@polygons[[gp]] class(manaus) str(manaus) #plota manaus #dev.off() #fecha dispositivos gráficos podes precisar disso map(xlim=mp@bbox[&quot;x&quot;,],ylim=mp@bbox[&quot;y&quot;,]) polygon(manaus@Polygons[[1]]@coords,col=&#39;red&#39;) #centroides do poligono de manaus ctro = manaus@Polygons[[1]]@labpt ctro[2] = ctro[2]+1.5 #adiciona 1.5 graus na latitude para não plotar sobre o poligono do municipio #plota no nome text(x=ctro[1],y=ctro[2],labels=&#39;Manaus&#39;,cex=0.8) "],["funções-gráficas.html", "7 Funções gráficas 7.1 Dispositivos Gráficos 7.2 Parâmetros gráficos dos dispositivos 7.3 Parâmetros gráficos parte II - Símbolos e cores 7.4 Funções gráficas de alto nível 7.5 Funções gráficas de baixo nível 7.6 Funções gráficas interativas", " 7 Funções gráficas 7.1 Dispositivos Gráficos Existem dois principais tipos de dispositivos (Devices) gráficos no R que basicamente significam onde você imprimirá um gráfico ou figura. Isso pode ocorrer: Na tela do computador (monitor), ou seja, em janelas do R ou do RStudio onde você visualiza gráficos; Em um arquivo em formato pdf, jpeg, tiff, png, eps etc. 7.1.1 Função plot() A função plot() (ou plot.default()) é a principal função genérica para gerar gráficos no R. Veremos isso com mais detalhes na seção Funções gráficas de alto nível. Aqui demonstraremos o uso da função simplificadamente para facilitar as demais explicações. Entenda que geramos gráficos com essa função. Vamos a um exemplo muito simples: #o objeto R do iris como exemplo str(iris) #plotando comprimento de sépala vs. comprimento de pétalas e colorindo os pontos de acordo com as espécies vcl = c(&quot;yellow&quot;,&#39;green&#39;,&#39;blue&#39;)[as.numeric(iris$Species)] #cria um vetor de cores para cada linha em Iris segundo especie #plota a figura plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) Muitos argumentos da função plot() são parâmetros gráficos. 7.1.2 Dispositivos de Tela Quando você usa funções para gerar um gráfico, o R ou RStudio usa automaticamente um dispositivo de tela. No entanto, você pode abrir novas janelas com as seguintes funções: X11() ou x11() funcionam no Mac, Linux e Windows; quartz() funciona apenas no Mac; windows() funciona apenas no Windows. ?device #veja o help da função e as opções de devices X11() #irá abrir uma janela nova #vamos plotar o mesmo gráfico do exercício anterior vcl = c(&quot;yellow&quot;,&#39;green&#39;,&#39;blue&#39;)[as.numeric(iris$Species)] #cria um vetor de cores para cada linha em Iris segundo especie #plota a figura plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) #irá fechar essa nova janela dev.off() quartz() #num mac abre uma janela sem dar nenhum aviso (funciona melhor que X11() no Mac) vcl = c(&quot;yellow&quot;,&#39;green&#39;,&#39;blue&#39;)[as.numeric(iris$Species)] #cria um vetor de cores para cada linha em Iris segundo especie #plota a figura plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) dev.off() #fecha 7.1.3 Listar e controlar dispositivos Existem funções que permitem trabalhar com vários dispositivos ao mesmo tempo, controlando o uso dos dispositivos abertos. Pode haver, por exemplo, várias janelas diferentes mostrando gráficos diferentes durante um trabalho. As principais funções para trabalhar com dispositivos são: A função dev.list()lista todos os dispositivos abertos no momento (geralmente o dispositivo padrão, que é sempre o número 1, é ignorado na lista), retornando o número (ordem de abertura) e o nome de cada um; dev.cur() mostra qual o dispositivo que está ativo (em inglês, current). Se há vários abertos, haverá sempre um que estará ativo naquele momento e se você enviar uma figura, ela sairá neste dispositivo; dev.set() torna ativo um determinado dispositivo; dev.off() fecha o dispositivo atual ou vários. Esta é a função dessa lista que é a mais usada na prática. #vamos primeiro fechar todos os dispositivos dev.off(which=dev.list()) dev.list() #vai retornar NULL por não há dispositivos abertos #vamos abrir vários dispositivos X11() #primeira janela extra X11() #segunda janela e mesma figura com cores diferentes X11() #terceira janela e mesma figura com cores diferentes #coloque e redimensione as janelas para ter as tres visiveis na tua tela e volte aqui. #veja os dispositivos abertos dev.list() #qual o atual dev.cur() #o ultimo que abrimos, né dev.set(2) #vamos mudar para o segundo e plotar algo plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,cex=0.8) #vamos mudar para o terceiro e plotar outra coisa dev.set(3) dev.cur() #deve responder 3 vcl = c(&quot;yellow&quot;,&#39;green&#39;,&#39;blue&#39;)[as.numeric(iris$Species)] plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) #vamos mudar para o quarto e plotar a mesma coisa com outras cores dev.set(4) dev.cur() #deve responder 4 vcl = c(&quot;red&quot;,&#39;blue&#39;,&#39;white&#39;)[as.numeric(iris$Species)] plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) #vamos fechar o dispositivo atual dev.cur() dev.off() dev.cur() #mudou automaticamente porque voce fechou o 4 dev.off() #mesma coisa fechou o ativo dev.cur() #sobrou o 3 #fechar este também dev.off() dev.list() #nao tem mais nenhum aberto 7.1.4 Dispositivos de Arquivos Há vários dispositivos para gerar arquivos com imagens. As funções em geral têm o nome do tipo de arquivo gerado. Vamos ver dois exemplos apenas, mas a mesma lógica se aplica a qualquer um dos dispositivos listados no ? dos dispositivos (execute o comando help('device') e veja a explicação sobre os dispositivos (devices)). Essas funções são ótimas ferramentas para incluir nos seus scripts a produção de figuras para uma publicação, basta ver na revista as especificações e através dos parâmetros das funções que abrem os dispositivos e dos 7.2\">parâmetros gráficos, você pode gerar figuras na especificação exata da revista selecionada. 7.1.5 Figuras Vetoriais PDF ou POSTSCRIPT Em nossa opinião, as funções pdf() e postscript() são as mais importantes para a geração de figuras, porque elas geram arquivos de excelente qualidade por serem vetoriais. Não há a necessidade de se definir a resolução, porque nesse tipo de imagem isso não existe. #plotando a figura na tela é o que fazemos normalmente vcl = c(&quot;yellow&quot;,&#39;green&#39;,&#39;blue&#39;)[as.numeric(iris$Species)] plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) #salvando a figura num PDF ?pdf #veja o help dessa função e seus argumentos, especialmente width e height #abre o dispositivo para pdf pdf(file=&#39;meupdf.pdf&#39;,width=lcm(15),height=lcm(10)) #lcm() apenas pega valores em cm e converte em polegadas que é a especificação padrão da funcao pdf. Portanto largura e altura de cada página do PDF é definida por esses argumentos #plota a figura plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) dev.off() #fecha o pdf #só será possível ver o pdf se tiver fechado ele. getwd() #o pdf foi gerado nessa pasta #se voce incluir vários gráficos. O pdf irá gerar várias páginas ao mesmo tempo. #abre o dispositivo para pdf pdf(file=&#39;meupdf2.pdf&#39;,paper=&#39;a4&#39;) #tamanho papel A4 #plota a figura 10 vezes for(i in 1:10) { plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) } dev.off() #fecha o pdf #veja que o arquivo 2 tem várias páginas 7.1.6 Figuras raster As funções jpeg(), png() e tiff() geram imagens em pixels, cuja qualidade depende muito da definição da resolução. #formato jpeg sem controlar a resolucao (usando units=&#39;px&#39; ou pixel) #abre o dispositivo no formato desejado jpeg(filename=&quot;meujpeg.jpg&quot;,width=600,height=400,units=&#39;px&#39;) #plota alguma coisa vcl = c(&quot;yellow&quot;,&#39;green&#39;,&#39;blue&#39;)[as.numeric(iris$Species)] plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) #fecha o jpeg dev.off() #ABRA O ARQUIVO E FAÇA UM ZOOM GRANDE #note que os pixels são super visíveis #AGORA MELHORANDO A RESOLUCAO #formato jpeg com 300dpi #abre o dispositivo no formato desejado jpeg(filename=&quot;meujpeg2.jpg&quot;,width=15,height=10,units=&#39;cm&#39;,res=300) #plota alguma coisa vcl = c(&quot;yellow&quot;,&#39;green&#39;,&#39;blue&#39;)[as.numeric(iris$Species)] plot(iris$Sepal.Length,iris$Petal.Length,type=&#39;p&#39;,pch=21,bg=vcl,cex=0.8) #fecha o jpeg dev.off() DICA: Abra os três arquivos e compare a resolução deles, ampliando a imagem até visualizar o pixel. Note que em um pdf você nunca verá o pixel. Por isso, recomendamos que vocÊ trabalhe sempre com a função pdf(). 7.1.7 Para saber mais: Dispositivos gráficos - vídeoaula com o conteúdo desta seção. 7.2 Parâmetros gráficos dos dispositivos Para fazer boas figuras no R, você precisa muitas vezes controlar parâmetros gráficos dos dispositivos, como margem da figura, tamanho de fonte, tipo da fonte, distância das legendas dos eixos x e y, se essas legendas são horizontais ou verticais, o tipo símbolos dos pontos, as cores dos simbolos etc. Você pode definir esses parâmetros diretamente nas funções gráficas de alto-nível highlevel plot&gt; (..., &lt;tag&gt; = &lt;value&gt;), onde um valor (value) de um parâmetro (tag) pode ser adicionado diretamente como argumento de uma função de alto-nível. Alguns desses parâmetros, no entanto, só podem ser definidos através da função par(), que também define parâmetros gráficos globais, isto é, se você alterar os parâmetros através dessa função, isso será alterado para todos os gráficos que forem abertos posteriormente durante a mesma sessão do R. Esta mesma função também permite visualizar os parâmetros gráficos. 7.2.1 Conhecendo os parâmetros Leia atentamente o ? da função par(). Você pode salvar os parâmetros globais antes de alterá-los. ?par #veja o help dessa função #você pode ver os parâmetros padrão: par() #vejo todos os parâmetros op = par() #pego todos os parâmetros class(op) #isso é uma lista names(op) #esses são os nomes dos parâmetros #a função par permite ver os valores atualmente definidos par(&quot;family&quot;) #tipo de fonte nao tem par(&quot;mar&quot;) #margens da figura em número de linhas #a função para tem apenas 1 argumento além dos parâmetros gráficos op2 &lt;- par(no.readonly = TRUE) class(op2) #a diferença entre especificar no.readonly como verdadeiro (na primeria opção não especificada acima, o padrão é FALSE) #é que a lista gerada pode ser usada para refazer alterações, ou seja, para resgatar os parâmetros gráficos padrão. #ou seja, posso fazer: par(op2) #para resgatar valores originais #mas não posso fazer o mesmo com a primeira opção par(op) #porque op é uma lista diferente length(op)==length(op2) #tem comprimentos diferentes identical(op,op2) #nao são identicas 7.2.1.1 Exemplos I - Margem #Usando novamente o exemplo de iris Sepalas = iris$Sepal.Length Petalas = iris$Petal.Length #especies como números spp = as.numeric(as.factor(iris$Species)) #uma cor para cada espécie vcl = c(&quot;yellow&quot;, &#39;green&#39;, &#39;blue&#39;)[spp] #um simbolo para cada espécie sbs = c(21, 22, 23)[spp] #plota a figura no dispositivo padrão plot(Sepalas, Petalas, pch = sbs, bg = vcl, cex = 0.8) #ALTERANDO A MARGEM em NUMEROS DE LINHAS #salva o valor padrao para resgatar ao final op = par(no.readonly = TRUE) op$mar #esses são os valor atuais para Margem Inferior, Esquerda, Superior e Direita, respectivamente. #quando se referir a margem todos os parâmetros seguem a ordem ANTI-HORÁRIA iniciando na margem inferior #reduzindo as margem direita e superior em número de linhas par(mar = c(5, 4, 1, 0.5)) plot(Sepalas, Petalas, pch = sbs, bg = vcl, cex = 0.8) #voltando ao original par(mar = op$mar) 7.2.1.2 Exemplo II - Aspecto dos eixos op = par(no.readonly = TRUE) #POSICAO DAS LEGENDAS DOS EIXOS par(&quot;mgp&quot;) #três valores que correspondem ao número de linhas para: (1) Titulo dos Eixos; (2) valores dos eixos; (3) linha dos eixos #TAMANHO DE FONTE DOS EIXOS É RELATIVO AO VALOR DE FONTE PADRÃO par(&quot;cex&quot;) #tamanho padrão par(&quot;cex.lab&quot;) #número que multiplicado por op$cex indica o valor da fonte dos títulos dos eixos par(&quot;cex.axis&quot;) #dos valores #TAMANHO DAS BARRAS DE CADA VALOR par(&quot;tck&quot;) #geralmente não tem padrão definido pois é extraído de outros valores automaticamente, mas você pode controlar isso #DIMINUINDO A FONTE DISSO par(cex.lab=0.8,cex.axis=0.7) plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #note que isso muda se eu alterar o tamanho de fonte padrão par(cex) par(cex=2, cex.lab=0.8,cex.axis=0.7) plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #APROXIMANDO par(mgp=c(1.5,0.5,0)) plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #e agora par(tck=-0.01) #note o valor negativo plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) par(tck=0.01) #se colocar positivo plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) par(op) #restaurando valores originais plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) 7.2.1.3 Exemplo III - Proporção dos eixos op = par(no.readonly = TRUE) par(&quot;pty&quot;) #valor &quot;m&quot; maximiza a area disponível plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #agora mantendo a proporção dos eixos (sem esticar nenhum dos dois) par(pty=&#39;s&#39;) plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #se não notou diferença, expandir o dispositivo onde está desenhando a figura 7.2.1.4 Exemplo IV - Múltiplas figuras na mesma tela ou página Você pode colocar diferentes gráficos na mesma tela ou na mesma página de um pdf, por exemplo. Temos duas formas de fazer isso. Os parâmetros mfrow e mfcol dividem os dispositivo em células de tamanhos idênticos. Todas as figuras terão o mesmo tamanho. A diferença entre os dois parâmetros é que mfrow() preenche o espaço por linhas, enquanto mfcol() preenche o espaço pelas colunas. par(op) par(&quot;mfrow&quot;) #o dispositivo não está divido: tem 1 linha e 1 coluna plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #EXEMPLO 1 #duas figuras no mesmo dispositivo par(mfrow=c(1,2)) #dividir o dispositivo em 1 linha e duas colunas #plota a primeira figura plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #plota a segunda sem cores plot(Sepalas,Petalas,pch=sbs,bg=NULL,cex=0.8) #EXEMPLO 2 par(mar=c(5.1,4.1,2.1,2.1)) par(mfrow=c(2,2)) #dividir o dispositivo em 2 linha e duas colunas #plota quatro figuras identificas for(f in 1:4) { plot(Sepalas,Petalas,pch=sbs,bg=NULL,cex=0.8) #adiciona uma letra para você ver a ordem e comparar com o exemplo 3 mtext(LETTERS[f],side=3,line=0,adj=0, font=2,col=&#39;red&#39;) #esta é uma função de baixo nível que falaremos depois } #EXEMPLO 3 par(mfcol=c(2,2)) #mesma coisa mas preenchendo por colunas (compare com a figura acima) for(f in 1:4) { plot(Sepalas,Petalas,pch=sbs,bg=NULL,cex=0.8) mtext(LETTERS[f],side=3,line=0,adj=0, font=2,col=&#39;red&#39;) } #colocando exemplo 2 e 3 num pdf pdf(file=&#39;meuPDFmfrow.pdf&#39;,paper=&quot;a4&quot;) #EXEMPLO 2 expandido par(mfrow=c(3,2)) #tres linhas e duas colunas for(f in 1:6) { plot(Sepalas,Petalas,pch=sbs,bg=NULL,cex=0.8) mtext(LETTERS[f],side=3,line=0,adj=0, font=2,col=&#39;red&#39;) } #EXEMPLO 3 expandido par(mfcol=c(3,2)) for(f in 1:6) { plot(Sepalas,Petalas,pch=sbs,bg=NULL,cex=0.8) mtext(LETTERS[f],side=3,line=0,adj=0, font=2,col=&#39;red&#39;) } dev.off() 7.2.1.5 Exemplo V A função layout() também permite dividir um dispositivo para múltiplas figuras, mas de uma forma muito mais complexa. ?layout #veja o help dessa função #voce precisa definir uma matriz que indica: #1) o numero de figuras (valores da matriz) #2) a posição das figuras (numero de linhas e colunas) #por exemplo, suponha que queremos plotar 3 figuras: #1 preenchendo a largura da página e metade da altura #2 outras figuras preenchendo a outra metada da altura #neste caso a figura 1 ira ocupar dois espacos mm = matrix(c(1,1,2,3),nrow=2,ncol=2, byrow = T) mm #a figura 1 irá ocupar a posicao do numero 1 na matriz #a figura 2 irá ocupar a posicao do numero 2 nessa matriz #a figura 3 irá ocupar a posicao do numero 3 dessa matriz #a largura de cada coluna e linha é especificada pelos argumentos widths e heights e usaremos a função lcm() para especificar isso em centímetros #divide o dispositivo ml = layout(mm,widths=rep(lcm(5),ncol(mm)),heights=rep(lcm(5),nrow(mm))) #mostra a divisao feita layout.show(ml) #plota a primeira figura plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #a segunda plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #a terceira plot(Sepalas,Petalas,pch=sbs,bg=vcl,cex=0.8) #colocando isso num pdf pdf(file=&#39;meuPDFlayout.pdf&#39;,paper=&quot;letter&quot;) layout(mm,widths=rep(lcm(8),ncol(mm)),heights=rep(lcm(8),nrow(mm))) #plota as tres figuras fazendo uma iteracao for(f in 1:3) { plot(Sepalas,Petalas,pch=sbs,bg=NULL,cex=0.8) mtext(LETTERS[f],side=3,line=0,adj=0, font=2,col=&#39;red&#39;) } dev.off() #fecha o pdf 7.2.2 Para saber mais: Parâmetros gráficos - veja nossas vídeoaulas com o conteúdo desta seção: Parte I; Parte II 7.3 Parâmetros gráficos parte II - Símbolos e cores Você pode fazer o que quiser na produção de um gráfico no R. Isso requer conhecer bem os parâmetros gráficos que já apresentamos de forma geral anteriormente (ver seção @ref(#par-graficos)). Aqui apresentamos alguns parâmetros de uso comum pelas funções gráficas de alto (seção @ref(#graf-alto-nivel)) e baixo nível (seção @ref(#graf-baixo-nivel)), que definem símbolos e cores. Você viu isso se leu o ? e entendeu o que a função par() faz. Em gráficos de dispersão e/ou na necessidade de colocar qualquer símbolo em um gráfico qualquer, precisamos saber como definir símbolos, suas cores e seus tamanhos. Os parâmetros gráficos que fazem isso são principalmente os seguintes: pch - define o tipo de símbolo para pontos; lty - define o tipo de símbolo para linhas; col e bg - respectivamente definem a cor de linhas e o “recheio” do ponto de símbolos, gráficos, polígonos etc; cex - define o tamanho de símbolos e texto; lwd - espessura das linhas. 7.3.1 Tipo de símbolo - pch Nós queremos símbolos, em geral, para adicionar em um gráfico os pontos referentes às nossas unidades amostrais. Portanto, esse tipo de símbolo no R é chamado de points, e já vimos a função de baixo-nível points(), que depende desse argumento ou parâmetro. O argumento pch pode ser um número2, que especifica um símbolo, ou símbolos de um único caractere [e.g. c(\"A\", \"*\",\"&amp;\", \"?\")]. #veja o definido como parâmetro global par(&quot;pch&quot;) #o que isso quer dizer? #vamos usar a função example() ?example #se quiser saber o que isso faz #quando digitar o comando abaixo, #vai precisar RESPONDER NO CONSOLE para prosseguir. example(&quot;points&quot;) #pare na terceira figura que esse exemplo gera. par(&quot;pch&quot;) #este valor corresponde ao símbolo nessa figura. #note que os símbolos de 21:25 permitem definir cor de linha e de recheiro, os demais apenas uma única cor #vamos gerar alguns exemplos com os dados de iris class(iris) dim(iris) colnames(iris) #com a definicao padrão de pch par(&quot;pch&quot;) Sepalas = iris$Sepal.Length Petalas = iris$Petal.Length plot(Sepalas, Petalas) #colocando todas com um único símbolo diferente plot(Sepalas, Petalas,pch=25) #colocando cada espécie com um único símbolo #neste caso o argumento pch deve ter um vetor do número de linhas em iris, se for menor, pela regra da reciclagem, ele irá repetir os símbolo sem estar relacionado à coluna Species, que define qual linha é de qual espécie. #então se eu definir apenas três simbolos, um para cada espécie: plot(Sepalas, Petalas,pch=c(&quot;A&quot;,&quot;&amp;&quot;,&quot;+&quot;)) #eles vao aparecer misturados, isso não está de acordo com as espécies #uma forma rápida de fazer isso, tendo em vista que o pch pode ser um valor numérico, #é transformar o nome das minhas especies em números. #Eu posso fazer isso se convertendo um fator para número, pois nele as categorias estão explicitamente definidas spp = iris$Species class(spp) #já é um fator #note que isso gera muitos NAs, já vimos isso antes as.numeric(as.vector(spp)) #mas isso gera números por spp é um fator as.numeric(spp) #então se eu quero os símbolos 22,23,25 para representar minhas espécies, eu uso esses números para pegar esses valores pelos índices de um vetor: pch.das.spp = c(21,23,25)[as.numeric(spp)] pch.das.spp #posso usar isso como argumento em plot: plot(Sepalas, Petalas,pch=pch.das.spp) #pronto cada espécie é um símbolo diferente 7.3.2 Tamanho dos pontos - cex O argumento genérico cex especifica o tamanho dos pontos relativo ao padrão do dispositivo. Aceita um valor numérico que é multiplicado pelo valor do seu dispositivo. O padrão geral é 1, isto é, 100% do tamanho. Se colocar 0.5 teremos 50%; se 1.5, teremos 150% do tamanho padrão. #da etapa anterior pch.das.spp = c(21,23,25)[as.numeric(spp)] #temos nosso gráfico com símbolos plot(Sepalas, Petalas,pch=pch.das.spp) #mudando o tamanho de todos os simbolos plot(Sepalas, Petalas,pch=pch.das.spp,cex=0.5) #para maior plot(Sepalas, Petalas,pch=pch.das.spp,cex=1.5) #um tamanho diferente por ponto (especie) tm = c(0.5,1,1.5)[as.numeric(spp)] tm plot(Sepalas, Petalas,pch=pch.das.spp,cex=tm) 7.3.3 Linhas Os argumentos lwd e lty controlam a espessura e o tipo das linhas, respectivamente. data(&quot;AirPassengers&quot;) #veja esse conjunto de dados com ?datasets class(AirPassengers) plot(AirPassengers,ylab=&quot;Número de Passageiros&quot;) #mudando o tipo de linha plot(AirPassengers,ylab=&quot;Número de Passageiros&quot;,lty=&#39;dotted&#39;) #outro tipo plot(AirPassengers,ylab=&quot;Número de Passageiros&quot;,lty=&#39;dotdash&#39;) #mudando a cor e espessura plot(AirPassengers,ylab=&quot;Número de Passageiros&quot;,lty=&#39;dashed&#39;,col=&#39;red&#39;,lwd=2) 7.3.4 Cores de símbolos - col e bg O argumento col define cores para os símbolos. No caso de símbolos de uma única cor, utilizamos apenas este argumento. Já o argumento bg define as cores do preenchimento dos símbolos. #o que definimos antes são símbolos que permitem definir cores para preenchimento e linha: pch.das.spp = c(21,23,25)[as.numeric(spp)] #temos nosso gráfico com símbolos plot(Sepalas, Petalas,pch=pch.das.spp) #vamos adicionar as cores seguindo o mesmo raciocínio cores.spp = c(&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;)[as.numeric(spp)] cores.spp plot(Sepalas, Petalas,pch=pch.das.spp,bg=cores.spp) #podemos mudar a cor da linha desses simbolos (todos para verde pela regra da reciclagem especifico uma única vez) plot(Sepalas, Petalas,pch=pch.das.spp,bg=cores.spp, col=&quot;green&quot;) #mudando simbolos nsb = c(&quot;*&quot;,&quot;#&quot;,&quot;+&quot;)[as.numeric(spp)] plot(Sepalas, Petalas,pch=nsb,bg=cores.spp) #note que apesar de bg estar especificando cores as cores nao foram adicionadas, porque colocamos no argumento de preenchimento. #Mudando: plot(Sepalas, Petalas,pch=nsb,col=cores.spp) 7.3.5 Funções que definem cores Cores podem ser definidas por palavras ou por códigos. As funções colors() ou colours() listam cores pelo nome. #lista todas as cores disponíveis pelo nome colors() #nossa tem 657 cores. Difícil, né? #reduz para as mais distintas colors(distinct = TRUE) #ainda 502 #eu posso pegar ou buscar por cores ascores = colors(distinct = TRUE) vl = grep(&quot;blue&quot;,ascores) ascores[vl] #60 nomes que contém a palavra azul #vamos ver todas as coresem umpdf longo #vamos plotar pizzas coloridas com 10 cores cada #4 pizzas por página ?pie #veja o help dessa função #abre um PDF pdf(&quot;cores.pdf&quot;,width=lcm(29),height = lcm(21)) #vamos dividir o dispositivo em 2 colunas e 3 linhas (e diminuir a margem) par(mfrow=c(2,2), mar=c(3,3,3,3),cex=0.7) ln = length(ascores) ln #sao 502 cores ceiling(ln/10) #, entao serao 51 pizzas #plota cada pizza fazendo uma iteração: idx = 0 #o objeto nullo para usar de indice na iteracao para fazer de 10 em 10 for(p in 1:ceiling(ln/10)) { de = idx+1 #cor do indice idx ate = idx+10 #ate cor do indice idx+10 cls = ascores[de:ate] #cores da pizza da iteracao p pie(rep(1,10),col=cls, labels= cls) idx = ate } dev.off() #fecha o pdf As funções rainbow() ou terrain.colors() geram gradientes de cores em um padrão definido. #10 cores do arco-iris cls = rainbow(n=10) pie(rep(1,10),col=cls, labels= cls) #12 cores do arco-iris com 50% de transparencia cls = rainbow(n=12,alpha=0.5) pie(rep(1,12),col=cls, labels= cls) #12 cores do arco-iris, limitando o espectro cls = rainbow(n=12,start=0.1,end=0.9) pie(rep(1,12),col=cls, labels= cls) #10 cores quentes cls = heat.colors(n=10, alpha = 1) pie(rep(1,10),col=cls, labels= cls) #20 cores topográficas cls = topo.colors(n=20, alpha = 1) pie(rep(1,20),col=cls, labels= cls) #ou melhor cls = terrain.colors(n=20, alpha = 1) pie(rep(1,20),col=cls, labels= cls) As funções rgb() ou hsv() geram qualquer tipo de cor para ser utilizados nos gráficos. ?rgb #veja o help dessa funcao e veja as funcoes sob See Also #podemos entender melhor fazendo o caminho inverso defs = col2rgb(&quot;yellow&quot;) #extraimos as especificacoes de amarelo (cores primárias ) pela palavra defs #sem cor temos preto cls = rgb(red=0, green=0, blue=0) #fazemos amarelo pie(1,col=cls,labels=cls) #fazemos amarelo cls = rgb(red=255, green=255, blue=0,maxColorValue=255) pie(1,col=cls,labels = cls) #tiramos verde cls = rgb(red=255, green=160, blue=0,maxColorValue=255) pie(1,col=cls,labels = cls) #tiramos verde e adicionamos azul cls = rgb(red=255, green=160, blue=255,maxColorValue=255) pie(1,col=cls,labels = cls) #tiramos azul-escuro (mais perto de 0) cls = rgb(red=0, green=0, blue=150,maxColorValue=255) pie(1,col=cls,labels = cls) #tiramos azul cls = rgb(red=0, green=0, blue=255,maxColorValue=255) pie(1,col=cls,labels = cls) 7.3.6 Para saber mais: Parâmetros gráficos parte II - vídeoaula com o conteúdo desta seção. 7.4 Funções gráficas de alto nível Funções gráficas de alto-nível (highlevel plots) são as funções que usamos para gerar os gráficos. Além da função genérica plot(), veremos apenas alguns poucos exemplos, mas existem diversas funções gráficas de alto nível, muitas das quais dependem de pacotes específicos. Existem inúmeras outras funções de alto-nível, algumas do R-base, outras geradas por colaboradores na forma de pacotes do R. A função plot() entende algumas dessas outras funções dos pacotes automaticamente, dependendo da classe do objeto, e você sequer precisa usar o nome específico (veja o exemplo em plot.phylo(), abaixo). No ? do pacote graphics, você encontra ajuda para funções gráficas em geral: demo(&quot;graphics&quot;) #execute este demostrativo - lembre-se de interagir no console do R para as figuras ?graphics #veja o help dessa função para alguns gráficos 7.4.1 plot() - uma função genérica A função plot() é a principal para produção de gráficos porque é uma função genérica que irá gerar um gráfico dependendo da classe do objeto. Em muitos casos, não precisamos usar outras funções, porque a depender da classe do objeto, esta função automaticamente entenderá o que você precisa. ?plot #veja o help dessa função #suponha um vetor simples e numérico vv = 1:10 class(vv) #plotamos ele plot(vv) #mudamos alguns argumentos plot(vv,pch=21,bg=&#39;red&#39;,xlab=&#39;índice do vetor&#39;,ylab=&#39;valor do vetor&#39;,main=&#39;Plotando um vetor&#39;) #agora suponha uma matriz com duas colunas xx = 1:10 #um vetor yy = 10:1 #o mesmo vetor invertido mm = cbind(xx,yy) #junta em uma matrix class(mm) plot(mm,xlab=&#39;Eixo X&#39;,ylab=&#39;Eixo Y&#39;,main=&#39;Plotando uma matriz de 2 colunas&#39;) #ou poderia especificar diretamente os eixos xx e yy sem usar a matriz plot(xx,yy,xlab=&#39;Eixo X&#39;,ylab=&#39;Eixo Y&#39;,main=&#39;Plotando uma matriz de 2 colunas&#39;,pch=21,bg=&#39;purple&#39;) #se temos um conjunto de dados e queremos ver a relação de todos as colunas, podemos simplesmente usar: class(iris) #um conjunto de dados no formato data.frame plot(iris) #o nome dos eixos está na diagonal dessa figura 7.4.2 hist() Esta importante função serve para visualizar a variação de uma variável apenas. ?hist #veja o help #vamos usar o objeto iris class(iris$Sepal.Length) #é um vetor hist(iris$Sepal.Length, xlab=&quot;Comprimento de sépala (cm)&quot;,main=&quot;Variação em Iris&quot;) #diminuindo os espaçamentos entre as barras e colorindo hist(iris$Sepal.Length, xlab=&quot;Comprimento de sépala (cm)&quot;,main=&quot;Variação em Iris&quot;,breaks=20,col=&#39;red&#39;) #note que o eixo y é a frequencia que o valor ocorre, ou seja, corresponde ao número de linhas em iris que tem valor 7.4.3 boxplot() Esta função é importante por mostrar a variação em uma variável qualquer em relação às categorias de um fator. É uma das melhores formas gráficas para mostrar a distribuição de valores de uma variável em relação às categorias. ?boxplot #vamos usar o objeto iris class(iris$Sepal.Length) #é um vetor class(iris$Species) #é um fator boxplot(iris$Sepal.Length~iris$Species, ylab=&quot;Comprimento da sépala&quot;) #você pode fazer a mesma coisa com a função plot() porque ela é genérica que irá reconhecer que sua fórmula &#39;valores~fator&#39; pede por um boxplot plot(iris$Sepal.Length~iris$Species, ylab=&quot;Comprimento da sépala&quot;,xlab=&#39;&#39;) #note que especificamos aqui que o eixo x não tem título (lab) 7.4.4 barplot() Esta função gera um gráfico de barras simples. ?barplot #veja o help dessa função ?VADeaths #veja o help desse conjunto de dados class(VADeaths) VADeaths #taxas de mortalidade/1000 habitantes no estado da Virgínia em 1940 rownames(VADeaths) #cada linha é uma classe de idade colnames(VADeaths) #cada coluna é sexo e cidade ou rural #com as informações padrão barplot(VADeaths) #cada cor é uma linha barplot(VADeaths, beside = TRUE) #lado a lado (cada barra é uma linha) #vamos colorir diferente, uma para cada linha rownames(VADeaths) cores = rainbow(n= nrow(VADeaths)) cores #uma cor por linha #essa é a correspondencia: cbind(rownames(VADeaths),cores) #plota com essas cores barplot(VADeaths, beside = TRUE, col= cores) 7.4.5 plot.phylo() O pacote Ape (Analyses of Phylogenetics and Evolution) possui uma função para desenhar uma filogenia. Caso você não tenha instalado o pacote ape ainda, faça-o assim: install.packages(&quot;ape&quot;) Depois, siga o exemplo abaixo: library(ape) #chama o pacote #uma filogenia hipotética para exemplo arv = &quot;(((A:1,B:1):2,C:3):0.5,((D:0.5,E:0.5):1,F:1.5):2);&quot; #lê essa filogenia para um objeto de classe phylo, que é uma classe para dendrogramas. phy = read.tree(text=arv) class(phy) #podemos plotar essa filogenia com plot(phy) #porque a função plot reconhece #que objetos de classe &quot;phylo&quot; são árvores #de fato ela usa a função plot.phylo() para gerar essa figura, que contém argumentos específicos para objetos dessa classe ?plot.phylo #veja o help e os argumentos #portanto posso incluir argumentos de plot.phylo() quando uso a função plot() para plotar um objeto de classe phylo plot(phy,no.margin = TRUE, tip.color = c(rep(&quot;red&quot;,3),rep(&quot;blue&quot;,3))) #seria o mesmo que dizer plot.phylo(phy,no.margin = TRUE, tip.color = c(rep(&quot;red&quot;,3),rep(&quot;blue&quot;,3))) 7.4.6 image() e countour() #existe um conjunto de dados topográficos na base do R que vamos usar como exemplo class(volcano) #é uma matriz dim(volcano) #com 87 linhas e 61 uma colnas volcano[1:5,1:5] #os valores são altitude hist(volcano,breaks=20) #essa é a distribuição de valores de elevacao range(volcano) #amplitude de variação #podemos usar algumas funções para visualizar um conjunto de dados que tem essa estrutura (matrix) ?image #veja o help image(volcano,col = heat.colors(12)) ?heat.colors #veja opções de gradientes continuos de cores #vamos mudar isso, cores = terrain.colors(12) #12 categorias de cores cores #o código é uma cor em HTML image(volcano,col=cores) #notem a cratera #outra opção é fazermos os contornos (ou curvas de nível neste caso do vulcão) contour(volcano) ?contour #veja o help #vamos mudar o número de níveis para o mesmo usado para as cores contour(volcano, nlevels=12) #vamos juntar essas figuras em uma só image(volcano, col=cores) contour(volcano, nlevels=12,add=TRUE) #note o argumento add=TRUE que indica para a função de alto-nível #que ela não deve começar uma nova figura, #apenas adiciona à uma já criada por outra função de alto-nível #muitas funções de alto-nível tem esse argumento add, que, portanto, mimetiza o que função gráfica de baixo-nível faz 7.4.7 map() O pacote maps fornece funções para desenhar mapas com divisões administrativas. A função map() é uma de alto-nível. Veremos depois como adicionar sobre esses mapas informação através de funções de baixo-nível. Caso você não tenha instalado o pacote maps ainda, faça-o assim: install.packages(&quot;maps&quot;) Agora, siga o exemplo abaixo: library(maps) #instalar se não tiver instalado ?map #veja o help map() #mapa do mundo map(region=&#39;Brazil&#39;) #Brazil #dev.off() #pode precisar fechar o dispositivo se estiver avisar que a figura é muito grande dev.off() sa = c(&quot;Brazil&quot;,&quot;Guyana&quot;,&quot;French Guiana&quot;,&quot;Suriname&quot;,&quot;Venezuela&quot;,&quot;Colombia&quot;,&quot;Ecuador&quot;,&quot;Trinidad-Tobago&quot;,&quot;Peru&quot;,&quot;Bolivia&quot;,&quot;Paraguay&quot;,&quot;Chile&quot;,&quot;Argentina&quot;,&quot;Uruguay&quot;,&quot;Panama&quot;) map(region=sa, col=&#39;red&#39;,lty=&#39;dashed&#39;) 7.4.8 xlim e ylim Esses dois parâmetros gráficos permitem ajustar o tamanho dos eixos de um gráfico, impondo limites. #CONTROLANDO UM XLIM plot(iris$Sepal.Length,iris$Sepal.Width,pch=21,col=&#39;red&#39;) #vamos aumentar um pouco o eixo X rg = range(iris$Sepal.Length) #variacao atual rg #aumentar rg2 = rg+c(-1,+1) #adicionamos 1 unidade de cada lado rg2 plot(iris$Sepal.Length,iris$Sepal.Width,pch=21,col=&#39;red&#39;,xlim=rg2) #LIMITANDO UM MAPA POR SUAS COORDENADAS dev.off() library(maps) #instalar se não tiver instalado map() #mapa do mundo #alguns limites em latitude e longitude lat0=-22 lat1=5 long0 = -80 long1=-30 dev.off() map(xlim=c(long0,long1),ylim=c(lat0,lat1)) 7.4.9 Para saber mais: Funções gráficas de alto nível - vídeoaula com o conteúdo desta seção; R Gallery - página que tem exemplos de gráficos do R e os códigos correspondentes. 7.5 Funções gráficas de baixo nível Funções de baixo nível são funções que permitem ADICIONAR elementos em um gráfico já aberto com as funções plot() ou plot.new(). Muitas vezes você pode usar uma função de alto nível para fazer a mesma coisa com o argumento add = TRUE. Vamos ver alguns exemplos mais comumente utilizados de funções de baixo-nível. 7.5.1 legend() A função legend() permite colocar uma legenda sobre um gráfico aberto por uma função de alto nível. ?legend #veja o help dessa funcao #vamos usar iris novamente Sepalas = iris$Sepal.Length Petalas = iris$Petal.Length nlevels(iris$Species) #contém três espécies levels(iris$Species) ascores = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)[as.numeric(iris$Species)] #plota a figura plot(Sepalas,Petalas,pch=21,bg=ascores,cex=0.8) #vamos colocar uma legenda no canto direito inferior #definimos o que vai na legenda cores = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;) texto = levels(iris$Species) legend(&quot;bottomright&quot;,legend=texto,pt.bg=cores,pch =21) #ficou apertado né... #aumentar o espacamento, colocar mais para dentro e tirar o box, diminuir o texto, aumentar o tamanho do ponto #plota a figura plot(Sepalas,Petalas,pch=21,bg=ascores,cex=0.8) legend(&quot;bottomright&quot;,legend=texto,pt.bg=cores,pch =21,y.intersp = 1.7,inset=0.1,box.lwd=0,cex=0.8,pt.cex=1.5) #podemos colocar legendas também pela coordenada plot(Sepalas,Petalas,pch=21,bg=ascores,cex=0.8) legend(x=7,y=3,legend=texto,pt.bg=cores,pch =21,y.intersp = 1.7,inset=0.1,box.lwd=0,cex=0.8,pt.cex=1.5) #ou colocar fora da figura #neste caso, primeiro dividimos o dispositivo em tres partes e plotamos a figura em 2 partes e a legenda em 1 parte layout(matrix(c(1,1,2),nrow=1,ncol=3)) plot(Sepalas,Petalas,pch=21,bg=ascores,cex=0.8) #usamos a função plot.new() para mudar de parte no dispositivo cirando um plot vazio plot.new() #nao vai ver nada acontecendo #agora plotamos a legenda nesse espaço legend(&quot;left&quot;,legend=texto,pt.bg=cores,pch =21,y.intersp = 1.7,inset=0.1,box.lwd=0,cex=0.8,pt.cex=1.5) 7.5.2 points() Esta função genérica serve para adicionar pontos, linhas, simbolos etc, segundo coordenadas x ou x+y em um gráfico aberto por uma função de alto nível. layout(1) #restaurando para 1 se fez o script acima #vamos usar um conjunto de dados de crescimento de laranja data(&quot;Orange&quot;) colnames(Orange) #número da árvore, idade, circunferencia nessa idade head(Orange) unique(Orange$Tree) #tem cinco árvores #vamos plotar idade por circunferencia #uma linha por árvore #cada linha de um tipo e cor diferente #definir tipos de linhas e cores ascores = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;purple&quot;) linhatipos = c(&quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;) #uma cor por árvore treeidx = as.numeric(Orange$Tree) cls = ascores[treeidx] cls #um tipo de linha por arvore tps = linhatipos[treeidx] tps #fazemos uma figura plot(Orange$age,Orange$circumference,lwd=1,type=&quot;b&quot;, col=cls,lty=tps) #note que todas as linhas sairam com primeira cor e com o primeiro tipo cls[1] tps[1] #nao dá para fazer assim, porque não especificamos como os pontos se ligam #podemos no entanto colocar linha por linha #desenhamos o gráfico com uma função de alto nível com os dados, mas vazia plot(Orange$age,Orange$circumference,type=&#39;n&#39;,xlab=&quot;Idade&quot;,ylab=&#39;Circunferência&#39;) #adicionamo para cada árvore os pontos e as linhas arvs = as.numeric(levels(Orange$Tree)) pts = arvs+20 #simbolos para pontos i=1 for(i in 1:length(arvs)) { #para cada arvore #filtra os dados dd = Orange[Orange$Tree==arvs[i],] #adiciona no gráfico aberto a linha e os pontos e uma vez (type=&#39;b&#39;, veja o argumento type) points(dd$age,dd$circumference,type=&#39;b&#39;,pch=pts[arvs[i]],lty=linhatipos[arvs[i]],lwd=1,col=ascores[arvs[i]],bg=ascores[arvs[i]]) } #vamos adicionar uma legenda txt = paste(&quot;tree&quot;,arvs) legend(&quot;bottomright&quot;,inset=0.1,box.lwd =0,legend=txt,pch=pts[arvs],pt.bg=ascores[arvs],lty=linhatipos[arvs],col=ascores[arvs], y.intersp = 1.5) 7.5.3 text() e mtext() text() e mtext()- funções para plotar textos (&gt;= 1 caracter de comprimento) sobre uma figura de alto nível. text() plota dentro da área da figura através de coordendas, mtext() plota fora da área da figura com indicação do lado (side) e da distância da linha dos eixos (line). ?text #veja o help dessa função #vamos usar iris novamente Sepalas = iris$Sepal.Length Petalas = iris$Petal.Length nlevels(iris$Species) #contém três espécies levels(iris$Species) ascores = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)[as.numeric(iris$Species)] #vamos dar um código de texto para cada especie (suas primeiras letras maiusculo) levels(iris$Species) spp = toupper(substr(iris$Species,1,2)) spp #plota a figura, mas ao inves de simbolos adicionamos text #poderiamos fazer isso se spp fosse apenas 1 caractere plot(Sepalas,Petalas,pch=spp,col=ascores,cex=0.8) legend(&quot;bottomright&quot;,legend=levels(iris$Species),text.col=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;),inset=0.1,box.lwd =0,y.intersp =1.5) #mas note que versicolor e virginica não se diferenciam, pois pch plota apenas 1 caractere quando o simbolo for texto #podemos, no entanto, usar a funcao text para isso plot(Sepalas,Petalas,type=&quot;n&quot;) text(Sepalas,Petalas,labels=spp,col=ascores,cex=0.8) txt = paste(&quot;Iris&quot;,levels(iris$Species)) legend(&quot;bottomright&quot;,legend=txt,text.col=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;),inset=0.1,box.lwd =0,y.intersp =1.5) #posso usar essa função para adicionar qualquer texto, em qualquer coordenada text(4.5,6,labels = &quot;Exemplo Iris&quot;,adj=0,col= &#39;yellow&#39;) #note o argumento adj que define o ajuste do texto em relacao à coordenada x y especificada (ajuste: 0 esquerda, 1 direita) #apenas o x text(x=4.5,y=6,labels = &quot;Exemplo Iris&quot;,adj=1, col= &#39;black&#39;) #o x e o y do ajuste (dois valores em adj) text(x=4.5,y=6,labels = &quot;Exemplo Iris&quot;,adj=c(0.3,1),col= &#39;purple&#39;) #a funcao mtext plot for da área das coordenas da figura #lado superior mtext(side=3,text = &quot;A.&quot;,line=1,col=&#39;red&#39;,font=2,cex=2) #lado superior esquerdo mtext(side=3,text = &quot;A.&quot;,line=1,col=&#39;red&#39;,font=2,cex=2,adj=0) #lado inferior direito mtext(side=1,text = &quot;B.&quot;,line=1,col=&#39;red&#39;,font=2,cex=2,adj=1) #mais para baixo mtext(side=1,text = &quot;B.&quot;,line=2.5,col=&#39;red&#39;,font=2,cex=2,adj=1) #lado direito superior mtext(side=4,text = &quot;C.&quot;,line=1,col=&#39;red&#39;,font=2,cex=2,adj=1) #lado direito no meio mtext(side=4,text = &quot;C.&quot;,line=1,col=&#39;red&#39;,font=2,cex=2,adj=0.5) 7.5.4 axis() A função axis() adiciona eixos individualmente. É importante quando desejamos combinar dois gráficos em um só. ?axis #algumas vezes queremos adicionar eixos, ou formatar o eixo de uma forma individualizada #por exemplo, na seguinte figura, queremos colocar o nome das especies no eixo y em posicao horizontal plot(iris$Sepal.Length~iris$Species, horizontal=TRUE) #o argumento para isso é par(las=2) #se mudar isso eu mudo para todos os eixos par(las=2) plot(iris$Sepal.Length~iris$Species, horizontal=TRUE) #mas eu quero apenas o eixo y par(las=1) #voltamos ao padrao 1 #plotamos a figura sem esse eixo plot(iris$Sepal.Length~iris$Species, horizontal=TRUE,yaxt=&#39;n&#39;) #adicionamos o eixo y na horizontal axis(side=2,las=2) #mas ele plotou números não é isso que eu quero plot(iris$Sepal.Length~iris$Species, horizontal=TRUE,yaxt=&#39;n&#39;) #entao dizemos onde e o que queremos desenhar axis(side=2,at=1:3,labels=levels(iris$Species)) #vamos mudar o titulo do eixo da variavel dependente (y) e apagar das especies plot(iris$Sepal.Length~iris$Species, horizontal=TRUE,yaxt=&#39;n&#39;,ylab=&#39;Comprimento Sépalas&#39;,xlab=&#39;&#39;) #entao dizemos onde e o que queremos desenhar axis(side=2,at=1:3,labels=levels(iris$Species)) #também posso adicionar eixos em outras posicoes axis(side=3) 7.5.5 abline() Esta função plota uma linha reta sobre um gráfico, ou uma linha de ajuste de uma correlação ou regressão. #linha sobre o eixo ?abline #permite colocar linha em regressoes ou linhas retas simples plot(iris$Sepal.Length,iris$Petal.Length) #um linha horizontal abline(h=4,col=&#39;red&#39;,lwd=2) #uma linha vertical abline(v=6.3,col=&#39;blue&#39;,lwd=2) #uma linha de uma regressao rg = lm(iris$Petal.Length~iris$Sepal.Length) #faço a regressao entre essas variaveis abline(coef(rg), col=&#39;darkgreen&#39;,lwd=3,lty=&#39;dotted&#39;) #plot pelos coeficientes 7.5.6 arrows(), rect(), polygon() e segments() Estas funções plotam flechas, retângulos, polígonos, ou segmentos de linhas sobre sobre gráficos, respectivamente. #FLECHAS ?arrows #veja o help #vamos criar um histograma hist(iris$Sepal.Width,breaks=20,col=&#39;red&#39;) #adicionar uma seta arrows(x0=3.6,y0=5,x1=3.6,y1=10,lty=&#39;solid&#39;,col=&#39;blue&#39;) #invertendo y0 e y1, diminuindo o tamanho da seta e colocando mais grosso hist(iris$Sepal.Width,breaks=20,col=&#39;red&#39;) arrows(x0=3.6,y0=10,x1=3.6,y1=5,lty=&#39;solid&#39;,lwd=3,col=&#39;blue&#39;,length=0.1) #RETANCULOS E POLIGONOS ?rect #veja o help plot(1:10,1:10,type=&#39;n&#39;) rect(xleft=2,ybottom=2,xright=3,ytop=4) #com preenchimento rect(xleft=4,ybottom=2,xright=6,ytop=4,density = 8, border=&quot;red&quot;,col=&#39;blue&#39;) #com preenchimento total (density tem valor negativo (um qualquer)) rect(xleft=7,ybottom=2,xright=8,ytop=4,density = -1, border=&quot;yellow&quot;,col=&#39;blue&#39;, lwd=5) #POLIGONO ?polygon #veja o help plot(1:10,1:10,type=&#39;n&#39;) polygon(x=c(4,7.5,8.2,6,4),y=c(2,2,5,8,2),lwd=2,col=&#39;red&#39;) plot(1:10,1:10,type=&#39;n&#39;) polygon(x=c(4,7.5,8.2,6,4),y=c(2,2,5,8,2),lwd=2,col=&#39;red&#39;,density=10) #segmentos de linhas ?segments plot(1:10,1:10,type=&#39;n&#39;) segments(x0=2,y0=2,x1=4.5,y1=6,lwd=2,col=&#39;red&#39;) segments(x0=2,y0=8,x1=7.5,y1=8,lwd=2,col=&#39;blue&#39;) 7.5.7 symbols() A função symbols() é uma de alto nível, mas com a adição do argumento add=TRUE, ela pode ser utilizada para adicionar sobre gráficos já plotados símbolos que expressam quantidades. ?symbols #ver o help plot(1:10,1:10,type=&#39;n&#39;) xx = c(3,5,7,9) yy = c(3,5,7,9) zz = c(0.1,0.3,0.4,1) #tamanho em unidade gráfica symbols(xx,yy,circles=zz,bg=&#39;red&#39;, add=T, inches=FALSE) plot(1:10,1:10,type=&#39;n&#39;) symbols(xx,yy,squares=zz,bg=&#39;blue&#39;, add=T, inches=FALSE) #agora mais complexo, expressando proporção plot(1:10,1:10,type=&#39;n&#39;) #uma matrix que com tres colunas: largura do simbolo, altura do simbolo e proporcao que simbolo deve estar preenchido v1 = matrix(c(1,1,0.2),nrow=1,ncol=3) #20% cheio #ll = rep(v1,length(xx)) symbols(xx[1],yy[1],thermometers=v1, add=T, inches=FALSE) v2 = matrix(c(1,1,0.8),nrow=1,ncol=3) #80% cheio #ll = rep(v1,length(xx)) symbols(xx[2],yy[2],thermometers=v2, add=T, inches=FALSE) 7.5.8 Para saber mais: Vídeoaulas com o conteúdo desta seção: Parte I; Parte II; 7.6 Funções gráficas interativas 7.6.1 locator() Esta função extrai coordenadas de um gráfico. ?locator #veja o help #fazemos um gráfico ?trees #se quiser entender esses dados data(&quot;trees&quot;) class(trees) colnames(trees) Circunferencia=trees$Girth Altura=trees$Height plot(Circunferencia,Altura,type=&#39;p&#39;,pch=21,bg=&#39;red&#39;) locator(n=1) #clique na figura dentro do gráfico #veja que no console há uma lista com os valores das coordenadas x e y #pode fazer a mesma coisa já salvando as coordendas num ojbeto. Colete 2 pontos agora, traçando uma linha entre eles cds = locator(n=2,type=&#39;l&#39;) cds #dois valores para cada coordenada #posso usar os valores obtidos, por exemplo para plotar uma flexa x0 = cds$x[1] x1 = cds$x[2] y0 = cds$y[1] y1 = cds$y[2] arrows(x0,y0,x1,y1,lwd=2,col=&quot;red&quot;) 7.6.2 identify() Esta função identifica os pontos de um gráfico. ?identify #veja o help #fazemos um gráfico data(&quot;trees&quot;) Circunferencia=trees$Girth Altura=trees$Height #plotamos vazio plot(Circunferencia,Altura,type=&#39;n&#39;) ss = sample(1:nrow(trees),1) #um valor de indice aleatorio #um ponto qualquer em vermelho points(Circunferencia[ss],Altura[ss],pch=21,cex=1.5,bg=&#39;red&#39;) #o resto dos pontos em branco points(Circunferencia[-ss],Altura[-ss],pch=21,cex=1.5,bg=&#39;white&#39;) #identificar pontos. Execute a funçào e selecione no ponto vermelho identify(Circunferencia,Altura,n=1,tolerance=1) #o numero que aparece no gráfico é o indice #portanto, deve ser igual ao valor de ss trees[ss,] de 0 a 25; veja o ? da função points(), ?points, para saber quais são esses símbolos↩︎ "],["iteração-e-controle-de-fluxo.html", "8 Iteração e controle de fluxo 8.1 Funções da família apply() 8.2 Condicionais 8.3 Iterações 8.4 Criando ou modificando funções", " 8 Iteração e controle de fluxo 8.1 Funções da família apply() Algumas funções da família apply() são muito úteis na manipulação de dados e descrição de dados. Essas funções são muito poderosas, porque permitem você fazer iterações de forma simples, ou seja, você pode aplicar uma função a vários objetos simultaneamente com funções dessa família. O que você faz com essas funções você também faz com as iterações que fazem uso da expressão for(){} (veja seção 8.3), mas essas funções simplificam e aceleram o processo. 8.1.1 Em uma matriz A função apply() poderia ser traduzida como: aplique uma função (FUN) a todas as linhas ou colunas (MARGIN) de uma matriz (X): ?apply #Veja o help #os argumentos dessa função são: #X = matrix #MAGRIN = 1 indica linha, 2 indica colunas #FUN = a função que você deseja aplicar #... ARGUMENTOS DESSA FUNCAO SE FOR O CASO #TOTAIS MARGINAIS #crie uma matriz X = matrix(1:36,nrow=4,ncol=9) colnames(X) = paste(&#39;col&#39;,1:ncol(X)) rownames(X) = paste(&#39;ln&#39;,1:nrow(X)) head(X) #cabeça da matriz criada #calcule para todas as linhas: #a soma dos valores apply(X,MARGIN=1,FUN=sum) #o valor máximo apply(X,MARGIN=1,FUN=max) #a média apply(X,MARGIN=1,FUN=mean) #o desvio padrão apply(X,MARGIN=1,FUN=sd) #para todas as colunas #a soma dos valores apply(X,MARGIN=2,FUN=sum) #o valor máximo apply(X,MARGIN=2,FUN=max) #a média apply(X,MARGIN=2,FUN=mean) #o desvio padrão apply(X,MARGIN=2,FUN=sd) As funções rowSums(), rowMeans(), colSums(), ou colMeans() são equivalentes à função apply(). Elas simplificam o uso para somas (em inglês, sum) e médias (em inglês, mean) de linhas (em inglês, rows) e colunas (em inglês, columns). Se você conhece bem a função apply(), você pode fazer o que essas funções fazem e muito mais. Portanto, ao dominar a função apply(), você acaba por não precisar se preocupar em aprender essas funções mais específicas. ?rowSums rowSums(X) #soma de cada linha rowMeans(X) #media de cada linha colSums(X) #soma de cada coluna colMeans(X) #média de cada coluna 8.1.2 Em um vetor ou lista A função lapply() aplica uma função FUN para cada elemento de um vetor ou de uma lista, e retorna um objeto de classe list. #muito simples, imprime algo linha por linha ll = lapply(LETTERS,print) ## [1] &quot;A&quot; ## [1] &quot;B&quot; ## [1] &quot;C&quot; ## [1] &quot;D&quot; ## [1] &quot;E&quot; ## [1] &quot;F&quot; ## [1] &quot;G&quot; ## [1] &quot;H&quot; ## [1] &quot;I&quot; ## [1] &quot;J&quot; ## [1] &quot;K&quot; ## [1] &quot;L&quot; ## [1] &quot;M&quot; ## [1] &quot;N&quot; ## [1] &quot;O&quot; ## [1] &quot;P&quot; ## [1] &quot;Q&quot; ## [1] &quot;R&quot; ## [1] &quot;S&quot; ## [1] &quot;T&quot; ## [1] &quot;U&quot; ## [1] &quot;V&quot; ## [1] &quot;W&quot; ## [1] &quot;X&quot; ## [1] &quot;Y&quot; ## [1] &quot;Z&quot; class(ll) ## [1] &quot;list&quot; str(ll) ## List of 26 ## $ : chr &quot;A&quot; ## $ : chr &quot;B&quot; ## $ : chr &quot;C&quot; ## $ : chr &quot;D&quot; ## $ : chr &quot;E&quot; ## $ : chr &quot;F&quot; ## $ : chr &quot;G&quot; ## $ : chr &quot;H&quot; ## $ : chr &quot;I&quot; ## $ : chr &quot;J&quot; ## $ : chr &quot;K&quot; ## $ : chr &quot;L&quot; ## $ : chr &quot;M&quot; ## $ : chr &quot;N&quot; ## $ : chr &quot;O&quot; ## $ : chr &quot;P&quot; ## $ : chr &quot;Q&quot; ## $ : chr &quot;R&quot; ## $ : chr &quot;S&quot; ## $ : chr &quot;T&quot; ## $ : chr &quot;U&quot; ## $ : chr &quot;V&quot; ## $ : chr &quot;W&quot; ## $ : chr &quot;X&quot; ## $ : chr &quot;Y&quot; ## $ : chr &quot;Z&quot; #suponha três vetores de tamanhos diferentes v1=sample(1:1000,50) length(v1) ## [1] 50 v2= sample(1:100,30) length(v2) ## [1] 30 v3= sample(1000:2000,90) length(v3) ## [1] 90 #imagina que isso esteja numa lista ml = list(v1,v2,v3) class(ml) ## [1] &quot;list&quot; length(ml) ## [1] 3 #posso usar lapply para calcular a media desses vetores lapply(ml,mean) #note que retorna uma lista ## [[1]] ## [1] 522.92 ## ## [[2]] ## [1] 45.06667 ## ## [[3]] ## [1] 1521.633 lt = lapply(ml,mean) #podemos guardar lt = as.vector(lt, mode=&#39;numeric&#39;) #e transformar num vetor. MODE neste caso é fundamental usar lt ## [1] 522.92000 45.06667 1521.63333 8.1.3 Por categoria de um fator A função tapply() aplica uma função FUN em uma coluna numérica individualizando os resultados para cada categoria de um determinado fator. #vamos usar os dados de Iris novamente ?iris #calculando o comprimento médio de sepálas pelas categorias de um fator (especies) class(iris$Sepal.Length) #variavel numerica class(iris$Species) #fator com categorias que correspondem a especies tapply(iris$Sepal.Length,iris$Species,FUN=mean) #calculando o comprimento máximo por especie tapply(iris$Sepal.Length,iris$Species,FUN=max) #a amplitude de variacao tapply(iris$Sepal.Length,iris$Species,FUN=range) #note que essa funcao sempre retorna um array (que é uma lista de fato, neste caso) tm = tapply(iris$Sepal.Length,iris$Species,FUN=min) class(tm) names(tm) tm[[&#39;setosa&#39;]] #indexadores de lista tr = tapply(iris$Sepal.Length,iris$Species,FUN=range) class(tr) names(tr) tr[[&#39;setosa&#39;]] 8.2 Condicionais Condicionais são expressões que permitem a um programa a tomada de decisões. Vamos tratar aqui das condicionais if (), if () else {}, e ifelse () (veja a seção Para saber mais para mais informações). 8.2.1 Condicional if () A expressão if () avalia um vetor atômico (ou de índice 1) lógico e executa o que estiver entre {} se o valor do vetor for verdadeiro (TRUE). A estrutura básica de um if () é: if (condicao) { ação a ser realizada caso a condição seja VERDADEIRA } Dentro do par de parênteses, deve haver uma condição. Condições em R são feitas com operadores lógicos: ==, !=, &gt;, &lt; etc (veja a seção @ref(#vetor-operador-logico) para relembrar; veja também a seção Para saber mais pois apresenta links para vídeoaulas importantes). 8.2.1.1 Exemplo 01 perdiz_estuda_breu &lt;- TRUE perdiz_estuda_grama &lt;- FALSE perdiz_estuda_breu perdiz_estuda_grama if (perdiz_estuda_breu) { print(&quot;Breu pode ser Protium, Dacryodes, Trattinnickia, e é da família Burseraceae&quot;) } if (perdiz_estuda_grama) { print(&quot;Isso não vai dar imprimir&quot;) } Reparem na condição que deve ser satisfeita dentro dos parênteses: TRUE, para efetuar a ação; se FALSE, não executa a função: if (TRUE) { print(&quot;Eu executo!&quot;) } if (FALSE) { print(&quot;Eu não executo&quot;) } 8.2.2 Condicional if () com o else A condicional if () pode ser expandida para if () { } else {}: execute em {} se if () for VERDADEIRO, caso contrário (== else), execute o que estiver entre o segundo par {}. 8.2.2.1 Exemplo 01 meunumero &lt;- 77 meunumero if (meunumero == 76) { print(&quot;Meu número é o 3&quot;) } else { #meu_else &lt;- paste0(&quot;Mas pode ser o &quot;, meunumero) #print(meu_else) #1+1 print(paste(&quot;Se eu somar o meu número &quot;, meunumero, &quot;com 3, eu vou obter &quot;, meunumero+3)) } 8.2.2.2 Exemplo 02 familia &lt;- c(&quot;Burseraceae&quot;, &quot;Solanaceae&quot;,&quot;Sapindaceae&quot;, &quot;Rubiaceae&quot;) clado &lt;- c(&quot;Malvids&quot;, &quot;Lamiids&quot;, &quot;Malvids&quot;, &quot;Lamiids&quot;) apg &lt;- data.frame(familia = familia, clado = clado, stringsAsFactors = FALSE) apg str(apg) dim(apg) malvids &lt;- c(&quot;Burseraceae&quot;, &quot;Sapindaceae&quot;) meunumero = 4 apg$familia[meunumero] apg$familia[meunumero] %in% malvids if (apg$familia[meunumero] %in% malvids) { malv_fam &lt;- paste(malvids, collapse = &quot; e &quot;) malv_fam clado &lt;- &quot;Malvids&quot; frase &lt;- paste(malv_fam, clado, sep = &quot; pertencem ao clado das &quot;) frase print(frase) } else { paste(&quot;A família&quot;, apg$familia[meunumero], &quot;pertence ao clado das&quot;, apg$clado[meunumero]) } 8.2.3 Condicional ifelse() ifelse(condicao, executa se VERDADEIRO, executa se FALSO) set.seed(333) familia familias &lt;- sample(familia, 100, replace = TRUE) familias table(familias) familias ifelse(familias == &quot;Burseraceae&quot;, TRUE, FALSE) ifelse(familias == &quot;Sapindaceae&quot;, &quot;Sapindaceae é a família do guaraná&quot;, &quot;Não é Sapindaceae&quot;) familias[3] familias[1:10] ifelse(familias == &quot;Sapindaceae&quot;, &quot;Sapindaceae da ordem Sapindales&quot;, ifelse(familias == &quot;Burseraceae&quot;, &quot;Burseraceae também é da ordem Sapindales&quot;, &quot;Nenhuma dessas famílias é uma Sapindales&quot;) ) sei_qual_ordem &lt;- ifelse(familias == &quot;Sapindaceae&quot;, &quot;Sapindaceae da ordem Sapindales&quot;, ifelse(familias == &quot;Burseraceae&quot;, &quot;Burseraceae também é da ordem Sapindales&quot;, &quot;Nenhuma dessas famílias é uma Sapindales&quot;) ) meudf &lt;- data.frame(familias, sei_qual_ordem) meudf 8.2.4 Para saber mais: Vídeoaula - temos duas vídeoaulas disponíveis com parte do conteúdo desta aula. Acesse-as no links abaixo: Vetores e Operadores Lógicos; Condicionais no R Auxílio do R - executem a expressão ?Control no R e vejam a explicação sobre condicionais. 8.3 Iterações Vocês usaram várias funções da família apply, especialmente apply() e tapply(), que são funções especiais que repetem uma mesma função FUN para cada objeto de um conjunto (vetores, matrizes, valores atômicos). Essas funções utilizam portanto a lógica de iterações (em inglês, loops), ou seja, fazem a mesma ação repetidas vezes; em outras palavras, fazem LOOPs, dão voltas, realizam o mesmo percurso várias vezes, percorrem um circuito. As expressões for(){} e while(){} permitem fazer LOOPs, e LOOPs dentro de LOOPS com muita liberdade. Aprendê-las é o mesmo que aprender todas as funções da família apply juntas (apply(), tapply(), sapply(), lapply(), mapply() etc). Se você compreende os LOOPS, pode fazer o que essas funções fazem sem precisar delas (embora elas possam executar a tarefa mais rapidamente). 8.3.1 Iteração com for(){} 8.3.1.1 Exemplo 1 Um exemplo simples do que seria uma iteração com o comando for(){}: #vamos imprimir na tela as letras do objeto LETTERS for(let in 1:length(LETTERS)) { paraimprimir = paste(LETTERS[let],&quot; é a letra de índice &quot;,let) print(paraimprimir) } Ou seja, para cada elemento do objeto let, assumindo os valores na sequência do elemento 1 ao elemento corresponden ao comprimento (== length(LETTERS)) do objeto LETTERS, execute o que está dentro de {}. 8.3.1.2 Exemplo 2 #Fazendo um loop com for(){} replicando o que a função apply() faz #criamos uma matriz vetn = rnorm(100,30,1) mvetn = matrix(vetn,ncol=10,dimnames=list(paste(&#39;linha&#39;,1:10),paste(&#39;coluna&#39;,1:10))) head(mvetn) #Fazendo algo == apply(mvetn,2,mean) #cria um objeto para salvar o resultado resultado = NULL for(coluna in 1:ncol(mvetn)) { #pega a coluna cl = mvetn[,coluna] #calcula a media mcl = mean(cl) print(paste(&quot;Média da coluna&quot;,colnames(mvetn)[cl],&quot;=&quot;,round(mcl,2))) #salva o resultado com a media do item anterior resultado = c(resultado,mcl) } #adicona o nome das colunas names(resultado) = colnames(mvetn) #ver o resultado resultado #identico ao apply, maior controle de como a média é aplicada resultado==apply(mvetn,2,mean) 8.3.1.3 Exemplo 3 Agora usando for(){} para fazer algo como o tapply(). #Fazendo algo == tapply(mvetn[,2],mvetn$classe,sum) #criamos uma matriz vetn = rnorm(100,30,1) mvetn = matrix(vetn,ncol=10,dimnames=list(paste(&#39;linha&#39;,1:10),paste(&#39;coluna&#39;,1:10))) #transformamos num data.frame adicionando uma coluna categorica mvetn = data.frame(classe=sample(paste(&quot;categ&quot;,1:3,sep=&#39;&#39;),size=nrow(mvetn),replace=T),mvetn) head(mvetn[,1:5]) #cria um objeto para salvar o resultado resultado = NULL #para cada categoria for(ct in 1:length(levels(mvetn$classe))) { #pega a categoria cl = levels(mvetn$classe)[ct] #filtra os dados (vetor logico) vl = mvetn$classe==cl #calcula a soma dos dados da categoria soma = sum(mvetn[vl,2],na.rm=T) #imprime o passo print(paste(&quot;A soma da categoria&quot;,cl,&quot; é igual a &quot;,soma)) #junta os resultados resultado = c(resultado,soma) } #atribui nomes aos elementos do vetor de somas names(resultado) = levels(mvetn$classe) #confere resultado==tapply(mvetn[,2],mvetn$classe,sum) 8.3.1.4 Exemplo 4 Calculando somas e médias de linhas, similar ao que podemos fazer com a função apply(): somas = NULL #objeto vazio para salvar soma de cada linha medias = NULL #objeto vazio para salvar medias de cada linha for(i in 1:nrow(X)) { #para cada linha somai = sum(X[i,]) #soma dos valores na linha i somas = c(somas,somai) #junta a somai com o resto (que estará vazio na primeira vez) mediai = mean(X[i,]) #média dos valores na linha i medias = c(medias,mediai) #junta as medias } #como a matriz tem nomes, acrescenta esses nomes aos vetores com resultados names(medias) = rownames(X) medias names(somas) = rownames(X) somas 8.3.2 Iteração com while(){} O comando while(){} funciona de forma parecida, mas faz algo ENQUANTO (em inglês, while) a condição em while(){} seja verdadeira. Um exemplo simples: 8.3.2.1 Exemplo 1 #cria um vetor de valores aleatorizados vet = sample(10:100) #amostra um valor do vetor até que este valor seja 10 conta = 1 valor =0 while(valor!=10) { valor = sample(vet,1) print(paste(&quot;o valor selecionado na iteração&quot;,conta,&quot;foi de &quot;,valor)) conta = conta+1 } 8.3.3 Iteração com for(){} e a condicional if(){} 8.3.3.1 Exemplo 1 #cria um vetor de valores aleatorizados vet = sample(10:100,60,replace=T) #amostra um valor do vetor até que este valor seja 10 for(v in 1:10000) { valor = sample(vet,1) if (valor==10) { #se o valor selecionado aleatoriamente for 10, ou seja se a expressão valor==10 for TRUE execute: #imprima isso print(paste(&quot;A primeira vez que o valor 10 foi selecionado aleatoriamente foi quando o objeto v assumiu o valor de&quot;,v)) #interrompa (quebre) o loop break #note este argumento } else { #caso contrario, valor!=10, imprime o valor selecionado e continua o loop print(paste(&quot;O valor selecionado foi &quot;,valor,&quot;no indice&quot;,v)) } } É possível que o script acima repita as 10000 vezes do for(){} sem encontrar o valor 10, até porque o 10 pode não estar em vet se não for amostrado. 8.4 Criando ou modificando funções Funções são objetos que contêm um script que usa os argumentos (também objetos) para executar alguma coisa. A expressão function(){} é utilizada para criar funções. Criar funções é útil pois podem executar algo várias vezes (podendo ser de forma diferente) sem precisar reescrever o código todas às vezes. Isso nos auxilia em práticas rotineiras como, por exemplo, na manipulação de um conjunto de dados de localização geográfica de espécimes botânicos. Podemos gerar um mapa personalizado de distribuição geográfica de cada espécie criando uma função para plotar um mapa, e depois utilizamos a aplicamos a função sobre a categoria, neste caso, a variável contendo o nome da espécie. É muito útil também poder modificar uma função criada por outra pessoa, seja uma função de um determinado pacote ou uma função que você encontrou em uma página qualquer navegando pela internet. É muito simples construir uma função. Há um bloco que deve ser sempre repetido: function(meu_argumento1, meu_argumento2, ...) { # AQUI FICAM AS AÇÕES DE SUA FUNÇÃO, COMO POR EXEMPLO return(&quot;resultado da função&quot;) # } É costume sempre utilizar a função return() como último elemento da função para que algum objeto seja retornado ao usuário. ?return #veja o help 8.4.1 Exemplo I Vamos fazer a nossa versão da função mean(), que tira a média aritmética dos valores de um vetor. #Vamos fazer essa função na unha: amedia &lt;- function(x) { #x será um vetor de comprimento &gt;=1 e todos os valores devem ser numéricos, senão precisamos avisar. #essa funçao ira retornar o valor do &#39;am&#39; que definimos como nulo inicialmente am = NULL #condicao 1 c1 = is.vector(x) #condicao 2 xx = as.numeric(x) #convertemos em numérico xx = xx[!is.na(xx)] #tira o que não é número (o que não foi convertido ou está em branco) c2 = length(xx)==length(x) #os comprimentos são iguais? e tem algum valor? if (c1 &amp; length(xx)&gt;0) { #se for um vetor e houver algum valor numérico, pode calcular a média am = sum(xx)/length(xx) if (!c2) { #se c1 for falso print(paste(length(x)-length(xx),&quot; valores do vetor não são numéricos e foram excluídos&quot;)) #avisa } } else { print(&quot;O objeto não é um vetor ou não há valores numéricos&quot;) #avisa } return(am) } Vamos agora utilizar a função: v1 = c(1,2,3,4,5,6) amedia(v1) v1 = c(3,3,3,3,3,3,3) amedia(v1) v1 = c(3,3,3,3,3,3,&quot;A&quot;) amedia(v1) v1 = LETTERS amedia(v1) 8.4.2 Exemplo II Os loops por meio da expressão for(){} e a condicional if são muito úteis dentro de funções. Sua função pode, por exemplo, ser construida para que um argumento possa assumir diferentes valores e, a depender do valor, executar uma coisa diferente. Como exemplo, vamos criar uma função que contém o script do exemplo de if: #CRIA uma funcao com os seguintes argumentos: #vet = um vetor de valores #busca.valor = um valor para busca em vet #nrun = numero de vezes da iteracao minhafuncao &lt;- function(vet,busca.valor,nrun) { #cria um loop do número de vezes (note o argumento nrun abaixo) for(v in 1:nrun) { #pega um valor aleatorio #amostra o indice aleatoriamente idx = sample(1:length(vet),1) valor = vet[idx] #se o valor amostrado for igual ao valor procurado para if (valor==busca.valor) { #se o valor selecionado aleatoriamente for 10, ou seja se a expressão valor==10 for TRUE execute: #imprima isso #print(paste(&quot;A primeira vez que o valor 10 foi selecionado aleatoriamente foi quando o objeto v assumiu o valor de&quot;,v)) #interrompa (quebre) o loop break #note este argumento } else { #caso contrario, valor!=10, imprime o valor selecionado e continua o loop #print(paste(&quot;O valor selecionado foi &quot;,valor,&quot;no indice&quot;,v)) } } #o valor do objeto v será o último valor assumido na execucao do for(){}, se tiver encontrado será menor que nrun, caso contrario será ==nrun #se encontrou retorna o indice do valor (que é o último valor assumido por idx) #caso o último valor seja == ao valor buscado, ou que o ultimo v é menor que o especificado em nrun, retorna o indice do valor no vetor vet if(v&lt;nrun | valor==busca.valor) { print(paste(&quot;Encontrei o valor&quot;,busca.valor,&quot;no indice, &quot;,idx,&quot;do vetor indicado&quot;)) return(idx) } else { #caso contrário returna NA print(paste(&quot;Não encontrei o valor&quot;,busca.valor,&quot;no vetor indicado&quot;)) return(NA) } } #usa a função criada umvetor = sample(10:100,60,replace=T) minhafuncao(vet=umvetor,busca.valor=22,nrun=1000) retornou.isso = minhafuncao(vet=umvetor,busca.valor=22,nrun=1000) #e usar de novo com outros valores umvetor = sample(200:300,50,replace=T) sort(table(umvetor),decreasing=T)[1:10] minhafuncao(vet=umvetor,busca.valor=250,nrun=10000) retornou.isso = minhafuncao(vet=umvetor,busca.valor=250,nrun=10000) "],["sumarização-de-dados.html", "9 Sumarização de dados 9.1 Tabelas dinâmicas 9.2 Tabelas de contagem 9.3 Lógica da junção de tabelas 9.4 Junção de tabelas utilizando funções3", " 9 Sumarização de dados 9.1 Tabelas dinâmicas A função tapply() calcula alguma funcão sobre um vetor numérico para cada categoria de um fator. Já a função aggregate() faz o mesmo, mas permite múltiplos fatores e sempre retorna um data.frame. Vamos usar dados de parcelas em caixetais, formações dominadas por Tabebuia cassinoides (Lam.) D.C. (Bignoniaceae), espécie comum da Mata Atlântica nos estados de São Paulo, Minas Gerais, Rio de Janeiro e Espírito Santo. Baixe o arquivo para seu computador e instale-o na sua pasta de trabalho antes de seguir com os comandos abaixo. dir(pattern=&quot;caixeta&quot;) caixeta = read.table(&quot;caixeta.csv&quot;,sep=&#39;,&#39;,header=T) names(caixeta) ## tapply: resumo de uma variavel numerica, separada por niveis de um ou mais fatores ?tapply #veja o help dessa função #altura máxima de cada especie tapply(caixeta$h,INDEX=caixeta$especie, FUN=max) #circunferencia media por localidade tapply(caixeta$cap,INDEX=caixeta$local, FUN=mean) ##&quot;Tabelas dinamicas&quot;: funcao aggregate ## Criar data.frame com altura media dos fustes por especie e por local ?aggregate #veja o help dessa função names(caixeta) #circunferencia máxima por especie ob1 = aggregate(caixeta$cap, by=list(especie=caixeta$especie), FUN=max) class(ob1) #obtenho um data frame head(ob1) #neste caso também poderia fazer assim ob2 = tapply(caixeta$h,caixeta$especie, max) class(ob2) #mas neste caso nos temos um array (um vetor unidimensional) ob2[1:10] #mas se eu quiser por localidade e por especie, preciso usar aggregate caixeta.alt &lt;- aggregate(caixeta$h, by=list(local=caixeta$local,especie=caixeta$especie), FUN=max) head(caixeta.alt) ##Vamos calcular a area basal (soma da area de todo os fustes) ## calculando a area basal de cada fuste, considerando o fuste um círculo perfeito, poderíamos usar: caixeta$ab &lt;- caixeta$cap^2/4*pi ## e agora criamos a planilha, com aggregate, somando as areas basais dos fustes caixeta.2 &lt;- aggregate(caixeta$ab, by=list(local=caixeta$local,parcela=caixeta$parcela,especie=caixeta$especie), FUN=sum) class(caixeta.2) head(caixeta.2) 9.2 Tabelas de contagem Vamos usar utilizar os mesmos dados de caixetas utilizados na seção @ref(#tabela-dinamica). A função table() permite contar valores em fatores e vetores. dir(pattern=&quot;caixeta&quot;) caixeta = read.table(&quot;caixeta.csv&quot;,sep=&#39;,&#39;,header=T) names(caixeta) #tem a coluna especie #podemos resumir quantos individuos tem de cada espécie (considerando que cada linha é um individuo) table(caixeta$especie) #mostra as tres especies mais abundantes sort(table(caixeta$especie), decreasing=T)[1:3] #quantos individuos por localidade? table(caixeta$local) #especie por localidade tb= table(caixeta$especie,caixeta$local) head(tb,3) #mostra as tres primeiras linhas #tabela de presenca e ausencia de especie por localidade tb = table(caixeta$especie,caixeta$local) #quem tem mais de 0 individuos está presente #portanto, substituo por 1 tb[tb&gt;0] = 1 head(tb) #sendo assim, posso ver o numero de especie por localidade aplicando a suma das linha que tem 1 para cada coluna apply(tb,2,sum) 9.3 Lógica da junção de tabelas Unir tabelas é uma prática corriqueira com bases de dados. É comum termos dados relacionados em tabelas diferentes, recurso que minimiza a entrada de redundância e portanto de erros nos nossos dados. É frequente também a necessidade de ter esses dados reunidos em uma só tabela. Para unir tabelas, é necessário que duas tabelas diferentes possuam uma coluna em comum, a quem vamos chamar de identificador. #vou criar aqui uma situação artificial com os dados iris, mas imagine uma situação mais complexa com muitos dados #uma tabela com os nomes das especies spp = unique(data.frame( GENUS = &quot;Iris&quot;, SPECIES = iris$Species, stringsAsFactors = F )) spp$fullname = paste(spp$GENUS, spp$SPECIES) ################################################################ #vou adicionar uns dados para esses nomes baixando da internet ###SO FUNCIONA COM INTERNET: pesquisa esses nomes na interne e traz algo #tem varios jeitos de fazer isso, aqui apenas para produzir um dado #pesquisa no TNRS o nome cientifico library(taxize) #instale se nao tiver sppinfo = sapply(spp$fullname, tp_search, type = &#39;exact&#39;) #pega as colunas obtidas para todos os nomes keys &lt;- table(unlist(lapply(sppinfo, names))) keys = names(keys[keys == length(sppinfo)]) #junta tudo num unico data.frame sppinfo = as.data.frame(do.call(mapply, c(FUN = c, lapply(sppinfo, `[`, keys))), stringsAsFactors = F) #tira osnomes illegits sppinfo = sppinfo[-grep(&quot;illeg&quot;, sppinfo$nomenclaturestatusname, ignore.case = T), ] #cria um identificaor compartilhado entre tabelas sppinfo$Species = gsub(&quot;Iris &quot;, &quot;&quot;, sppinfo$scientificname) #bagunca a ordem sppinfo = sppinfo[sample(1:3), ] rownames(sppinfo) = sppinfo$Species ##NAO SE PREOCUPE EM DECIFRAR A BUSCA E ORGANIZACAO DESSA TABELA ################################################################ #agora temos dois conjuntos de dados, que em comum tem a coluna Species #mas tem linhas diferentes sppinfo head(iris) #suponha que voce queira adicionar à tabela iris uma coluna com informacao que esta na tabela sppinfo #JEITO 1 DE FAZER ISSO (USANDO MATCH) #pega as linhas da tabela sppinfo para cada linha da tabela iris #para isso eu quero o INDICE da tabela sppinfo segundo o valor da coluna Species que a coluna comum às duas tabelas idxinfo = match(iris$Species, sppinfo$Species) #idxinfo é um vetor que tem o mesmo comprimento que o numero de linhas que iris e contem o numero das linhas (os indices) da tabela sppinfo #assim, seguindo indexacao numerica eu posso pegar informacoes da tabela sppinfo e colocar na tabela iris iris$speciesComAutor = sppinfo$scientificnamewithauthors[idxinfo] head(iris) #jutando as duas tabelas novoiris = cbind(iris, sppinfo[idxinfo, ]) head(novoiris) #JEIO 2 DE FAZER ISSO (USANDO INDICES NOMINAIS) #sppinfo contém nomes de linhas que correspondem aos valores que estao na coluna iris$Species #portanto, para fazer a mesma coisa eu poderia simplesmente pegar atraves dos nomes das linhas da tabela sppinfo iris$speciesComAutor = sppinfo[iris$Species, ]$scientificnamewithauthors #juntando as duas tabelas completas novoiris = cbind(iris, sppinfo[iris$Species, ]) 9.4 Junção de tabelas utilizando funções3 O pacote base do R fornece uma função que executa essa ação, chamada merge(). Porém, há alguns tipos de junções não podem ser executados com esta função, o que nos levará ao uso de vetores lógicos em conjunto com a função interaction(). Daremos exemplos com essas duas maneiras. 9.4.1 Dados para nossa prática Utilizaremos três tabelas para esta prática: O data.frame tab1 possui nomes de famílias, gêneros e epítetos específicos de algumas angiospermas: familia &lt;- c(&quot;Burseraceae&quot;, &quot;Solanaceae&quot;,&quot;Sapindaceae&quot;, &quot;Rubiaceae&quot;, &quot;Lauraceae&quot;) generos &lt;- c(&quot;Protium&quot;, &quot;Trattinnickia&quot;, &quot;Dacryodes&quot;, &quot;Duckeodendron&quot;, &quot;Markea&quot;, &quot;Solanum&quot;, &quot;Allophylastrum&quot;, &quot;Cupania&quot;, &quot;Thinouia&quot;, &quot;Psychotria&quot;, &quot;Duroia&quot;, &quot;Cinchona&quot;, &quot;Ocotea&quot;, &quot;Licaria&quot;, &quot;Rhodostemonodaphne&quot;, &quot;Anisophyllea&quot;, &quot;Freziera&quot;) epitetos &lt;- c(&quot;aracouchini&quot;, &quot;burserifolia&quot;, &quot;edilsonii&quot;, &quot;cestroides&quot;, &quot;ulei&quot;, &quot;cyathophorum&quot;, &quot;frutescens&quot;, &quot;rubiginosa&quot;, &quot;myriantha&quot;, &quot;viridis&quot;, &quot;eriopila&quot;, &quot;amazonica&quot;, &quot;delicata&quot;, &quot;aureosericea&quot;,&quot;recurva&quot;, &quot;manausensis&quot;, &quot;carinata&quot;) tab1 &lt;- data.frame(familia = c(rep(familia, each = 3), &quot;Anisophylleaceae&quot;, &quot;Pentaphylacaceae&quot;), genero = generos, epiteto = epitetos, stringsAsFactors = FALSE) kable(tab1, caption = &quot;Tabela 1&quot;) Tabela 9.1: Tabela 1 familia genero epiteto Burseraceae Protium aracouchini Burseraceae Trattinnickia burserifolia Burseraceae Dacryodes edilsonii Solanaceae Duckeodendron cestroides Solanaceae Markea ulei Solanaceae Solanum cyathophorum Sapindaceae Allophylastrum frutescens Sapindaceae Cupania rubiginosa Sapindaceae Thinouia myriantha Rubiaceae Psychotria viridis Rubiaceae Duroia eriopila Rubiaceae Cinchona amazonica Lauraceae Ocotea delicata Lauraceae Licaria aureosericea Lauraceae Rhodostemonodaphne recurva Anisophylleaceae Anisophyllea manausensis Pentaphylacaceae Freziera carinata O data.frame tab2 contem um conjunto pequeno com alguns nomes de famílias, gêneros, e o nome de seus respectivos clados acima dos nomes de ordens segundo o APG (2016): familia2 &lt;- c(&quot;Burseraceae&quot;, &quot;Solanaceae&quot;,&quot;Sapindaceae&quot;, &quot;Rubiaceae&quot;, &quot;Annonaceae&quot;) generos2 &lt;- c(&quot;Protium&quot;, &quot;Duckeodendron&quot;, &quot;Thinouia&quot;, &quot;Psychotria&quot;, &quot;Guatteria&quot;) clado &lt;- c(&quot;Malvids&quot;, &quot;Lamiids&quot;, &quot;Malvids&quot;, &quot;Lamiids&quot;, &quot;Magnoliids&quot;) tab2 &lt;- data.frame(familia = familia2, genero = generos2, clado = clado, stringsAsFactors = FALSE) Tabela 9.2: Tabela 2 familia genero clado Burseraceae Protium Malvids Solanaceae Duckeodendron Lamiids Sapindaceae Thinouia Malvids Rubiaceae Psychotria Lamiids Annonaceae Guatteria Magnoliids O data.frame tab3 corresponde à tabela 2, tab2, sem as famílias Solanaceae e Rubiaceae: tab3 &lt;- subset(tab1, familia %in% c(&quot;Burseraceae&quot;, &quot;Sapindaceae&quot;)) Tabela 9.3: Tabela 3 familia genero epiteto Burseraceae Protium aracouchini Burseraceae Trattinnickia burserifolia Burseraceae Dacryodes edilsonii Sapindaceae Allophylastrum frutescens Sapindaceae Cupania rubiginosa Sapindaceae Thinouia myriantha 9.4.2 Unindo tabelas com merge() O básico para entender a função merge() é saber que existem dois argumentos, x e y, que correspondem aos data.frames de entrada. Quando unimos tabelas, existem junções que adicionam variáveis, e junções que filtram variáveis. Vamos ver abaixo 4 tipos da primeira ( junção interna, junção à esquerda, junção à direita, junção total), e dois tipos desta última ( semijunção e antijunção). 9.4.2.1 Junção interna ao juntarmos tabelas x e y, temos todas as linhas de x em que há valores em comum com y, e todas as colunas de x e y. Se houver múltiplas correspondências entre x e y, todas as combinações retornam. Em nosso exemplo, vamos unir as tabelas 1 e 2. Ambas possuem em comum os identificadores familia e genero. Para facilitar o entendimento, vamos verificar primeiro cada tabela com cores para checar as correspondências entre x e y nas variáveis em comum: Tabela 9.4: Tabela 1 familia genero epiteto Burseraceae Protium aracouchini Burseraceae Trattinnickia burserifolia Burseraceae Dacryodes edilsonii Solanaceae Duckeodendron cestroides Solanaceae Markea ulei Solanaceae Solanum cyathophorum Sapindaceae Allophylastrum frutescens Sapindaceae Cupania rubiginosa Sapindaceae Thinouia myriantha Rubiaceae Psychotria viridis Rubiaceae Duroia eriopila Rubiaceae Cinchona amazonica Lauraceae Ocotea delicata Lauraceae Licaria aureosericea Lauraceae Rhodostemonodaphne recurva Anisophylleaceae Anisophyllea manausensis Pentaphylacaceae Freziera carinata Tabela 9.4: Tabela 2 familia genero clado Burseraceae Protium Malvids Solanaceae Duckeodendron Lamiids Sapindaceae Thinouia Malvids Rubiaceae Psychotria Lamiids Annonaceae Guatteria Magnoliids Reparem que os valores em que há correspondência entre x e y estão coloridos de amarelo; para os em que não há correspondência, estão coloridos de vermelho. Agora, executemos a junção das duas tabelas: merge(x = tab1, y = tab2) familia genero epiteto clado Burseraceae Protium aracouchini Malvids Rubiaceae Psychotria viridis Lamiids Sapindaceae Thinouia myriantha Malvids Solanaceae Duckeodendron cestroides Lamiids Vejam que houve a incorporação dos valores da coluna epiteto, presente apenas na tabela 2, em que há correspondência entre as tabelas 1 e 2. É importante notar que as famílias Lauraceae, Anisophylleaceae, e Pentaphylacaceae ficaram de fora, pois não são encontradas na tabela y, isto é, a tabela 2, assim como seus respectivos gêneros e epítetos associados a estes. Gêneros presentes na tabela 1 de famílias em comum entre ambas as tabelas também não foram incorporados nessa junção, pois nãp encontram correspondência na tabela 2: Dacryodes, Trattinnickia, Markea, Solanum, Allophylastrum, Cupania, Duroia, Cinchona. Revejam o conceito de junção interna para entender o porquê desse acontecimento. 9.4.2.2 Junção à esquerda ao juntarmos tabelas x e y, temos todas as linhas de x, e todas as colunas de x e y. Linhas em x sem correspência em y terão valores NA adicionados nas novas colunas. Se houver múltiplas correspondências entre x e y, todas as combinações retornam. Continuaremos utilizando as tabelas 1 e 2. Como mostrado anteriormente, ambas possuem em comum os identificadores familia e genero. Chequemos novamente as cores das correspondências dentro de cada identificador, coloridas em amarelo: Tabela 9.5: Tabela 1 familia genero epiteto Burseraceae Protium aracouchini Burseraceae Trattinnickia burserifolia Burseraceae Dacryodes edilsonii Solanaceae Duckeodendron cestroides Solanaceae Markea ulei Solanaceae Solanum cyathophorum Sapindaceae Allophylastrum frutescens Sapindaceae Cupania rubiginosa Sapindaceae Thinouia myriantha Rubiaceae Psychotria viridis Rubiaceae Duroia eriopila Rubiaceae Cinchona amazonica Lauraceae Ocotea delicata Lauraceae Licaria aureosericea Lauraceae Rhodostemonodaphne recurva Anisophylleaceae Anisophyllea manausensis Pentaphylacaceae Freziera carinata Tabela 9.5: Tabela 2 familia genero clado Burseraceae Protium Malvids Solanaceae Duckeodendron Lamiids Sapindaceae Thinouia Malvids Rubiaceae Psychotria Lamiids Annonaceae Guatteria Magnoliids Em uma junção à esquerda, todas as linhas de x retornam após a junção. Para executar este tipo de junção, acrescentaremos um novo argumento, all.x = TRUE, indicando que manteremos todas as linhas de x, isto é, o data.frame à esquerda, que é a tabela 1. merge(x = tab1, y = tab2, all.x = TRUE) familia genero epiteto clado Anisophylleaceae Anisophyllea manausensis NA Burseraceae Dacryodes edilsonii NA Burseraceae Protium aracouchini Malvids Burseraceae Trattinnickia burserifolia NA Lauraceae Licaria aureosericea NA Lauraceae Ocotea delicata NA Lauraceae Rhodostemonodaphne recurva NA Pentaphylacaceae Freziera carinata NA Rubiaceae Cinchona amazonica NA Rubiaceae Duroia eriopila NA Rubiaceae Psychotria viridis Lamiids Sapindaceae Allophylastrum frutescens NA Sapindaceae Cupania rubiginosa NA Sapindaceae Thinouia myriantha Malvids Solanaceae Duckeodendron cestroides Lamiids Solanaceae Markea ulei NA Solanaceae Solanum cyathophorum NA Agora, temos uma nova situação. Para os valores de x sem correspondência em y, valores NA são acrescentados. Reparem na coluna clado e vejam que isso ocorreu apenas nesta variável. Por exemplo, vejam a família Anisophylleaceae. Ela ocorre apenas na tabela 1 e, portanto, não possui nenhum valor de cladoa ssociado a ela, pois esta variável ocorre apenas na tabela 2. Com a junção das tabelas, essa variável é retida, porém sem a existência de um valor para a família, é inserido então o valor NA. Temos também o caso de Annonaceae, presente na tabela 2. A família não é recuperada na junção interna, pois ela não existe na tabela 1 dentro da variável familia e, portanto, não apresenta correspondência com nenhum dado da tabela 1. Revejam o conceito de junção à esquerda para entender o porquê desse acontecimento. 9.4.2.3 Junção à direita ao juntarmos tabelas x e y, temos todas as linhas de y, e todas as colunas de x e y.Linhas em y sem correspência em x terão valores NA adicionados nas novas colunas. Se houver múltiplas correspondências entre x e y, todas as combinações retornam. De maneira oposta à junção à esquerda, na junção à direita são mantidas todas as linhas de y. Desta vez, o argumento a ser utilizado é all.y = TRUE. Antes de executar a junção, vamos checar novamente as variáveis em comum e correspondências entre as tabelas x e y: Tabela 9.6: Tabela 1 familia genero epiteto Burseraceae Protium aracouchini Burseraceae Trattinnickia burserifolia Burseraceae Dacryodes edilsonii Solanaceae Duckeodendron cestroides Solanaceae Markea ulei Solanaceae Solanum cyathophorum Sapindaceae Allophylastrum frutescens Sapindaceae Cupania rubiginosa Sapindaceae Thinouia myriantha Rubiaceae Psychotria viridis Rubiaceae Duroia eriopila Rubiaceae Cinchona amazonica Lauraceae Ocotea delicata Lauraceae Licaria aureosericea Lauraceae Rhodostemonodaphne recurva Anisophylleaceae Anisophyllea manausensis Pentaphylacaceae Freziera carinata Tabela 9.6: Tabela 2 familia genero clado Burseraceae Protium Malvids Solanaceae Duckeodendron Lamiids Sapindaceae Thinouia Malvids Rubiaceae Psychotria Lamiids Annonaceae Guatteria Magnoliids Agora executaremos a junção com o comando abaixo. Não deixem de reparar no uso do argumento all.y = TRUE, pois ele é o responsável por agora manter todas as linhas da tabela 2 (== y): merge(x = tab1, y = tab2, all.y = TRUE) familia genero epiteto clado Annonaceae Guatteria NA Magnoliids Burseraceae Protium aracouchini Malvids Rubiaceae Psychotria viridis Lamiids Sapindaceae Thinouia myriantha Malvids Solanaceae Duckeodendron cestroides Lamiids Notem que agora todos os dados da tabela 2 foram mantidos. Houve a inserção de um valor NA para a família Annonaceae na variável epiteto, pois esta variável não está presente na tabela 2. Revejam o conceito de junção à direita para entender o porquê desse acontecimento. 9.4.2.4 Junção total ao juntarmos tabelas x e y, temos todas as linhas e colunas de x e y. Onde não houver valores correspondentes, valores NA serão colocados nesses lugares. Em uma junção total, uniremos todas as linha de x e y utilizando o argumento all = TRUE. merge(x = tab1, y = tab2, all = TRUE) familia genero epiteto clado Anisophylleaceae Anisophyllea manausensis NA Annonaceae Guatteria NA Magnoliids Burseraceae Dacryodes edilsonii NA Burseraceae Protium aracouchini Malvids Burseraceae Trattinnickia burserifolia NA Lauraceae Licaria aureosericea NA Lauraceae Ocotea delicata NA Lauraceae Rhodostemonodaphne recurva NA Pentaphylacaceae Freziera carinata NA Rubiaceae Cinchona amazonica NA Rubiaceae Duroia eriopila NA Rubiaceae Psychotria viridis Lamiids Sapindaceae Allophylastrum frutescens NA Sapindaceae Cupania rubiginosa NA Sapindaceae Thinouia myriantha Malvids Solanaceae Duckeodendron cestroides Lamiids Solanaceae Markea ulei NA Solanaceae Solanum cyathophorum NA Reparem que valores NA são colocados nos valores da tabela 2 referentes à coluna epiteto, ausente na tabela 1. O mesmo se passa com valores da coluna clado, presente na tabela 2 e ausente na tabela 1. Revejam o conceito de junção total para entender o porquê desse acontecimento. 9.4.2.5 Semijunção ao juntarmos tabelas x e y, temos todas as linhas de x onde houver valores correspondentes em y, mantendo apenas colunas de x. É parecida com a junção interna, porém difere desta por nunca duplicar valores de x, retornando sempre apenas valores de x que houver uma correspondência em y. A semijunção é muito similar à junção interna, diferindo desta por não incorporar as colunas de y, pois apenas utiliza esta tabela para filtrar os dados de x, constituindo-se então em um tipo de junção que filtra variáveis. Neste exemplo, utilizaremos as tabelas 1 e 3. Ambas compartilham as colunas familia e genero. Vamos checar primeiramente cada tabela e ver o que é compartilhado entre cada uma: Tabela 9.7: Tabela 1 familia genero epiteto Burseraceae Protium aracouchini Burseraceae Trattinnickia burserifolia Burseraceae Dacryodes edilsonii Solanaceae Duckeodendron cestroides Solanaceae Markea ulei Solanaceae Solanum cyathophorum Sapindaceae Allophylastrum frutescens Sapindaceae Cupania rubiginosa Sapindaceae Thinouia myriantha Rubiaceae Psychotria viridis Rubiaceae Duroia eriopila Rubiaceae Cinchona amazonica Lauraceae Ocotea delicata Lauraceae Licaria aureosericea Lauraceae Rhodostemonodaphne recurva Anisophylleaceae Anisophyllea manausensis Pentaphylacaceae Freziera carinata Tabela 9.7: Tabela 3 familia genero epiteto Burseraceae Protium aracouchini Burseraceae Trattinnickia burserifolia Burseraceae Dacryodes edilsonii Sapindaceae Allophylastrum frutescens Sapindaceae Cupania rubiginosa Sapindaceae Thinouia myriantha Para executar uma semijunção com o pacote base do R, devemos fazer uso de vetores lógicos e da função interaction(), pois a função merge() não fornece uma maneira de se obter o que desejamos. Vamos então à prática4. As colunas compartilhadas por ambas as tabelas serão nossas chaves: chaves &lt;- c(&quot;familia&quot;, &quot;genero&quot;) Partimos então para filtrar na tabela 1 a combinação de linhas para esse conjunto de colunas utilizando a função interaction() do pacote base do R: interaction(tab1[, chaves]) ## [1] Burseraceae.Protium Burseraceae.Trattinnickia ## [3] Burseraceae.Dacryodes Solanaceae.Duckeodendron ## [5] Solanaceae.Markea Solanaceae.Solanum ## [7] Sapindaceae.Allophylastrum Sapindaceae.Cupania ## [9] Sapindaceae.Thinouia Rubiaceae.Psychotria ## [11] Rubiaceae.Duroia Rubiaceae.Cinchona ## [13] Lauraceae.Ocotea Lauraceae.Licaria ## [15] Lauraceae.Rhodostemonodaphne Anisophylleaceae.Anisophyllea ## [17] Pentaphylacaceae.Freziera ## 119 Levels: Anisophylleaceae.Allophylastrum ... Solanaceae.Trattinnickia Essa função computa um vetor de fatores que representa a interação das colunas fornecidas na tabela 1. Se fizermos isso com a tabela 3, poderemos saber quais combinações ocorrem em ambas as tabelas. interaction(tab3[, chaves]) ## [1] Burseraceae.Protium Burseraceae.Trattinnickia ## [3] Burseraceae.Dacryodes Sapindaceae.Allophylastrum ## [5] Sapindaceae.Cupania Sapindaceae.Thinouia ## 12 Levels: Burseraceae.Allophylastrum ... Sapindaceae.Trattinnickia Agora utilizamos a mesma função interaction e o operador %in% para retornar um vetor lógico que utilizaremos para filtrar os valores da tabela 1 com correspondência na tabela 3. linhas &lt;- interaction(tab1[, chaves]) %in% interaction(tab3[, chaves]) linhas ## [1] TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE TRUE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE tab1[linhas,] familia genero epiteto 1 Burseraceae Protium aracouchini 2 Burseraceae Trattinnickia burserifolia 3 Burseraceae Dacryodes edilsonii 7 Sapindaceae Allophylastrum frutescens 8 Sapindaceae Cupania rubiginosa 9 Sapindaceae Thinouia myriantha 9.4.2.6 Antijunção retorna todas as linhas de x em que não há correspondência em y, mantendo apenas colunas de x. Uma antijunção é ligeiramente diferente de uma semijunção pois ela retorna todas as linhas de x que não aparecem em y. Portanto, podemos utilizar o inverso de nosso vetor lógico linhas e utilizar este inverso para filtrar as linhas da tabela 1 e ter nossa tabela antijunção entre x e y: antilinhas &lt;- !linhas tab1[antilinhas, ] familia genero epiteto 4 Solanaceae Duckeodendron cestroides 5 Solanaceae Markea ulei 6 Solanaceae Solanum cyathophorum 10 Rubiaceae Psychotria viridis 11 Rubiaceae Duroia eriopila 12 Rubiaceae Cinchona amazonica 13 Lauraceae Ocotea delicata 14 Lauraceae Licaria aureosericea 15 Lauraceae Rhodostemonodaphne recurva 16 Anisophylleaceae Anisophyllea manausensis 17 Pentaphylacaceae Freziera carinata 9.4.3 Para saber mais Join in R; Tudo sobre Joins (merge) em R; Join com dplyr; Entendendo o JOIN do SQL (ou Junções) - Obtive as imagens aqui apresentadas desta página. Há uma boa explicação com SQL como pano de fundo para operações de junções de tabela. Referências "],["amostragens-aleatórias.html", "10 Amostragens aleatórias 10.1 Funções para gerar permutações e simular dados 10.2 Distribuições aleatórias", " 10 Amostragens aleatórias 10.1 Funções para gerar permutações e simular dados A função sample() aleatoriza valores em um vetor, com ou sem repetição, ou amostra um certo número de valores aleatoriamente de um vetor de valores. #ALEATORIZANDO DADOS SEM AMOSTRAGEM ?sample #suponha um vetor de numeros v1 = 1:20 v1 #os numeros sao sequenciais #se quiser embaralhar aleatoriamente sample(v1) sample(v1) #cada vez será diferente sample(v1) #diferente de novo #no exemplo acima, os numeros sao apenas embaralhados table(v1) #cada valor só aparece uma vez table(sample(v1)) #aqui tambem #se eu quiser amostras com repeticao table(sample(v1,replace=TRUE)) #ele repetiu alguns valores aleatoriamente table(sample(v1,replace=TRUE)) #vai ser diferente toda vez que voce executa #mas o comprimento é sempre o mesmo length(v1) length(sample(v1)) length(sample(v1,replace=T)) #agora com textos table(LETTERS) table(sample(LETTERS,replace=T)) Amostraremos N valores de um vetor qualquer: #agora amostra um número qualquer de valores de um vetor qualquer: umvetor = seq(from=0,to=1000,by=0.1) length(umvetor) head(umvetor,10) #primeiros 10 elementos #agora amostra 100 valores desse vetor que tem 9991 valores umaamostra = sample(umvetor,size=100,replace=T) #entao isso deve ser verdadeiro length(umaamostra)==100 #primeiros 10 valores amostrados head(umaamostra,10) #histograma da amostra hist(umaamostra,col=&#39;red&#39;) #note que a distribuição é uniforme, qualquer valor tem a mesma chance de ser amostrado #faco outra vez e adiciono outraamostra = sample(umvetor,size=100,replace=T) #adiciono ao histograma anterior hist(outraamostra,density=10,add=T,col=&#39;black&#39;) #cada vez é diferente a sequencia de valores amostrados 10.2 Distribuições aleatórias O R disponibiliza um conjunto um conjunto de funções para gerar densidade, distribuição cumulativa, quantis e geração aleatória de variáveis com diferentes distribuições de probabilidade (veja a seção Para saber mais para mais informações). Aqui vamos conhecer as funções que geram variáveis aleatórias para duas distribuições probabilísticas: Distribuição normal; Distribuição log-normal. #veja no R o help para as funções para as diferentes distribuições disponíveis no R. ?Distributions 10.2.1 Distribuição Normal Segundo as companhias aéreas dos EUA, a largura dos quadris dos homens norte-americanos segue uma curva normal, com média de 14.4 polegadas, e desvio-padrão de 1 polegada. 10.2.1.1 rnorm() Esta função permite gerar essa distribuição de valores aleatórios que seguem uma distribuição normal se soubermos a média e o desvio padrão. amedia = 14.4 osd = 1 #vamos gerar 1000 valores aleatórios com essa distribuição ?rnorm #veja o help da função quadris = rnorm(n=1000,mean=amedia,sd=osd) #visualizando essa distribuição de valores hist(quadris) #ou visualizando a densidade probabilística dessa distribuição hist(quadris,probability = T) #a linha da densidade lines(density(quadris),col=&quot;red&quot;,lwd=2) 10.2.1.2 pnorm() Esta função permite responder à pergunta: “Qual percentual de pessoas não cabe em um assento de 15 polegadas?” #qual o percentil/quantil da distribuição que é maior que 15 polegadas #quem não cabe no assento? #veja o help dessa função ?pnorm qMaior15in = pnorm(q=15,mean=14.4,sd=1,lower.tail=F) #note o argumento lower.tail=F (você quer apenas o percentil que está acima desse valor) #ca. de 27% qMaior15in print(paste(round(qMaior15in*100,0),&quot;% dos americanos não cabem em um assento de 15polegadas&quot;,sep=&#39;&#39;)) #vamos visualizar isso x=sort(quadris) #ordenamos os quadris y=dnorm(x,mean=amedia,sd=1) #calculamos a densidade probabilística desses valores plot(x,y,type=&quot;l&quot;,lwd=2,col=&#39;black&#39;,ylab=&quot;Densidade Probabilística&quot;,xlab=&#39;Quadris de americanos (inches)&#39;) #plotamos isso e temos nossa curva normal #agora fazemos o mesmo para os quadris que satisfazem a condicao abline(v=15,lwd=2,col=&#39;blue&#39;) #o quadril da pergunta xx = sort(quadris[quadris&gt;=15]) yy=dnorm(xx,mean=amedia,sd=1) #adicionamos isso na forma de um polígono #coordenadas X do polígono (note que adicionei valores para poder fechar o polígono) xxp = c(15,xx,max(xx),15) #e adiciono também no eixo y yyp = c(0,yy,0,0) #desenho o polígono correspondente polygon(xxp,yyp,col=&quot;red&quot;) ##a area desse polígono representa esse quantil #(i.e. a porcentagem da população que tem quadril &gt;= 15) 10.2.1.3 qnorm() Esta função permite responder à pergunta: Qual largura de assento garante que 95% da população caberá? #agora fazemos o inverso da função pnorm, ao inves de informar o quantil, #informamos o percentil qnorm(p=0.95,mean=14.4,sd=1) #este é o tamanho do assento que inclui 95% dos valores #numa distribuição normal com essa média e esse desvio padrão tamanho95 = qnorm(p=0.95,mean=14.4,sd=1) #graficando isso? hist(quadris,prob=T) #limite de tamanho abline(v=tamanho95,col=&#39;blue&#39;,lwd=2,lty=&#39;dashed&#39; ) #plota valores que estao dentro dessa distribuicao hist(quadris[quadris&lt;tamanho95],prob=T,add=T,col=&#39;red&#39;) 10.2.1.4 dnorm() A função dnorm() gera a densidade probabilística para um conjunto de valores, tendo em vista uma distribuição normal de mesma média e mesmo desvio padrão. Podemos responder à pergunta: Qual a densidade probabilística para um valor de quadril de 12 polegadas? Ou seja, qual a probabilidade de amostrar na população uma pessoa com quadril de 12 in? dq12 = dnorm(x=12,mean=14.4,sd=1) dq12 #mostra na figura #plota a densidade probabilística hist(quadris,prob=T) #coloca a linha lines(density(quadris),col=&#39;red&#39;,lwd=2) #adicona um ponto que mostra a probabilidade do valor points(x=12,y=dq12,pch=21,bg=&#39;blue&#39;) segments(0,dq12,12,dq12,lty=&#39;dotted&#39;,col=&#39;blue&#39;,lwd=2) axis(side=2,at=dq12,labels=paste(round(dq12*100,0),&quot;%&quot;,sep=&#39;&#39;), line=NULL,las=2,col=&#39;blue&#39;) 10.2.2 Para saber mais: Probability distributions "],["extraindo-dados-de-colunas-descritivas.html", "11 Extraindo dados de colunas descritivas 11.1 Dados categóricos 11.2 Listas de referência 11.3 Extraindo altura e dap 11.4 Usando essas funções", " 11 Extraindo dados de colunas descritivas Na compilação de dados de especímenes botânicos, informações sobre a planta e o habitat estão em geral anotadas na forma de textos (notas), num formato pouco útil para entender os atributos dos organismos. Os scripts aqui relacionados mostram exemplos de como extrair informações dessas colunas descritivas, categorizando informações de habito, fertilidade, textura do solo, habitat, dap, altura. 11.1 Dados categóricos A lógica básica é simples. Para cada tipo de informação (variável) você busca por um conjunto de palavras e suas variantes, e substitui todas elas por uma única palavra, criando estados de variação (categorias). É importante pensar na ordem em que a busca é feita, pois em algumas notas descritivas duas palavras podem ser encontradas e você quer apenas uma delas. Por exemplo, na busca por hábito você deveria buscar a palavra epífita antes da palavra árvore, porque se a coleta for de uma planta epífita, a palavra árvore pode aparecer como hospedeiro. Não precisa se preocupar com acentos nem se a palavra está em caixa alta ou baixa. Criaremos uma função para ignorar isso nas comparações. 11.1.1 Passo 01 - Lista de referência Você cria uma lista de referencia (veja a seção 11.2 para exemplos de listas de referência) para cada variável que quer buscar, composta de vetores com palavras ou parte de palavras a serem buscadas. Cada vetor tem um nome que é a palavra que define a categoria (estados de variação da variável). A construção dessa lista deve ser baseada nas palavras que existem nos seus dados. As listas de referência abaixo contêm alguns conjuntos de palavras que você pode ajustar para seu uso. #exemplo com a variável habito com duas categorias que desejamos separar: arvoreta e arvore #criamos a lista de referencia obj[[nome.da.categoria]] = c(palavras.a.buscar): referencias = list() referencias[[&quot;arvoreta&quot;]] = c(&quot;arvoreta&quot;,&quot;treelet&quot;,&quot;arvore pequena&quot;,&quot;arbolito&quot;,&quot;small tree&quot;) referencias[[&quot;árvore&quot;]] = c(&quot;arvore&quot;,&quot;tree&quot;,&quot;rvore&quot;,&quot;arvo&quot;,&quot;arbol&quot;,&quot;avore&quot;) #primeiro arvoreta e depois arvore, porque __arvore__ faz parte da palavra arvoreta e quero diferenciar as duas. Note que erros de grafia podem ser inseridos nesses vetores como palavras a buscar e diferentes idiomas podem ser buscados 11.1.2 Passo 02 - Funções que fazem a busca Primeiro criamos uma função que pega um texto ou vetor de textos e remove acentos. Isso é útil porque é frequente a mesma palavra aparecer com e sem acentos, por isso é melhor ignorar acentos nas comparações. removeacentos &lt;- function(x) { #remove acentos xx = iconv(x, to=&quot;ASCII//TRANSLIT&quot;) xx = gsub(&quot;[~|^|~|\\&quot;|&#39;|`]&quot;,&quot;&quot;,xx) return(xx) } E uma segunda função que usa a lista de referência para extrair os dados de um texto. #x é um vetor character de comprimento=1 com o texto original a ser explorado #referencias é uma lista de comprimento &gt;=1 referente as categorias a serem buscadas em x pegavalor &lt;- function(x,referencias) { acategoria = NA #objeto onde armazena a categoria caso encontre em x x = x[!is.na(x)] #elimina elementos NA em x x = removeacentos(x) if (length(x)==1 &amp; is.character(x)[1]) { #se x ainda for um texto for(t in 1:length(referencias)) { #se ainda não encontrou procura em outra referencia if (is.na(acategoria)) { words = referencias[[t]] #pega as palavras a serem buscadas words = words[!is.na(words)] #limpa caso haja NAs hab = names(referencias)[t] #pega a categoria correspondente if (!is.null(hab) &amp; !is.na(hab) &amp; length(words)&gt;=1) { words = removeacentos(words) found = 0 #para cada palavra chave busca em x e se encontrar anota for(g in 1:length(words)) { gp = grep(words[g],x,ignore.case=T) if (length(gp)&gt;0) { found &lt;- found + 1 } } #se encontrou, atribui if (found&gt;0) { acategoria = hab } } } } } #retorna o resultado return(acategoria) } 11.1.3 Passo 03 - Usando a função Vamos utilizar dados de exemplo para testar a função. Baixe o arquivo presente neste link (http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=analises:baixandoespecimenes:pegados_dados_exemplo.csv). Ele apresenta uma coluna com notas de exsicatas para ilustrar nosso exemplo. #voce já deve ter os seguinte objetos: pegavalor(), removeacentos(), referencias #le o arquivo de exemplo dados = read.table(file=&quot;pegados_dados_exemplo.csv&quot;,sep=&#39;\\t&#39;,as.is=T,na.strings=c(&quot;NA&quot;,&quot;NULL&quot;,&quot;&quot;),header=T) txt.org = dados$NOTAS_ORIGINAL #coluna com dados de notas (cada linha é um registro) head(txt.org) habito = sapply(txt.org,pegavalor,referencias=referencias) table(habito) #o que estiver NA significa que ele não encontrou as palavras em referencias. #adiciona com uma nova coluna em dados dados$HABITO = habito 11.2 Listas de referência As listas de referência abaixo podem ser úteis e você pode acrescentar termos de busca a cada categoria. A ordem das categorias na lista deve ser pensada de forma que minimize erros. Por exemplo, é importante primeiro encontrar liana herbacea e apenas depois definir liana lenhosa porque muitas vezes aparece apenas a palavra ‘liana’ que se refere a plantas lenhosas quando não diferenciada. O formato básico é: lista[[“categoria a definir”]] = c(vetor com as palavras a serem encontradas que indiquem a categoria) 11.2.1 Hábito da planta habito.refs = list() habito.refs[[&quot;liana herbácea&quot;]] = c(&quot;erva trepadeira&quot;,&quot;trepadeira&quot;,&quot;liana herbácea&quot;,&quot;liana herbacea&quot;,&quot;erva liana&quot;, &quot;rastejante&quot;,&quot;vine&quot;,&quot;scandent vine&quot;,&quot;erva liana&quot;) habito.refs[[&quot;liana lenhosa&quot;]] = c(&quot;cipó&quot;,&quot;liana&quot;,&quot;liana sublenhosa&quot;,&quot;liana lenhosa&quot;) habito.refs[[&quot;hemiepífita&quot;]] = c(&quot;hemiepifita&quot;,&quot;hemi-epifita&quot;,&quot;hemiepiphyte&quot;,&quot;hemi-epiphyte&quot;) habito.refs[[&quot;epífita&quot;]] = c(&quot;epífita&quot;,&quot;epiphyte&quot;) habito.refs[[&quot;arvoreta&quot;]] = c(&quot;arvoreta&quot;,&quot;treelet&quot;,&quot;Trellet&quot;,&quot;arvore pequena&quot;,&quot;arbolito&quot;,&quot;small tree&quot;) habito.refs[[&quot;árvore&quot;]] = c(&quot;m de altura&quot;,&quot;DAP:&quot;,&quot;arvore&quot;,&quot;tree&quot;,&quot;rvore&quot;,&quot;arvo&quot;,&quot;arbol&quot;,&quot;arbre&quot;,&quot;Arbor&quot;,&quot;Arv.&quot;,&quot; DAP&quot;,&quot;DBH &quot;,&quot; DBH&quot;,&quot;DAP &quot;,&quot;D.A.P. &quot;,&quot;Árovore&quot;,&quot;Arborea&quot;,&quot;Ávore&quot;,&quot;ÁRVIRE&quot;,&quot;Arbóreo&quot;,&quot;Tronco &quot;, &quot; PAP &quot;,&quot;Rrv.&quot;) habito.refs[[&quot;arbusto&quot;]] = c(&quot;arbust&quot;,&quot;shrub&quot;,&quot;scrub&quot;,&quot;subarbust&quot;,&quot;arbust&quot;,&quot;Shruv&quot;) habito.refs[[&quot;hemiparasita&quot;]] = c(&quot;hemiparasit&quot;,&quot;hemi-parasit&quot;) habito.refs[[&quot;saprófita&quot;]] = c(&quot;saprofit&quot;,&quot;saprophy&quot;) habito.refs[[&quot;parasita&quot;]] = c(&quot;parasit&quot;) habito.refs[[&quot;erva aquática&quot;]] = c(&quot;erva aquática&quot;,&quot;erva aquatica&quot;,&quot;Macrófita aquática&quot;,&quot;macrofit&quot;,&quot;macrophy&quot;,&quot;aquatic herb&quot;) habito.refs[[&quot;erva&quot;]] = c(&quot;erva&quot;,&quot;herbace&quot;,&quot;terrestre&quot;,&quot;herbacia&quot;,&quot;herb&quot;) 11.2.2 Estado de fertilidade da amostra fertilidade.refs = list() fertilidade.refs[[&quot;flores&quot;]] = c(&quot; flor&quot;,&quot; petal&quot;,&quot; flôr&quot;,&quot; pétala&quot;,&quot; estigma&quot;,&quot; sépal&quot;,&quot; sepal&quot;,&quot; bract&quot;,&quot; flower&quot;,&quot; bráctea&quot;,&quot;sicônio&quot;,&quot;siconio&quot;,&quot; estgimas&quot;, &quot; espadice&quot;,&quot; espádice&quot;, &quot; ovário&quot;,&quot;ovario&quot;, &quot; tépala&quot;,&quot; antera&quot;,&quot; estame&quot;,&quot;tepala&quot;,&quot;Pétal&quot;, &quot;Tépal&quot;, &quot;Sépal&quot;,&quot;espata&quot;, &quot;corolla&quot;, &quot;anthers&quot;) fertilidade.refs[[&quot;botões&quot;]] = c(&quot; botão&quot;,&quot; botões&quot;,&quot; botao&quot;,&quot; botao&quot;,&quot; bud&quot;) fertilidade.refs[[&quot;frutos&quot;]] = c(&quot; fruto&quot;,&quot; fruit&quot;,&quot;futo&quot;, &quot;f ruto&quot;,&quot;frutescencia&quot;,&quot;frutescenc&quot;,&quot;frutescênc&quot;,&quot; legume&quot;,&quot; semente&quot;,&quot; cupula&quot;,&quot; cúpula&quot;) fertilidade.refs[[&quot;estéril&quot;]] = c(&quot;Estéril&quot;,&quot;Sterile&quot;) 11.2.3 Classes de hábitat habitat.refs = list() habitat.refs[[&quot;Floresta ciliar&quot;]] = c(&quot;Riverbank&quot;,&quot;beria de rio&quot;,&quot;beira de rio&quot;,&quot;berra de rio&quot;,&quot; ciliar&quot;,&quot;galeria&quot;,&quot;Gallery forest&quot;,&quot;margem alta do igarap&quot;) habitat.refs[[&quot;Floresta de igapó&quot;]] = c(&quot;igapo&quot;,&quot;margin of black water igarapé&quot;) habitat.refs[[&quot;Floresta Inundável&quot;]] = c(&quot;varzea&quot;,&quot;flooded forest&quot;,&quot;floresta indundavel&quot;,&quot;periodicamente inundavel&quot;) habitat.refs[[&quot;Campinarana&quot;]] = c(&quot;campinarana&quot;,&quot;varillal&quot;,&quot;chamisal&quot;,&quot;wallaba&quot;,&quot;curuni&quot;,&quot;sandy soil&quot;,&quot;Solo arenoso, dossel&quot;) habitat.refs[[&quot;Campina&quot;]] = c(&quot;campina&quot;,&quot;campinarana gramíneo lenhosa&quot;,&quot;savannis areno&quot;) habitat.refs[[&quot;Aquático&quot;]] = c(&quot;aquatic&quot;) habitat.refs[[&quot;Vegetação secundária&quot;]] = c(&quot;Mata secundária&quot;,&quot;Secondary forest&quot;,&quot;capoeira&quot;,&quot;Disturbed margin of road&quot;,&quot;mata perturbada&quot;,&quot;mata pertubada&quot;,&quot;rea alterada&quot;,&quot;beira de mata&quot;,&quot;beira de estrada&quot;,&quot;beira da estrada&quot;,&quot;antropizada&quot;,&quot;floresta secundária&quot;,&quot;vegetação secundária&quot;) habitat.refs[[&quot;Floresta de Baixio&quot;]] = c(&quot;Nomflooded moist forest&quot;,&quot;baixio&quot;,&quot;area encharcada&quot;,&quot;encharcado&quot;,&quot;Non-flooded moist forest&quot;,&quot;Solo argiloso sujeito a inundação tempor&quot;) habitat.refs[[&quot;Floresta de Vertente&quot;]] = c(&quot;vertente&quot;,&quot;encosta&quot;,&quot;slope&quot;,&quot;Solo areno-argiloso&quot;) habitat.refs[[&quot;Floresta de Platô&quot;]] = c(&quot;plato&quot;,&quot;plateau&quot;) habitat.refs[[&quot;Floresta de Terra Firme&quot;]] = c(&quot;Solo argiloso. Dossel&quot;,&quot;Solo argiloso, dossel&quot;,&quot;Mata de solo argiloso&quot;,&quot;Upland hillside forest&quot;,&quot;Upland forest&quot;,&quot;Primary forest&quot;,&quot;terra firme&quot;,&quot;terra alta&quot;,&quot;Terreno firme&quot;,&quot;Floresta&quot;,&quot;Mata primaria&quot;,&quot;Mata de terra&quot;,&quot;Terreno argiloso&quot;,&quot;Mature forest&quot;) habitat.refs[[&quot;Cerradão&quot;]] = c(&quot;cerradao&quot;) habitat.refs[[&quot;Cerrado&quot;]] = c(&quot;cerrado&quot;,&quot;savanna&quot;,&quot;savana&quot;) habitat.refs[[&quot;Campo rupestre&quot;]] = c(&quot;Campo rupestre&quot;) 11.2.4 Textura do solo solo.refs = list() solo.refs[[&quot;pedregoso&quot;]] = c(&quot;pedregos&quot;,&quot;pedral&quot;,&quot;rock&quot;) solo.refs[[&quot;areno-argiloso&quot;]] = c(&quot;areno-argilos&quot;,&quot;areno argilos&quot;,&quot;arenoso-argiloso&quot;,&quot;arenoso argiloso&quot;,&quot;argilo-arenoso&quot;,&quot;argilo arenoso&quot;,&quot;areno-arcill&quot;) solo.refs[[&quot;argiloso&quot;]] = c(&quot;argilos&quot;,&quot;agilos&quot;,&quot;clay&quot;,&quot;clayish&quot;,&quot; loam&quot;,&quot; arcill&quot;) solo.refs[[&quot;arenoso&quot;]] = c(&quot;arenoso&quot;,&quot;aenoso&quot;,&quot;areia branca&quot;,&quot;sand&quot;,&quot;arrenoso&quot;) solo.refs[[&quot;siltoso&quot;]] = c(&quot; silte&quot;,&quot; silt&quot;) 11.2.5 Exsudato exsudato.refs = list() exsudato.refs[[&quot;látex&quot;]] = c(&quot;latex&quot;,&quot;látex&quot;) exsudato.refs[[&quot;resina&quot;]] = c(&quot;resina&quot;) exsudato.refs[[&quot;seiva&quot;]] = c(&quot;seiva&quot;,&quot; sap &quot;) exsudato.refs[[&quot;exsudato&quot;]] = c(&quot;exsudato&quot;,&quot;exsudação&quot;,&quot;exsudate&quot;) 11.3 Extraindo altura e dap Funções para extrair altura e DAP de colunas descritivas. 11.3.1 Altura pegaaltura &lt;- function(x) { x=gsub(&quot;\\\\+/-&quot;,&quot;&quot;,x) x=gsub(&quot; &quot;,&quot; &quot;,x) x=gsub(&quot; &quot;,&quot; &quot;,x) print(x) pt1 = &quot;[-+]?[0-9]*[,.]?[0-9] m x&quot; pt2 = &quot;[-+]?[0-9]*[,.]?[0-9]m x&quot; pt3 = &quot;[-+]?[0-9]*[,.]?[0-9] m\\\\. x&quot; pt4 = &quot;[-+]?[0-9]*[,.]?[0-9] m de altura&quot; pt5 = &quot;[-+]?[0-9]*[,.]?[0-9] m\\\\. de altura&quot; pt6 = &quot;[-+]?[0-9]*[,.]?[0-9]m d ealtura&quot; pt7 = &quot;[-+]?[0-9]*[,.]?[0-9]m de alto&quot; pt8 = &quot;[-+]?[0-9]*[,.]?[0-9] m de alto&quot; pt9 = &quot;[-+]?[0-9]*[,.]?[0-9]m alto&quot; pt10 = &quot;[-+]?[0-9]*[,.]?[0-9]m de altura&quot; pt11 = &quot;[-+]?[0-9]*[,.]?[0-9] m tall&quot; pt12 = &quot;[-+]?[0-9]*[,.]?[0-9]m tall&quot; pt13 = &quot;[-+]?[0-9]*[,.]?[0-9] m\\\\. tall&quot; pt14 = &quot;[-+]?[0-9]*[,.]?[0-9] m\\\\. Tall&quot; pt15 = &quot;[-+]?[0-9]*[,.]?[0-9]m\\\\. tall&quot; pt16 = &quot;Tree, [-+]?[0-9]*[,.]?[0-9]m&quot; pt17 = &quot;Tree, [-+]?[0-9]*[,.]?[0-9] m&quot; pt18 = &quot;Tree [-+]?[0-9]*[,.]?[0-9] m&quot; pt19 = &quot;Tree [-+]?[0-9]*[,.]?[0-9]m&quot; pt20 = &quot;to [-+]?[0-9]*v?[0-9] m&quot; pt21 = &quot;Tree [0-9]*-[0-9]*m&quot; pt22 = &quot;de [-+]?[0-9]*[,.]?[0-9] m&quot; pt23 = &quot;de [-+]?[0-9]*v?[0-9]m&quot; pt24 = &quot;de [0-9]*-[0-9]* m&quot; pt25 = &quot;Tree [0-9]*-[0-9]* m&quot; pt26 = &quot;de [0-9]*-[0-9]*m&quot; pt27 = &quot;alt. [-+]?[0-9]*[,.]?[0-9] m&quot; pt28 = &quot;[-+]?[0-9]*[,.]?[0-9] feet high&quot; pt29 = &quot;[-+]?[0-9]*[,.]?[0-9] ft. high&quot; pt30 = &quot;rvore [-+]?[0-9]*[,.]?[0-9]m&quot; pt31 = &quot;rvore [-+]?[0-9]*[,.]?[0-9] m&quot; pt32 = &quot;rvore, [-+]?[0-9]*[,.]?[0-9] m&quot; pt33 = &quot;rvore, [-+]?[0-9]*[,.]?[0-9]m&quot; pt34 = &quot;rbusto [-+]?[0-9]*[,.]?[0-9]m&quot; pt35 = &quot;rbusto [-+]?[0-9]*[,.]?[0-9] m&quot; pt36 = &quot;rbusto, [-+]?[0-9]*[,.]?[0-9] m&quot; pt37 = &quot;rbusto, [-+]?[0-9]*[,.].?[0-9]m&quot; pt38 = &quot;rvore +/- [-+]?[0-9]*[,.].?[0-9]m&quot; pt39 = &quot;rvore ca. [-+]?[0-9]*[,.].?[0-9]m&quot; pt40 = &quot;de [-+]?[0-9]*[,.].?[0-9] de altura&quot; pt41 = &quot;altura [-+]?[0-9]*[,.].?[0-9]m&quot; pt42 = &quot;altura [-+]?[0-9]*[,.].?[0-9] m&quot; pt43 = &quot;of [-+]?[0-9]*[,.].?[0-9]m&quot; pt44 = &quot;to [-+]?[0-9]*[,.].?[0-9]m&quot; pt45 = &quot;Treelet [-+]?[0-9]*[,.].?[0-9]m&quot; pt46 = &quot;rvore [-+]?[0-9]*[,.].?[0-9] m&quot; pt47 = &quot;rvore, [-+]?[0-9]*[,.].?[0-9] m&quot; pt48 = &quot;rvoreta, [-+]?[0-9]*[,.].?[0-9] m&quot; pt49 = &quot;Fuste= [-+]?[0-9]*[,.].?[0-9] m&quot; pt50 = &quot;Fuste= [-+]?[0-9]*[,.].?[0-9]m&quot; pt51 = &quot;com [-+]?[0-9]*[,.].?[0-9] m. alt.&quot; pt52 = &quot;Height: [-+]?[0-9]*[,.].?[0-9] m&quot; pt53 = &quot;Arbol [-+]?[0-9]*[,.].?[0-9]m&quot; pt54 = &quot;Treelet, [-+]?[0-9]*[,.].?[0-9]m&quot; pt55 = &quot;altura = [-+]?[0-9]*[,.].?[0-9]m&quot; pt56 = &quot;Fuste = [-+]?[0-9]*[,.].?[0-9]m&quot; pt57 = &quot;Fuste = [-+]?[0-9]*[,.].?[0-9] m&quot; altura = NA for(p in 1:57) { pt = get(paste(&quot;pt&quot;,p,sep=&quot;&quot;)) gp = grep(pt,x,ignore.case = F) if (length(gp)&gt;0 &amp; is.na(altura)) { print(p) rmm = strsplit(x,pt)[[1]] rmm = rmm[rmm!=&quot;&quot; &amp; rmm!=&quot;.&quot; &amp; !is.na(rmm)] xx = x if (length(rmm)&gt;0) { for(r in length(rmm):1) { xx = gsub(rmm[r],&quot;&quot;,xx,fixed=T,useBytes=T) } } xx = mytrim(gsub(&quot;[A-Z]|\\\\(|\\\\)|:|=&quot;,&quot;&quot;,xx,ignore.case = T)) xx = gsub(&quot;,&quot;,&quot;.&quot;,xx) tt = grep(&quot;-&quot;,xx) if (length(tt)&gt;0) { xxx = strsplit(xx,&quot;-&quot;)[[1]] xxx = xxx[xxx!=&quot;&quot;] xxx = gsub(&quot; \\\\.&quot;,&quot;&quot;,xxx) xx = mean(as.numeric(mytrim(xxx)),na.rm=T) } else { xx = strsplit(xx,&quot; &quot;)[[1]] xx = mytrim(xx) xx = xx[xx!=&quot;.&quot;] xx = xx[1] } xx = as.numeric(xx) if (!is.na(xx) &amp;&amp; xx&gt;0) { altura = xx } else {altura = NA} } } return(altura) } 11.3.2 DAP pegadap &lt;- function(x) { x=gsub(&quot;\\\\+/-&quot;,&quot;&quot;,x) x=gsub(&quot; &quot;,&quot; &quot;,x) x=gsub(&quot; &quot;,&quot; &quot;,x) print(x) pt1 = &quot;x [-+]?[0-9]*[,.]?[0-9] cm de circ&quot; pt2 = &quot;x [-+]?[0-9]*[,.]?[0-9] cm de di&quot; pt3 = &quot;x [-+]?[0-9]*[,.]?[0-9]cm de di&quot; pt4 = &quot;x [-+]?[0-9]*[,.]?[0-9]cm di&quot; pt5 = &quot;m x [-+]?[0-9]*[,.]?[0-9] cm DAP&quot; pt6 = &quot;m x [-+]?[0-9]*[,.]?[0-9] cm&quot; pt7 = &quot;de [-+]?[0-9]*[,.]?[0-9] m de DAP&quot; pt8 = &quot;[-+]?[0-9]*[,.]?[0-9] cm de DAP&quot; pt9 = &quot;[-+]?[0-9]*[,.]?[0-9] cm (DAP)&quot; pt10 = &quot;[-+]?[0-9]*[,.]?[0-9] cm dbh&quot; pt11 = &quot;DAP [-+]?[0-9]*[,.]?[0-9] cm&quot; pt12 = &quot;[-+]?[0-9]*[,.]?[0-9] cm D.A.P.&quot; pt13 = &quot;D.A.P. = [-+]?[0-9]*[,.]?[0-9] cm&quot; pt14 = &quot;[-+]?[0-9]*[,.]?[0-9]cm de di&quot; pt15 = &quot;[-+]?[0-9]*[,.]?[0-9]cm dap&quot; pt16 = &quot;[-+]?[0-9]*[,.]?[0-9]cm. dia&quot; pt17 = &quot;dbh. [-+]?[0-9]*[,.]?[0-9]cm&quot; pt18 = &quot;[-+]?[0-9]*[,.]?[0-9]cm. in dia&quot; pt19 = &quot;[-+]?[0-9]*[,.]?[0-9] cm de di&quot; pt20 = &quot;[-+]?[0-9]*[,.]?[0-9] cm (DAP)&quot; pt21 = &quot;DBH [-+]?[0-9]*[,.]?[0-9] cm&quot; #x=&quot;Árvore de 13m de altura x 11cm de diâmetro do fuste.&quot; altura = NA for(p in 1:21) { pt = get(paste(&quot;pt&quot;,p,sep=&quot;&quot;)) gp = grep(pt,x,ignore.case = F) if (length(gp)==1 &amp; is.na(altura)) { print(p) rmm = strsplit(x,pt)[[1]] rmm = rmm[rmm!=&quot;&quot; &amp; rmm!=&quot;.&quot; &amp; !is.na(rmm)] xx = x if (length(rmm)==1) { for(r in length(rmm):1) { xx = gsub(rmm[r],&quot;&quot;,xx,fixed=T,useBytes=T) } } else { if (length(rmm)==2) { n1 = nchar(rmm[1]) n2 = nchar(rmm[2]) n0 = nchar(x) ns = n1+1 nt = n0-n2 xx= substr(x,ns,nt) } else { if (length(rmm)&gt;2) { xx= NA } } } if (!is.na(xx)) { xx = mytrim(gsub(&quot;[A-Z]|\\\\(|\\\\)|:|=&quot;,&quot;&quot;,xx,ignore.case = T)) xx = gsub(&quot;,&quot;,&quot;.&quot;,xx) tt = grep(&quot;-&quot;,xx) if (length(tt)&gt;0) { xxx = strsplit(xx,&quot;-&quot;)[[1]] xxx = xxx[xxx!=&quot;&quot;] xxx = gsub(&quot; \\\\.&quot;,&quot;&quot;,xxx) xx = mean(as.numeric(mytrim(xxx)),na.rm=T) } else { xx = strsplit(xx,&quot; &quot;)[[1]] xx = mytrim(xx) xx = xx[xx!=&quot;.&quot; &amp; xx!=&quot;&quot; &amp; xx!=&quot;...&quot;] xx = xx[1] if (substr(xx,nchar(xx),nchar(xx))==&quot;.&quot;) { xx = substr(xx,1,nchar(xx)-1) } } xx = as.numeric(xx) if (xx&gt;0) { altura = xx } } } } return(altura) } #funcoes uteis mytrim &lt;- function (x) {gsub(&quot;^\\\\s+|\\\\s+$&quot;, &quot;&quot;, x)} 11.4 Usando essas funções # usando os dados de exemplo carregados acima txt.org = as.vector(dados$NOTAS) #sua coluna com dados descritivos #aplica a funcao daps = sapply(txt.org,pegadap) head(daps) names(daps) = NULL #quais valores viraram NA (ou seja, não encontrou um valor de dap) txt.org[is.na(daps)] #adiciona ao conjunto de dados dados$DAPcm = daps #aplica a funcao alts = sapply(txt.org,pegaaltura) head(alts) names(alts) = NULL #quais valores viraram NA (ou seja, não encontrou um valor de altura) txt.org[is.na(alts)] #histograma hist(alts) #adiciona ao conjunto de dados dados$ALTURAm = alts "],["suplementos.html", "12 Suplementos 12.1 Base R vs. Tidyverse 12.2 Baixar e descomprimir um arquivo zip usando o R 12.3 Aulas em vídeo", " 12 Suplementos 12.1 Base R vs. Tidyverse A linguagem R completou 20 anos de idade neste mês de março de 2020, e a cada dia se torna mais popular. Pesquisa recente publicada no mês de março feita pelo TIOBE Programming Community Index, um site que agrega indicadores sobre a popularidade de linguagens de programação, posiciona a linguagem como a 11º entre as mais populares no mundo A TIOBE agrega dados do Google, Yahoo, Bing, Wikipedia, Youtube, Badu, e Amazon, para gerar estes resultados, que são apresentados mensalmente. Parte dessa popularidade é relativamente recente, podendo ser verificada a partir do ano de 2014. Coincidência ou não, 2014 é o ano de surgimento do pacote dplyr, o primeiro de uma série de pacotes que coletivamente vieram a se tornar conhecidos como Tidyverse. Porcentagem de visitas às questões pertinentes a algumas linguagens de programação na plataforma Stack Overflow. Dados obtidos apenas de países desenvolvidos segundo o Banco Mundial. Nota-se o aumento quase linear referente à linguagem R a partir do ano 2014. Figura extraída desta postagem: https://stackoverflow.blog/2017/10/10/impressive-growth-r/ 12.1.1 O que é o Tidyverse?5 O Tidyverse é um conjunto de pacotes de R desenvolvidos para a ciência de dados. Todos os pacotes compartilham uma mesma filosofia e gramática da linguagem. Por exemplo, a estrutura das funções é sempre a mesma: o primeiro argumento sempre é data, isto é, você deve sempre apresentar os dados neste local. Já que o universo destes pacotes é focado em dados na forma de uma tabela, aqui sempre deve ser fornecido um data.frame; Argumentos posteriores modificam o data.frame por exemplo, na função select() do pacote dplyr, você deve fornecer os nomes das colunas que deseja selecionar no seu conjunto de dados; na função separate_rows do pacote tidyr, você deve fornecer os nomes das colunas que se deseja separar em uma ou mais colunas além de indicar o separador (por exemplo, você pode ter uma coluna que possui os nomes Sapotaceae;Burseraceae e deseja separar isso em duas colunas; você deve indicar que o separador é ;). A função sempre deve retornar um data.frame (existem algumas exceções feitas às funções de alguns pacotes voltados exclusivamente para lidar com vetores, como por exemplo o pacote purrr; porém o uso dessas funções é geralmente utilizado dentro de colunas do seu data.frame) Pretendemos aqui apresentar apenas funcionalidades básicas de dois dos pacotes deste universo, e mostrar como se tornam poderosas quando integrados ao mesmo fluxo de trabalho. 12.1.1.1 dplyr e ggplot2, símbolos do Tidyverse Talvez os pacotes mais conhecidos deste universo sejam o dplyr e o ggplot2. Enquanto o primeiro é especializado na manipulação de dados, o segundo é voltado para a produção de plots. O dplyr surgiu com o objetivo de fornecer um conjunto de ferramentas (suas funções!) para uma manipulação eficiente de conjuntos de dados sob a forma de data.frames, e rapidamente, ganhou muitos adeptos devido à facilidade de uso de suas funções dentro de uma nova gramática para a manipulação de dados (palavras do criador do pacote, Hadley Wickham, em sua postagem de introdução do pacote). Essa nova gramática incluiu tanto o uso de funções com nomes de verbos (em inglês, vale ressaltar) desenhados para executar muito bem apenas uma ação (Tabela 12.1), quanto o uso do que se convencionou chamar de pipe, criado para encadear ações da esquerda para a direita, resultando em menos objetos intermediários estocados na área de trabalho e facilitando a leitura do código. Com o uso de verbos como nome de funções e uma sintaxe diferente da tradicionalmente utilizada em R, o pacote ganhou muitos adeptos deste sua disponibilização no CRAN em janeiro de 2012. Seguindo o mesmo caminho, o pacote ggplot2 (Tabela 12.2), também do mesmo autor do pacote dplyr, porém já de muito mais idade (foi lançado oficialmente em 10 de junho de 2007) se tornou uma referência na produção de gráficos utilizando a linguagem R, ao propor a construção de gráficos por camadas, similar ao utilizado em programas de SIG. Dentro desta nova sintaxe em R, o operador + ganhou uma nova função. Nas próximas seções, vamos ver alguns exemplos práticos utilizando esses dois pacotes. 12.1.2 Usando o dplyr Vamos utilizar o famoso conjunto iris6 para aprender a manipular os dados com as ferramentas do dplyr. Vamos aprender brevemente como funcionam as principais funções deste pacote (Tabela 12.1). Primeiro vamos carregar o pacote para a sessão de trabalho: library(&quot;dplyr&quot;) Tabela 12.1: Principais funções do pacote R dplyr. Função O que faz select() seleciona colunas dos dados filter() filtra linhas específicas dos dados arrange() ordena as linhas do data.frame mutate() cria novas colunas no data.frame summarise() sumariza os dados de acordo com grupos group_by() agrupa os dados segundo grupos 12.1.2.1 Selecionando colunas com select() Agora, vamos utilizar a função select() para selecionar colunas. Ela funciona da seguinte maneira: primeiro, utiliza-se como primeiro argumento o nome do data.frame que se deseja trabalhar; em nosso caso, o data.frame se chama iris: select(iris, ...); depois, colocamos no lugar de ... o nome das colunas que desejamos selecionar, sem aspas. Por exemplo, se quisermos selecionar a coluna das espécie, fazemos assim: head( select(iris, Species), 10) Species setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa Ou se quisermos a coluna de comprimento de pétala mais a coluna das espécies: head( select(iris, Petal.Length, Species), 10) Petal.Length Species 1.4 setosa 1.4 setosa 1.3 setosa 1.5 setosa 1.4 setosa 1.7 setosa 1.4 setosa 1.5 setosa 1.4 setosa 1.5 setosa Também podemos utilizar funções auxiliares para executar buscas nos nomes das colunas segundo determinados padrões. Entre essas funções auxiliares, destacamos a função contains(). Por exemplo, se quisermos selecionar todas as variáveis que contêm “Petal” em seus nomes: head( select(iris, contains(&quot;Petal&quot;)), 10) Petal.Length Petal.Width 1.4 0.2 1.4 0.2 1.3 0.2 1.5 0.2 1.4 0.2 1.7 0.4 1.4 0.3 1.5 0.2 1.4 0.2 1.5 0.1 12.1.2.2 Filtrando dados com filter() Se desejamos filtrar os dados segundo alguma informação, devemos utilizar a função filter(). Por exemplo, se quiser checar os dados de pétalas apenas para a espécie setosa, fazemos assim: head( filter(iris, Species == &quot;setosa&quot;), 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa Ou então quais amostras da espécie virginica possuem comprimento de sépala maior que 7 cm: head( filter(iris, Species == &quot;virginica&quot;, Sepal.Length &gt; 7), 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 7.1 3.0 5.9 2.1 virginica 7.6 3.0 6.6 2.1 virginica 7.3 2.9 6.3 1.8 virginica 7.2 3.6 6.1 2.5 virginica 7.7 3.8 6.7 2.2 virginica 7.7 2.6 6.9 2.3 virginica 7.7 2.8 6.7 2.0 virginica 7.2 3.2 6.0 1.8 virginica 7.2 3.0 5.8 1.6 virginica 7.4 2.8 6.1 1.9 virginica E se quisermos adicionar uma coluna em iris que consiste na razão entre o comprimento da pétala pelo comprimento da sépala? Chamaremos nossa nova coluna de razaopetsep: head( mutate(iris, razaopetsep = Petal.Length/Sepal.Length), 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species razaopetsep 5.1 3.5 1.4 0.2 setosa 0.2745098 4.9 3.0 1.4 0.2 setosa 0.2857143 4.7 3.2 1.3 0.2 setosa 0.2765957 4.6 3.1 1.5 0.2 setosa 0.3260870 5.0 3.6 1.4 0.2 setosa 0.2800000 5.4 3.9 1.7 0.4 setosa 0.3148148 4.6 3.4 1.4 0.3 setosa 0.3043478 5.0 3.4 1.5 0.2 setosa 0.3000000 4.4 2.9 1.4 0.2 setosa 0.3181818 4.9 3.1 1.5 0.1 setosa 0.3061224 12.1.2.3 Destrinchando as funções group_by e summarise As funções group_by e summarise resumem o propósito do pacote dplyr, pois permitem em poucas linhas de comando sumariar os dados, e partem do princípio, muito presente no R através das funções da família apply, chamado split-apply-combine que, em tradução livre, pode ser entendido como uma sequência lógica de ação: quebre em grupos, aplique uma função, e combine os resultados. Vamos partir para o uso dessas funções agrupando os dados em função da coluna Species e calculando a média do comprimento das pétalas (variável Petal.Length): iris_grouped &lt;- group_by(iris, Species) iris_sumario &lt;- summarise(iris_grouped, petala_l_media = mean(Petal.Length, na.rm = TRUE)) iris_sumario Species petala_l_media setosa 1.462 versicolor 4.260 virginica 5.552 Vamos destrinchar o que fizemos acima. A função group_by os dados em função de alguma ou algumas variáveis. Essa função geralmente é utilizada em conjunto com a função summarise para gerar sumários estatísticos de uma ou mais variáveis. head( group_by(iris, Species), 10) ## [90m# A tibble: 10 x 5[39m ## [90m# Groups: Species [1][39m ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;fct&gt;[39m[23m ## [90m 1[39m 5.1 3.5 1.4 0.2 setosa ## [90m 2[39m 4.9 3 1.4 0.2 setosa ## [90m 3[39m 4.7 3.2 1.3 0.2 setosa ## [90m 4[39m 4.6 3.1 1.5 0.2 setosa ## [90m 5[39m 5 3.6 1.4 0.2 setosa ## [90m 6[39m 5.4 3.9 1.7 0.4 setosa ## [90m 7[39m 4.6 3.4 1.4 0.3 setosa ## [90m 8[39m 5 3.4 1.5 0.2 setosa ## [90m 9[39m 4.4 2.9 1.4 0.2 setosa ## [90m10[39m 4.9 3.1 1.5 0.1 setosa Vejam que, acima das linhas do conjunto de dados, há a seguinte sentença: ## # Groups: Species [1] Ela informa que o objeto gerado a partir de group_by está agrupado ao redor da variável Species. Pensando no pacote base, é como pensar que a variável Species é o argumento INDEX da função tapply(): todos os cálculos a partir desse objeto ocorrerão em função dessa variável. Após agrupar os dados, nós colocamos esse data.frame agrupado via group_by(), iris_grouped &lt;- group_by(iris, Species), como primeiro argumento da função summarise() para então calcular a média do comprimento de pétala: iris_grouped &lt;- group_by(iris, Species) summarise(iris_grouped, petala_l_media = mean(Petal.Length, na.rm = TRUE)) Species petala_l_media setosa 1.462 versicolor 4.260 virginica 5.552 A partir desse mesmo data.frame agrupado, iris_grouped, podemos responder várias outras perguntas: Quantas amostras por espécies existem nesse conjunto de dados? Utilizaremos a função n(), que pertence ao mesmo pacote dplyr, para contar o número de grupos. Vejamos: summarise(iris_grouped, n()) Species n() setosa 50 versicolor 50 virginica 50 Médias de comprimento de sépalas e pétalas summarise(iris_grouped, sepala_l_media = mean(Sepal.Length, na.rm = TRUE)) Species sepala_l_media setosa 5.006 versicolor 5.936 virginica 6.588 summarise(iris_grouped, petala_l_media = mean(Petal.Length, na.rm = TRUE)) Species petala_l_media setosa 1.462 versicolor 4.260 virginica 5.552 Todas as operações anteriores na mesma linha de comando: iris_sumario &lt;- summarise(iris_grouped, N = n(), sepala_l_media = mean(Sepal.Length, na.rm = TRUE), petala_l_media = mean(Petal.Length, na.rm = TRUE)) head(iris_sumario, 10) Species N sepala_l_media petala_l_media setosa 50 5.006 1.462 versicolor 50 5.936 4.260 virginica 50 6.588 5.552 12.1.3 O operador %&gt;% e o encadeamento de ações Notem que nada do que vimos até aqui parece ser muito relevante se comparamos com o que pode ser feito com o pacote base do R. Vejamos: # Queremos selecionar colunas? Operadores `$` e `[[` dao conta head( iris[, which(names(iris) == &quot;Species&quot;)], 10) ## [1] setosa setosa setosa setosa setosa setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica head( iris[, &quot;Sepal.Length&quot;], 10) ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 # Filtrar linhas? Vetores lógicos em conjunto com o operador `[[` em um data.frame resolvem o problema head( iris[iris$Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; 7,], 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 103 7.1 3.0 5.9 2.1 virginica 106 7.6 3.0 6.6 2.1 virginica 108 7.3 2.9 6.3 1.8 virginica 110 7.2 3.6 6.1 2.5 virginica 118 7.7 3.8 6.7 2.2 virginica 119 7.7 2.6 6.9 2.3 virginica 123 7.7 2.8 6.7 2.0 virginica 126 7.2 3.2 6.0 1.8 virginica 130 7.2 3.0 5.8 1.6 virginica 131 7.4 2.8 6.1 1.9 virginica # Ou podemos filtrar também usando a função `subset`: head( subset(iris, Species == &quot;virginica&quot; &amp; iris$Sepal.Length &gt; 7), 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 103 7.1 3.0 5.9 2.1 virginica 106 7.6 3.0 6.6 2.1 virginica 108 7.3 2.9 6.3 1.8 virginica 110 7.2 3.6 6.1 2.5 virginica 118 7.7 3.8 6.7 2.2 virginica 119 7.7 2.6 6.9 2.3 virginica 123 7.7 2.8 6.7 2.0 virginica 126 7.2 3.2 6.0 1.8 virginica 130 7.2 3.0 5.8 1.6 virginica 131 7.4 2.8 6.1 1.9 virginica # Criar novas colunas? Podemos atribuir novas colunas a qualquer data.frame existente usando o operador `$` para criar uma nova coluna qualquer iris_novo &lt;- iris iris_novo$razaopetsep &lt;- iris_novo$Petal.Length/iris_novo$Sepal.Length head( iris_novo, 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species razaopetsep 5.1 3.5 1.4 0.2 setosa 0.2745098 4.9 3.0 1.4 0.2 setosa 0.2857143 4.7 3.2 1.3 0.2 setosa 0.2765957 4.6 3.1 1.5 0.2 setosa 0.3260870 5.0 3.6 1.4 0.2 setosa 0.2800000 5.4 3.9 1.7 0.4 setosa 0.3148148 4.6 3.4 1.4 0.3 setosa 0.3043478 5.0 3.4 1.5 0.2 setosa 0.3000000 4.4 2.9 1.4 0.2 setosa 0.3181818 4.9 3.1 1.5 0.1 setosa 0.3061224 # Sumariar resultados - Aqui temos um pouco mais de trabalho, porem nada muito complexo iris_count &lt;- as.data.frame(table(iris$Species)) names(iris_count) &lt;- c(&quot;Species&quot;, &quot;N&quot;) iris_sumario2 &lt;- cbind(iris_count, sepala_c_media = tapply(iris$Sepal.Length, iris$Species, &quot;mean&quot;), sepala_l_media = tapply(iris$Sepal.Width, iris$Species, &quot;mean&quot;), petala_c_media = tapply(iris$Petal.Length, iris$Species, &quot;mean&quot;), petala_l_media = tapply(iris$Petal.Width,iris$Species, &quot;mean&quot;)) head( iris_sumario2, 10) # comparem o resultado do objeto `iris_sumario2` com os de `iris_sumario` criado com as funcoes do pacote `dplyr` Species N sepala_c_media sepala_l_media petala_c_media petala_l_media setosa setosa 50 5.006 3.428 1.462 0.246 versicolor versicolor 50 5.936 2.770 4.260 1.326 virginica virginica 50 6.588 2.974 5.552 2.026 O operador %&gt;% foi introduzido no R por meio do pacote magrittr, de autoria de Stefan Milton Bache, com o intuito de encadear ações na manipulação de data.frames e facilitar a leitura do código. Segundo palavras do próprio autor, o operador %&gt;% modifica semanticamente o código em R e o torna mais intuitivo tanto na escrita quanto na leitura. Será? Vamos tentar entender isso na prática. Vamos retomar os exemplos acima com a introdução do operador %&gt;% e usá-lo para efetuar dois conjuntos de comandos, expostos abaixo: 12.1.3.1 Conjunto de comandos 1 # Chamar o data.frame `iris`, então... # Selecionar as colunas `Species`, `Petal.Length`, e `Sepal.Length`, então ... # Agrupar os dados em função de `Species`, então ... # Sumariar os dados para obter o número de observações por grupo, nomeando esta variável como `N`; obter o comprimento médio de pétalas, nomeando esta variável como `petala_l_media`, e o comprimento médio de sépalas, nomeando esta variável como `sepala_l_media`, então ... # Atribui o resultado dessa operação a um objeto chamado `res1` 12.1.3.2 Conjunto de comandos 2 # Chamar o data.frame `iris`, então... # Selecionar as colunas `Species`, `Petal.Length`, e `Sepal.Length`, então ... # Filtrar os dados para conter apenas a espécie `virginica` e espécimes com comprimento de sépala maior que 7 cm, então ... # Criar uma nova coluna chamada `razaopetsep` que contenha a razão entre os comprimentos de pétala e sépala, então ... # Sumariar os dados para obter o número total de observações, nomeando esta variável como `N`; obter o comprimento médio de pétalas, nomeando esta variável como `petala_l_media`, o comprimento médio de sépalas, nomeando esta variável como `sepala_l_media`, e a média do índice da razão entre o comprimento de pétalas e o comprimento de sépalas, nomeando-a como `media_razaopetsep`, então ... # Atribui o resultado dessa operação a um objeto chamado `res2` Primeiramente, carreguemos o pacote magrittr: library(&quot;magrittr&quot;) Executando o conjunto de comandos 1, temos: # Chamar o data.frame `iris`, então... res1 &lt;- iris %&gt;% # Selecionar as colunas `Species`, `Petal.Length`, e `Sepal.Length`, então ... select(Species, Petal.Length, Sepal.Length) %&gt;% # Agrupar os dados em função de `Species`, então ... group_by(Species) %&gt;% # Sumariar os dados para obter o número de observações por grupo, nomeando esta variável como `N`; obter o comprimento médio de pétalas, nomeando esta variável como `petala_l_media`, e o comprimento médio de sépalas, nomeando esta variável como `sepala_l_media` summarise( N = n(), petala_l_media = mean(Petal.Length, na.rm = TRUE), sepala_l_media = mean(Sepal.Length, na.rm = TRUE) ) res1 Species N petala_l_media sepala_l_media setosa 50 1.462 5.006 versicolor 50 4.260 5.936 virginica 50 5.552 6.588 Fazendo o mesmo com o conjunto de comandos 2, temos: # Chamar o data.frame `iris`, então... res2 &lt;- iris %&gt;% # Selecionar as colunas `Species`, `Petal.Length`, e `Sepal.Length`, então ... select(Species, Petal.Length, Sepal.Length) %&gt;% # Filtrar os dados para conter apenas a espécie `virginica` e espécimes com comprimento de sépala maior que 7 cm, então ... filter(Species == &quot;virginica&quot; &amp; Sepal.Length &gt; 7) %&gt;% # Criar uma nova coluna chamada `razaopetsep` que contenha a razão entre os comprimentos de pétala e sépala, então ... mutate( razaopetsep = Petal.Length/Sepal.Length ) %&gt;% # Sumariar os dados para obter o número total de observações, nomeando esta variável como `N`; obter o comprimento médio de pétalas, nomeando esta variável como `petala_l_media`, o comprimento médio de sépalas, nomeando esta variável como `sepala_l_media`, e a média do índice da razão entre o comprimento de pétalas e o comprimento de sépalas, nomeando-a como `media_razaopetsep` summarise( N = n(), petala_l_media = mean(Petal.Length, na.rm = TRUE), sepala_l_media = mean(Sepal.Length, na.rm = TRUE) ) res2 N petala_l_media sepala_l_media 12 6.3 7.475 Notem que o código fica formatado da maneira que funciona nosso pensamento sobre as ações a serem executadas: pegamos os dados, efetuamos transformações, e agregamos os resultados, praticamente da mesma maneira que o código é executado. Como diz o autor na vinheta de introdução ao operador %&gt;%, é como uma receita, fácil de ler, fácil de seguir (It’s like a recipe – easy to read, easy to follow!). Em conformidade com este entendimento, sugere-se que leiamos o operador %&gt;% como ENTÃO, implicando em uma passagem do resultado da ação à esquerda para a função à direita. Por isso, eu fiz questão de incluir em ambos os conjuntos de comandos, 1 e 2, a palavra então... ao fim de cada sentença. Um ponto importante que deve ser levado em consideração é que o uso do operador %&gt;% permite que escondamos o data.frame de entrada nas funções. Vejamos na prática para entender. Suponha que nós queiramos selecionar apenas as colunas Species e Petal.Length de iris. Podemos executar isso de duas maneiras, todas com o mesmo resultado: # podemos representar iris de três maneiras utilizando o operador `%&gt;%` iris %&gt;% select(Species, Petal.Length) # como temos feito ate aqui iris %&gt;% select(., Species, Petal.Length) # explicitamos que `iris` esta dentro de select por meio do `.` Isso pode ficar mais fácil de entender com outro exemplo. Suponha que tenhamos o vetor meuvetor &lt;- c(1:20) e queiramos obter o somatório deste vetor. Podemos executar isso de três maneiras utilizando o operador %&gt;%: meuvetor &lt;- c(1:20) meuvetor %&gt;% sum(.) # representando o vetor na forma de um `.` meuvetor %&gt;% sum() # deixando a funcao vazia meuvetor %&gt;% sum # sem parenteses e sem o `.`. O que????? Todas as maneiras acima executam e geram o mesmo resultado, 210. Essa multiplicidade de maneiras de expor o data.frame (ou o vetor no exemplo acima) é alvo de críticas por parte de alguns estudiosos, devido ao pacote magrittr não exigir que o argumento seja explícito quando usamos o operador %&gt;% (vejam uma boa argumentação nesta postagem de John Mount). Vale ressaltar que poderíamos muito bem encadear todas as ações executadas acima sem o operador %&gt;%, porém perderíamos a chance de ler o código da esquerda para a direita, oportunidade ofertada pelo uso do operador. Vejamos, usando o conjunto de comandos 2: summarise( mutate( filter( select(iris, Species, Petal.Length, Sepal.Length), Species == &quot;virginica&quot; &amp; Sepal.Length &gt; 7), razaopetsep = Petal.Length/Sepal.Length ), N = n(), petala_l_media = mean(Petal.Length, na.rm = TRUE), sepala_l_media = mean(Sepal.Length, na.rm = TRUE) ) Reparem que o código fica mais difícil de ser lido, pois temos de identificar primeiro quem é o data.frame que serve de entrada para a função summarise. Depois, há outros desafios, como entender o que cada função faz, e em qual ordem. Por fim, o código é lido de dentro para fora, um sentido nada intuitivo. Foi pensando em tornar a leitura do código mais fácil que o autor decidiu criar este operador na linguagem R, uma vez que essa lógica já é extensivamente utilizada em algumas outras linguagens de programação, como F# (representada como |&gt; e o bash (e similares) (representada como |). 12.1.3.3 Resumo do operador %&gt;%: transforma a leitura do código da esquerda para a direita; evita a criação de muitos objetos intermediários na sessão de trabalho; facilita a leitura do código, pois transforma a própria escrita em uma receita. 12.1.4 Usando o ggplot2 O pacote ggplot2 funciona de maneira diferente da função plot() do pacote base do R, pois trabalha em camadas. Similarmente ao pacote dplyr, começamos com o data.frame que desejamos plotar, contudo, passos posteriores são bem diferentes, e se assemelham mais ao uso do operador %&gt;% do pacote magrittr. No ggplot2, utilizamos o operador + para adicionar as camadas. Tabela 12.2: Principais funções do pacote R ggplot2. Função O que faz ggplot() Recebe os dados a serem plotados geom_point() Plota um gráfico de barra geom_boxplot() Plota um diagrama de caixa aes() Estética do gráfico xlab() Modifica o texto do eixo X ylab() Modifica o texto do eixo Y ggtitle() Adiciona o título do gráfico facet_wrap() Divide os gráficos segundo categoria especificada As principais funções do pacote estão exemplificadas na tabela 12.2. A função básica do pacote é ggplot(): nela, informamos nosso conjunto de dados no primeiro argumento. Após o primeiro passo, fazemos uso de funções para plotar dados em forma de um espalhamento (scatterplots usando a função geom_point()), gráficos de barra (geom_bar), diagramas de caixa (geom_boxplot()), entre outras. Vejamos na prática como funciona: # um grafico de espalhamento da variavel Sepal.Length no eixo X e Petal.Length no eixo Y utilizando o conjunto de dados iris ggplot(iris) + geom_point(aes(x = Sepal.Length, y = Petal.Length)) Dentro das funções que plotam os dados efetivamente (e.g., geom_point(), geom_boxplot()), devemos sempre usar a função aes(): nela inserimos os eixos x e y, informando sempre o nome das colunas sem aspas. Se quisermos colorir os pontos em função das espécies, fazemos: ggplot(iris) + geom_point(aes(x = Sepal.Length, y = Petal.Length, color = Species)) Por trabalhar em camadas, podemos atribuir os resultados dessas operações a objetos. Por exemplo, vamos passar o resultado da ação acima para um objeto meugrafico e mudar os temas do gráfico: meugrafico &lt;- ggplot(iris) + geom_point(aes(x = Sepal.Length, y = Petal.Length, color = Species)) meugrafico + theme_bw() # Existem varios outros temas pre-definidos no ggplot2 meugrafico + theme_minimal() # Para utilizar os outros temas, e so verificar o help de funcoes que comecam com theme_OUTROSnomes meugrafico + theme_void () # - existem, por exemplo, os temas theme_grey, theme_classic, theme_light etc Podemos facilmente também gerar um gráfico para cada espécie utilizando a função facet_wrap(): meugrafico + facet_wrap(~Species) Não temos a intenção de cobrir todo o uso do pacote ggplot2 nesta postagem. Existem muitas páginas com excelentes tutoriais na internet que podem ser visitadas para um maior aprofundamento nas ferramentas deste pacote (vejam abaixo na seção Para saber mais). Queremos aqui demonstrar o uso concomitante do pacote ggplot2 dentro de uma linha de trabalho associada ao pacote dplyr. Passemos para a seção abaixo. 12.1.5 dplyr e ggplot2 em conjunto Durante uma análise exploratória de dados, muitas perguntas surgem com a análise de gráficos simples, que podemos criar com poucas linhas de comando. Com os comandos ensinados nos passos anteriores, e novamente utilizando o conjunto de dados iris, vamos fazer uma exploração muito breve nesses dados. 12.1.5.1 Gráfico de espalhamento iris %&gt;% select(Species, Sepal.Width, Sepal.Length) %&gt;% ggplot(.) + # lembrem-se que o data.frame com colunas selecionadas acima aqui e representado por um `.` geom_point(aes(x = Sepal.Width, y = Sepal.Length, color = Species)) + xlab(&quot;Largura de sépala (cm)&quot;) + ylab(&quot;Comprimento de sépala (cm)&quot;) 12.1.5.2 Diagrama de caixas iris %&gt;% select(Species, Sepal.Length) %&gt;% ggplot(.) + geom_boxplot(aes(x = Species, y = Sepal.Length, fill = Species)) + xlab(&quot;Espécies de Iris&quot;) + ylab(&quot;Comprimento de sépala (cm)&quot;) 12.1.5.3 Histograma iris %&gt;% select(Species, Sepal.Width) %&gt;% ggplot(.) + geom_histogram(aes(x = Sepal.Width, fill = Species)) + xlab(&quot;Largura de sépala (cm)&quot;) + ylab(&quot;Frequência&quot;) + facet_wrap(~Species) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 12.1.6 Comparando o mesmo conjunto de ações entre base R e dplyr Abaixo, para efeitos de comparação, executamos as mesmas ações usando os pacotes base e dplyr; ao utilizar o dplyr, também fizemos uso do operador %&gt;%. # para avaliar os objetos criados no ambiente de trabalho, vamos apagar tudo da area de trabalho e comecar do zero rm(list=ls()) # filtra os dados em iris ## quem tem sepala menor que 6 cm e tem petala maior que 5 cm? iris2 &lt;- subset(iris, Sepal.Length &lt; 6 &amp; Petal.Length &lt; 5) head(iris2, 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa # checa as dimensoes do novo objeto dim(iris2) ## [1] 78 5 # ordena os dados segundo comprimento da petala iris_ord &lt;- iris2[order(iris2$Petal.Length),] head(iris_ord, 10) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 23 4.6 3.6 1.0 0.2 setosa 14 4.3 3.0 1.1 0.1 setosa 15 5.8 4.0 1.2 0.2 setosa 36 5.0 3.2 1.2 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 17 5.4 3.9 1.3 0.4 setosa 37 5.5 3.5 1.3 0.2 setosa 39 4.4 3.0 1.3 0.2 setosa 41 5.0 3.5 1.3 0.3 setosa 42 4.5 2.3 1.3 0.3 setosa # muda a ordem das colunas, colocando a coluna Species primeiro colsp &lt;- which(colnames(iris_ord) == &quot;Species&quot;) # qual a posicao da coluna Species? irisf &lt;- iris_ord[, c(colsp, (which(!(1:ncol(iris_ord)) %in% colsp)))] # cria uma nova coluna de razao entre comprimento da sepala e comprimento da petala irisf$razao_sepall_petall &lt;- irisf$Sepal.Length/irisf$Petal.Length head(irisf, 10) Species Sepal.Length Sepal.Width Petal.Length Petal.Width razao_sepall_petall 23 setosa 4.6 3.6 1.0 0.2 4.600000 14 setosa 4.3 3.0 1.1 0.1 3.909091 15 setosa 5.8 4.0 1.2 0.2 4.833333 36 setosa 5.0 3.2 1.2 0.2 4.166667 3 setosa 4.7 3.2 1.3 0.2 3.615385 17 setosa 5.4 3.9 1.3 0.4 4.153846 37 setosa 5.5 3.5 1.3 0.2 4.230769 39 setosa 4.4 3.0 1.3 0.2 3.384615 41 setosa 5.0 3.5 1.3 0.3 3.846154 42 setosa 4.5 2.3 1.3 0.3 3.461539 # faz um sumario estatisco agrupando as especies e checando min, max, desvio, media e mediana de cada variavel mean_pl &lt;- aggregate(irisf$Petal.Length, list(Species = irisf$Species), FUN = &quot;mean&quot;) mean_raz &lt;- aggregate(irisf$razao_sepall_petall, list(Species = irisf$Species), FUN = &quot;mean&quot;) sd_pl &lt;- aggregate(irisf$Petal.Length, list(Species = irisf$Species), FUN = &quot;sd&quot;) sd_raz &lt;- aggregate(irisf$razao_sepall_petall, list(Species = irisf$Species), FUN = &quot;sd&quot;) res &lt;- as.data.frame(mean_pl) res2 &lt;- cbind(res, media_razao = mean_raz[, -1], desvio_pl = sd_pl[, -1], desvio_raz = sd_raz[, -1]) names(res2)[2] &lt;- &quot;media_pl&quot; res2 Species media_pl media_razao desvio_pl desvio_raz setosa 1.462000 3.464906 0.1736640 0.4302168 versicolor 3.969231 1.404475 0.4249887 0.1195457 virginica 4.700000 1.115873 0.2828427 0.0381613 # plota grafico de pontos com eixo X correspondendo ao comprimento da sepala, e eixo Y ao comprimento da petala plot(irisf$Sepal.Length, irisf$Petal.Length, col = irisf$Species) # para avaliar os objetos criados no ambiente de trabalho, vamos apagar tudo da area de trabalho e comecar do zero rm(list=ls()) # chama os pacotes tidyverse library(&quot;dplyr&quot;) # o pacote para manipular dados library(&quot;ggplot2&quot;) # o pacote para plotar graficos # utilizando a filosofia tidyverse, utilizarei o pipe (&quot; %&gt;% &quot;) iris2t &lt;- # salvamos o objeto como `iris2t` para diferenciar do salvo acima iris %&gt;% # chama os dados e passa para a funcao abaixo filter(Sepal.Length &lt; 6 &amp; Petal.Length &lt; 5) %&gt;% # quem tem sepala menor que 6 cm E petala maior que 5 cm? arrange(Petal.Length) %&gt;% mutate(razao_sepall_petall = Sepal.Length/Petal.Length) %&gt;% select(Species, everything()) # reordena as colunas head(iris2t, 10) Species Sepal.Length Sepal.Width Petal.Length Petal.Width razao_sepall_petall setosa 4.6 3.6 1.0 0.2 4.600000 setosa 4.3 3.0 1.1 0.1 3.909091 setosa 5.8 4.0 1.2 0.2 4.833333 setosa 5.0 3.2 1.2 0.2 4.166667 setosa 4.7 3.2 1.3 0.2 3.615385 setosa 5.4 3.9 1.3 0.4 4.153846 setosa 5.5 3.5 1.3 0.2 4.230769 setosa 4.4 3.0 1.3 0.2 3.384615 setosa 5.0 3.5 1.3 0.3 3.846154 setosa 4.5 2.3 1.3 0.3 3.461539 # faz um sumario estatisco agrupando as especies e checando min, max, desvio, media e mediana de cada variavel res_t &lt;- iris2t %&gt;% group_by(Species) %&gt;% # agrupa dados pela coluna Species summarise( # sumarisa dados de acordo com os grupo estabelecidos acima mean_pl = mean(Petal.Length), # media da coluna comp de petala mean_raz = mean(razao_sepall_petall), # media da coluna razao de comp de sepala/petala sd_pl = sd(Petal.Length), # desvio do comp da petala sd_raz = sd(razao_sepall_petall)) # desvio do comp da sepala head(res_t, 10) Species mean_pl mean_raz sd_pl sd_raz setosa 1.462000 3.464906 0.1736640 0.4302168 versicolor 3.969231 1.404475 0.4249887 0.1195457 virginica 4.700000 1.115873 0.2828427 0.0381613 # plota grafico de pontos com eixo X correspondendo ao comprimento da sepala, e eixo Y ao comprimento da petala tgraf &lt;- ggplot(data = iris2t) + geom_point(aes(x = Sepal.Length, y = Petal.Length, color = Species)) tgraf Vejam que os resultados são iguais, com exceção da estética diferente proporcionada pelo pacote ggplot2. Porém, há uma mudança notável em como a manipulação dos dados é feita quando utilizamos o operador %&gt;% dentro do fluxo de trabalho, como resumido acima: a leitura é feita da esquerda para a direita, podemos reduzir a criação de objetos intermediários na área de trabalho, e o código pode ser lido com mais clareza. Postagens futuras abordarão com mais detalhes outros usos deste operador e de alguns outros inclusos no mesmo pacote, porém com funções levemente diferentes. 12.1.6.1 E o uso do operador %&gt;% com o pacote base? Apesar de termos explorado até aqui o uso do operador %&gt;% apenas com o pacote dplyr, ele pode ser utilizado com qualquer função no R. Vamos retormar o exemplo da seção acima com comandos do pacote base do R, porém adicionando o operador %&gt;% na manipulação dos dados: iris_ord &lt;- iris %&gt;% subset(Sepal.Length &lt; 6 &amp; Petal.Length &lt; 5) %&gt;% # filtramos os dados com a funcao subset() .[order(.$Petal.Length),] # usamos o `.` para representar o data.frame filtrado no passo anterior colsp &lt;- which(colnames(iris_ord) == &quot;Species&quot;) irisf &lt;- iris_ord[, c(colsp, (which(!(1:ncol(iris_ord)) %in% colsp)))] irisf$razao_sepall_petall &lt;- irisf$Sepal.Length/irisf$Petal.Length head(irisf, 10) Species Sepal.Length Sepal.Width Petal.Length Petal.Width razao_sepall_petall 23 setosa 4.6 3.6 1.0 0.2 4.600000 14 setosa 4.3 3.0 1.1 0.1 3.909091 15 setosa 5.8 4.0 1.2 0.2 4.833333 36 setosa 5.0 3.2 1.2 0.2 4.166667 3 setosa 4.7 3.2 1.3 0.2 3.615385 17 setosa 5.4 3.9 1.3 0.4 4.153846 37 setosa 5.5 3.5 1.3 0.2 4.230769 39 setosa 4.4 3.0 1.3 0.2 3.384615 41 setosa 5.0 3.5 1.3 0.3 3.846154 42 setosa 4.5 2.3 1.3 0.3 3.461539 mean_pl &lt;- aggregate(irisf$Petal.Length, list(Species = irisf$Species), FUN = &quot;mean&quot;) mean_raz &lt;- aggregate(irisf$razao_sepall_petall, list(Species = irisf$Species), FUN = &quot;mean&quot;) sd_pl &lt;- aggregate(irisf$Petal.Length, list(Species = irisf$Species), FUN = &quot;sd&quot;) sd_raz &lt;- aggregate(irisf$razao_sepall_petall, list(Species = irisf$Species), FUN = &quot;sd&quot;) res &lt;- as.data.frame(mean_pl) res2 &lt;- cbind(res, media_razao = mean_raz[, -1], desvio_pl = sd_pl[, -1], desvio_raz = sd_raz[, -1]) names(res2)[2] &lt;- &quot;media_pl&quot; res2 Species media_pl media_razao desvio_pl desvio_raz setosa 1.462000 3.464906 0.1736640 0.4302168 versicolor 3.969231 1.404475 0.4249887 0.1195457 virginica 4.700000 1.115873 0.2828427 0.0381613 Reparem que, mesmo utilizando o operador %&gt;%, algumas transformações realizadas com poucas linhas de código com o pacote dplyr em uma cadeia de comandos (o chamado pipeline em inglês) não são possíveis com o uso do pacote base do R, notadamente a criação de colunas, o rearranjo de colunas, e o sumário de dados. 12.1.7 Tidyverse, um resumo David Robinson, autor do pacote broom, um dos membros do tidyverse, explica em sua postagem Teach the tidyverse to beginners que sua preferência por ensinar as ferramentas dos pacotes pertencentes ao tidyverse primeiramente a seus alunos se deve à compatibilidade da filosofia de ensino deste universo com o que ele acredita que seja ideal em uma filosofia de ensino: deve haver uma, preferencialmente apenas uma, maneira óbvia de se fazer, mote emprestado do guia de 19 princípios da linguagem de programação Python, conhecido como Zen of Python. Essa filosofia se contrapõe, por exemplo, ao mote da linguagem Perl, que é Há sempre mais de uma maneira de se fazer (nota pessoal: Isso pode ser observado na linguagem R, são sempre múltiplos os caminhos para se chegar a um resultado). O mesmo autor também afirma nesta postagem que talvez um fluxo de trabalho comum aos alunos de cursos de ciência de dados seja: trabalhar com dados interessantes e reais; Criar gráficos informativos e atrativos; Chegar a conclusões úteis. Finalizando, ele conclui dizendo que o tidyverse oferece ferramentas a seus usuários que tornam esse caminho mais suave. O uso do %&gt;% oferece outros aspectos a serem considerados no uso dessas ferramentas: Cada passo do operador resolve um problema; Cada passo ensina uma função; Acelera o uso da linguagem para análise exploratória de dados. Nem tudo são flores em nenhum dos pontos abordados acima. Há muita controvérsia sobre o caminho a ser tomado em aulas da linguagem R nos dias atuais, que passam pela pergunta: ensinar primeiro o pacote base do R e suas funcionalidades básicas, ou começar pelas ferramentas do tidyverse (ver mais na seção Para saber mais. Não vamos entrar nesse embate nesta postagem. O que podemos afirmar é que qualquer pacote de R, com exceção do pacote base, foi construído em cima das funcionalidades deste último, logo, sem este pacote, não estaríamos nem aqui falando de funcionalidades do dplyr e afins. Quisemos aqui apresentar funcionalidades básicas de alguns pacotes que podem ser adotadas ou não pelos alunos, e mostrar como podem ser incorporadas no fluxo diário das manipulações de dados. Caso queiram ver manipulações mais complexas em tabelas utilizando as ferramentas do tidyverse, convido-os a checarem estas duas postagens: importando e manipulando dados no R, e um tutorial para gerar o mapa de distribuição de Macrolobium aracaense Farroñay. 12.1.8 Para saber mais: As postagens abaixo variam entre posições favoráveis ou desfavoráveis ao Tidyverse. Abrangem desde opiniões pessoais sobre o porquê de não ensinar essas ferramentas aos iniciantes na linguagem a questões de performance computacional desse universo quando comparado com o base R. Leiam e tirem suas próprias conclusões. A Thousand Gadgets: My Thoughts on the R Tidyverse - Opinião pessoal do autor da postagem sobre o porquê de ele não simpatizar nem utilizar nenhuma ferramenta do tidyverse. Tidyverse - Página principal deste universo de pacotes; R for Data Science - Livro disponível gratuitamente na internet, escrito por Garrett Grolemund e Hadley Wickham, este criador e mente criativa por muitos dos pacotes deste universo What is the tidyverse - Postagem introdutória sobre o tidyverse e algumas de suas funcionalidades. Why I don’t use the tidyverse - opinião pessoal do autor sobre o porquê do mesmo não utilizar nenhum pacote do tidyverse. Don’t teach built-in plotting to beginners (teach ggplot2) - postagem do autor do pacote broom, David Robinson, sobre o porquê de ele ensinar seus alunos a manipularem primeiro o ggplot2 em detrimento das funções gráficas do pacote base do R. Teach the tidyverse to beginners - postagem de David Robinson sobre sua opinião pessoal de se ensinar primeiro o tidyverse aos alunos de cursos de introdução ao R. Introducing magrittr - Vinheta de introdução às funcionalidades do operador %&gt;% 12.2 Baixar e descomprimir um arquivo zip usando o R Caso você queira baixar e descomprimir um arquivo .zip no próprio R, ao invés de baixá-lo manualmente, siga os comandos abaixo. Utilizaremos um arquivo utilizado na seção @ref(#obj-complexos). # grava o endereco do arquivo em um objeto arq_zip_url &lt;- &quot;http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=bot89:precurso:2lists:municipiosshape.zip&quot; # cria um diretorio temporario dirtemp &lt;- tempdir() # cria um arquivo temporario para arquivar esse zip arq_temp &lt;- tempfile(tmpdir = dirtemp, fileext=&quot;.zip&quot;) # baixa o arquivo para dentro do arquivo temporario download.file(arq_zip_url, arq_temp) # Apos executar o comando acima, o arquivo `.zip` e baixado para o objeto `arq_temp` # agora utilizaremos a funcao `unzip()` para descomprimir o arquivo # pega o nome do primeiro arquivo dentro do zip == corresponde ao nome da pasta fname &lt;- unzip(arq_temp, list=TRUE)$Name[1] nomes_arqs &lt;- unzip(arq_temp, list=TRUE) class(nomes_arqs) # e um dataframe; a primeira coluna mostra o caminho de cada arquivo presente no zip; segunda coluna, o tamanho do arquivo str(nomes_arqs) nomes_arqs # Descomprime o arquivo zip para a pasta temporaria unzip(arq_temp, files = nome_pasta, exdir = dirtemp, overwrite = TRUE) # caminho completo do arquivo extraido caminho_completo &lt;- file.path(dirtemp, nome_pasta) caminho_completo # lista arquivos dentro do caminho contido em caminho_completo list.files(paste0(caminho_completo, &quot;/.&quot;), all.files = TRUE) 12.3 Aulas em vídeo Gravamos vídeos para muitas aulas da disciplina Preparação de dados para Análises Estatísticas - Introdução ao R (BOT-89) do Programa de Pós-Graduação em Ciências Biológicas (Botânica) do INPA. Elas estão agrupadas abaixo para facilitar a visualização e o entendimento dos tópicos abordados. 12.3.1 Importando e exportando dados 12.3.2 Criação de vetores 12.3.3 Classes de vetores e fatores 12.3.4 Sequências numéricas e repetições, operações e funções com vetores 12.3.5 Listas 12.3.6 Criando matrizes 12.3.7 Criando dataframes, e operações importantes em matrizes e dataframes 12.3.8 Indexação de matrizes e dataframes 12.3.9 Condicionais 12.3.10 Funções da família apply(\") 12.3.11 Funções de manipulação de pasta e arquivos 12.3.12 Funções de manipulação de texto - parte 01 12.3.13 Funções de manipulação de texto - parte 02 12.3.14 Objetos complexos Texto publicado originalmente no blog de R.O.Perdiz (https://ricardoperdiz.com/post/2020-04-08-basertidyverse/tidyverse/)↩︎ O famoso conjunto de dados iris consiste de observações de comprimentos e larguras de sépalas e pétalas de 3 espécies de Iris, um gênero de plantas herbáceas da família Iridaceae. O conjunto de dados possui 150 linhas e 5 colunas. Para quem quiser saber mais sobre esses dados, leia aqui.↩︎ "],["informação-da-sessão.html", "13 Informação da sessão", " 13 Informação da sessão ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.7 ## ## Locale: en_US.UTF-8 / en_US.UTF-8 / en_US.UTF-8 / C / en_US.UTF-8 / en_US.UTF-8 ## ## Package version: ## askpass_1.1 assertthat_0.2.1 base64enc_0.1.3 bookdown_0.21 ## brio_1.1.1 callr_3.5.1 cli_2.2.0 colorspace_2.0-0 ## compiler_4.0.3 cpp11_0.2.6 crayon_1.4.0 curl_4.3 ## desc_1.2.0 diffobj_0.3.3 digest_0.6.27 dplyr_1.0.3 ## ellipsis_0.3.1 evaluate_0.14 fansi_0.4.2 farver_2.0.3 ## generics_0.1.0 ggplot2_3.3.3 glue_1.4.2 graphics_4.0.3 ## grDevices_4.0.3 grid_4.0.3 gtable_0.3.0 highr_0.8 ## htmltools_0.5.1.1 httr_1.4.2 isoband_0.2.3 jsonlite_1.7.2 ## kableExtra_1.3.1 knitr_1.31 labeling_0.4.2 lattice_0.20.41 ## lifecycle_0.2.0 magrittr_2.0.1 markdown_1.1 MASS_7.3.53 ## Matrix_1.2.18 methods_4.0.3 mgcv_1.8.33 mime_0.9 ## munsell_0.5.0 nlme_3.1.149 openssl_1.4.3 pillar_1.4.7 ## pkgbuild_1.2.0 pkgconfig_2.0.3 pkgload_1.1.0 praise_1.0.0 ## prettyunits_1.1.1 printr_0.1.1 processx_3.4.5 ps_1.5.0 ## purrr_0.3.4 R6_2.5.0 RColorBrewer_1.1.2 rematch2_2.1.2 ## rlang_0.4.10 rmarkdown_2.6 rprojroot_2.0.2 rstudioapi_0.13 ## rvest_0.3.6 scales_1.1.1 selectr_0.4.2 splines_4.0.3 ## stats_4.0.3 stringi_1.5.3 stringr_1.4.0 sys_3.4 ## testthat_3.0.1 tibble_3.0.6 tidyr_1.1.2 tidyselect_1.1.0 ## tinytex_0.29 tools_4.0.3 utf8_1.1.4 utils_4.0.3 ## vctrs_0.3.6 viridisLite_0.3.0 waldo_0.2.3 webshot_0.5.2 ## withr_2.4.1 xfun_0.20 xml2_1.3.2 yaml_2.2.1 "],["referências.html", "Referências", " Referências "]]
