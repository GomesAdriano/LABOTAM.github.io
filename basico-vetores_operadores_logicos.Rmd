## Vetores e operadores lógicos {#vetor-operador-logico}


Para manipular dados no R, entender vetores lógicos e operadores lógicos é fundamental.
Vetores lógicos são vetores de verdadeiros (`TRUE` ou apenas `T`, sempre em letras maiúsculas) ou falsos (`FALSE` ou `F`).
Eles podem ser convertidos em vetores numéricos e, portanto, operados matematicamente (`T` = 1, e `F` = 0).  

### Fazendo perguntas à vetores {#perg-vetores}

Vetores lógicos podem ser respostas às perguntas feitas por **operadores lógicos**:

* `>` - é maior que?

* `<` - é menor que?

* `>=` - é maior igual a?

* `<=` - é menor igual a?

* `==` - é igual a?

* `!=` - é diferente de?

* `%in%` - compara conteúdo de vetores

Há ainda a função `duplicated()` que busca valores repetidos em um vetor.
O resultado desta função é um vetor contendo `TRUE` ou `FALSE`. 
Valores que possuam o valor `TRUE` são duplicados.
Para checar os duplicados, devemos filtrar o resultado desta ação (veja na seção \@ref(vetor-filtro-logico)).

<!-- Há funções úteis que auxiliam na filtragem de dados utilizando valores lógicos. -->
<!-- A primeira se chama `grep()`, que busca parte de palavras em um vetor, e a segunda chama-se `duplicated()`, que busca valores repetidos.   -->

```{r, opts.label='evalF'}
#um vetor numerico
v1 = 1:20
#quais valores de v1 são maiores ou iguais a 10
p1 = v1>=10 #vai retornar um vetor lógico
p1
#soma dos verdadeiros responde "quantos valores de v1 são maiores ou iguais a 10, pois apenas esses valores são verdadeiros ou seja são 1)
sum(p1) 
#experimente os demais operadores

#a regra da reciclagem também se aplica neste conceito
v1 = 1:20
v2 = 1:20
p2 = v1==v2 #compara cada par dos vetores que são idênticos
p2 #é o vetor lógico resultando, todos os valores são verdadeiros
#portanto, as seguintes expressões também são verdadeiras
sum(v1==v2)==length(v1)
#ou então
sum(v1==v2)==length(v2)

#valores duplicados
vv = c(2,2,2,3,4,5) 
vv #apenas o dois é duplicado
duplicated(vv) #note que esta função retorna TRUE apenas para dois dos três valores 2 (o primeiro não é duplicado)

#comparando vetores
v1 = c(1,2,3,4)
v2 = c(4,4,5,6)
v1%in%v2 #quantos elementos de v1 existem em v2
sum(v1%in%v2) #apenas 1
v2%in%v1 #quais elementos de v2 estão em v1
sum(v2%in%v1) #os dois quatro

notas.dos.alunos = c(6.0, 5.1, 6.8, 2.8, 6.1, 9.0, 4.3, 10.4,6.0, 7.9, 8.9, 6.8, 9.8, 4.6, 11.3, 8.0, 6.7, 4.5)
##Quantos aprovados?
sum(notas.dos.alunos>=5)
#Qual a proporção de aprovados?
prop = sum(notas.dos.alunos>=5)/length(notas.dos.alunos)
prop
#ou em texto
paste(round(prop*100),"%",sep="")
```
  
Podemos usar também vetores de texto e fatores em conjunto com operadores lógicos.  

```{r, opts.label='evalF'}
#E VETORES DE TEXTO?
v1 = rep(c("banana","pera","laranja","limão"),10)
v1 #um vetor de palavras
#quantos elementos são iguais a banana
v1=="banana"
sum(v1=="banana")
#também poderia perguntar: quantos elementos de v1 contém banana
sum(v1%in%"banana")
v1%in%"banana"

#no caso acima == e %in% funcionam igual, mas o operador %in% é util quando quisermos comparar dois vetores de character
v2 = c("banana","pera","abacate")
v1%in%v2 #quais elementos de v1 correspondem a elementos de v2
sum(v1%in%v2) #quantos são? 10 laranjas e 10 peras 
v2%in%v1 #quais elementos de v2 estão em v1
sum(v2%in%v1) #quantos são (apenas laranja e pera, abacate não está)
```


Operadores auxiliares permitem combinar perguntas:

* `&` equivale a `E` - essa condição E essa outra;

* `|` equivale a `OU` - essa condição OU essa outra;

* `!` - inverte os valores da pergunta


```{r, opts.label='evalF'}
#um vetor
v1 = 1:20
v1
p1 = v1>5 & v1<=15 #quais elementos de v1 são maiores que 5 E menores ou iguais a 15
sum(p1) #quantos são?
p1 = v1>5 | v1<=15 #quais elementos de v1 são maiores que 5 OU menores ou iguais a 15
sum(p1) #quantos são

#!exclamação NEGA ou INVERTE verdadeiros e falsos
v1 = 1:20
sum(v1==5) #quantos v1 são iguais a 5?
sum(!v1==5) #quantos v1 são diferentes de 5?

sum(v1>5) #quantos v1 são maiores que 5?
sum(!v1>5) #quantos v1 são menores que 5?

#texto
v1 = rep(c("banana","pera","laranja","limão"),10)
v1 #um vetor de palavras
vl = v1=="banana" & v1=="pera" #quantos elementos de v1 sao banana E sao pera
vl 
sum(vl)  #nenhum valor satisfaz as duas condicoes

vl = v1=="banana" | v1=="pera" #quantos elementos de v1 sao banana ou sao pera
vl 
sum(vl)  #tem 20 valores que satisfazem 1 das condições
#isso é o mesmo que pergunta desse outro jeito:
sum(v1%in%c("banana","pera"))
```

### Filtrando dados com vetores lógicos {#vetor-filtro-logico}

Vetores lógicos podem ser usados como índices (Seção \@ref()) para filtrar elementos de um vetor.
É através deste conceito que podemos filtrar dados de matrizes e criar subconjunto de dados.  

```{r, opts.label='evalF'}
#um vetor com sequencia de 1 a 100
v1 = 1:100

p1 = v1>15  #Pergunta 1 quantos são maiores que 15
v1[p1] #valores que satisfazem a pergunta 1

p2 = v1<=20 #Pergunta 2 quantos são menores ou iguais a 20
v1[p2]  #valores que satisfazem a pergunta 2

#quantos satisfazem as duas perguntas
p3 = p1 & p2
v1[p2]  #valores que satisfazem as duas perguntas
```

A função `grep()` permite a busca de uma palavra (ou pedaço dela) em um vetor de palavras.
Mais de uma palavra pode ser buscada ao mesmo tempo.  

```{r, opts.label='evalF'}
?grep #veja o help dessa função e seus argumentos

#um vetor de palavras
v1 = rep(c("banana","pera","laranja","limão"),5)
grep("an",v1) #quais elementos tem a palavra 'an' no nome?
#note que é case.sensitive (depende se é maiusculo ou minúsculo)
grep("An",v1) #não encontra nada
grep("An",v1,ignore.case=T) #mas eu posso dizer para ele ignorar se é minusculo ou maiúsculo e ele encontra novamente 
#quem sao esses elementos
vl = grep("An",v1,ignore.case=T) #pega os índices desses elementos
v1[vl]
unique(v1[vl]) #valores únicos desse vetor
```

### Perguntando por valores ausentes - NA {#filtro-dados-ausentes}

Vimos anteriormente como o R codifica valores ausentes (seção \@ref(valor-na)): como uma classe lógica definida pela palavra `NA` em maiúsculo.
E nossos dados frequentemente têm valores ausentes.
Isso vai gerar avisos indesejáveis e impedir certas análises.
Então, muitas vezes precisamos tirar registros com valores ausentes ou colunas com muitos valores ausentes.  

Perguntar por valores ausentes no R é feito por uma função especial chamada `is.na()`.
A resposta da função é um vetor lógico indicando quem é e quem não é `NA`.
Há uma outra função chamada `na.omit()` que elimina valores `NA` de um vetor.  

```{r, opts.label='evalF'}
?is.na  #veja o help
#um vetor com NAs
v1 = c(NA,NA,1,2,3,4,5,6)
is.na(v1) #quem é NA?
v2 = v1[!is.na(v1)] #criar um vetor novo com quem não é NA (note o !)
v2
#isso também pode ser feito com na.omit()
?na.omit  #veja o help dessa função
v3 = na.omit(v1)
v3 #a diferença é que criou um objeto de classe na.omit
v3 = as.vector(v3) #isso elimina a diferença, convertendo em vetor
v3 #agora é idêntico a v2

#agora suponha o seguinte vetor
v4 = c("NA", "NA","pera","banana","mamão")
is.na(v4) #ops todos são falsos
#isso porque "NA" é texto e não um objeto de classe lógica
class(NA)
class("NA")
#mas eu poderia corrigir isso
v4[v4=="NA"] #vejo
v4[v4=="NA"] = NA #corrijo
v4
is.na(v4) #agora dois são NAs
#note que agora todos são diferentes de "NA" como texto 
v4[!v4=="NA"]
#mas isso de mostra quem não é corretamente
v5 = v4[!is.na(v4)]
v5
```

## Para saber mais: {#sabermais-manip-texto}

(@) Vídeoaula - temos uma vídeoaula disponível com o conteúdo desta aula. Acesse-a no *link* abaixo:

  * [Vetores e Operadores Lógicos](http://www.botanicaamazonica.wiki.br/labotam/lib/exe/fetch.php?media=bot89:precurso:6vetores:video01_bot89-2020-04-07_07.52.00.mp4);
