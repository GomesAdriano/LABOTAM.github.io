## Filtrando e ordenando matrizes e `data.frames`

### Filtragem de dados

Já vimos como fazer perguntas sobre vetores (Seção \@ref(perg-vetores)) e obter vetores lógicos ou valores de índices que nos permitem extrair ou filtrar de vetores os dados que satisfazem às condições das perguntas feitas.
Aqui vamos estender isso para objetos de classe `matrix` e `data.frame`, porque é através de vetores lógicos ou de matrizes lógicas que podemos filtrar dados de objetos bidimensionais.  

```{r, opts.label='evalF'}
?iris  #veja o help do R sobre Edgar Anderson's Iris Data que explica esses dados que vem com o R
class(iris)
str(iris)  #estrutura, veja as colunas

#vamos filtrar os dados de uma das especies
unique(iris$Species) #vemos os valores únicos
#ou, tendo em vista que é um fator
levels(iris$Species)
sp1 = levels(iris$Species)[1]
#quais linhas correspondem a essa especie
vl = iris$Species==sp1
sum(vl) #numero de linhas que satisfazem a pergunta
nrow(iris) #numero total de linhas no data.frame
#filtrando os dados eu simplesmente uso o vetor lógico como índice de linha. O novo objeto criado terá apenas as linhas em que vl é verdadeiro
iris.sp1 = iris[vl,]
nrow(iris.sp1)==sum(vl) #entao esta condição é verdadeira

#filtrar segundo duas colunas
vl = iris$Species==sp1 #seja da especie em sp1
sum(vl) #quantas sao?
vl2 = iris$Sepal.Length<=5 #tenha sepala menor ou igual a 5
sum(vl2) #quantas sao?
#combinando as duas perguntas
vll = vl & vl2
sum(vll) #quantas sao?
#filtrando
ff = iris[vll,] 
class(ff) #novo data.frame resultando do filtro realizado
nrow(ff)== sum(vll)  #isso deve ser verdadeiro
```

#### Dados com valores ausentes

As funções`is.na()` e `na.omit()` vistas anteriormente (Seção \@ref(filtro-dados-ausentes)) permitem eliminar linhas e colunas que tenham valores ausentes.
A presença de valores às vezes impede certas análises de serem executadas.  

```{r, opts.label='evalF'}
#vamos fazer uma cópia do objeto iris e modificar ele acrescentando alguns NAs
dd = iris
#tem algum NA originalmente?
sum(is.na(dd)) #não tem

#qual a dimensão?
dim(dd)
#pega 10 valores aletórios entre 1:150 (linhas)
v1 = sample(1:nrow(dd),size=10,replace=F)
#nessas linhas acrescenta NAs na coluna 2
dd[v1,2] = NA
#pega outros 10 valores aletórios entre 1:150 (linhas)
v1 = sample(1:nrow(dd),size=10,replace=F)
#nessas linhas acrescenta NAs na coluna 3
dd[v1,3] = NA

#pronto agora temos um data.frame com NAs
sum(is.na(dd)) #tem 20 NAs na tabela

#quais linhas tem NA
vl = is.na(dd[,2]) | is.na(dd[,3]) #ou é NA em 2 ou em 3 que foi onde mudei
dd[vl,]

#use na.omit() para eliminar todas as linhas que NA em alguma coluna
sum(is.na(dd)) #tem 20 valores
dd2 = na.omit(dd)
sum(is.na(dd2)) #nao tem mais nenhum
```


### Ordenação de dados

Para ordenar matrizes e `data.frames`, é preciso entender a diferença entre duas funções:

* `sort()` ordena um vetor e retorna os valores ordenados;

* `order()` ordena um vetor e retorna os **índices dos valores ordenados**. É isso que deve ser utilizado para ordenar matrizes e `data.frames`.

```{r, opts.label='evalF'}
?sort
?order
#ordenação
str(iris)  

#funcao SORT()
o1 = sort(iris$Sepal.Length) #pega os valores ordenados da coluna comprimento de sépala
o1 #sao valores de sepalas do menor para o maior
#em ordem decrescente
o2 = sort(iris$Sepal.Length,decreasing=T)
o2 #sao valores de sepalas do maior para o menor

#FUNCAO order()
#qual o indice dos valores ordenados em ordem crescente?
o3 = order(iris$Sepal.Length)
o3 #esses valores correspondem aos INDICES dos valores ordenados
#entao para ver os valores ordenados
iris$Sepal.Length[o3]
#então isso deve ser totalmente verdadeiro: 
iris$Sepal.Length[o3]==sort(iris$Sepal.Length) #as comparações para a par são identicas
#então esta expressão também é verdadeira:
sum(iris$Sepal.Length[o3]==sort(iris$Sepal.Length))==nrow(iris)

#portanto a função sort ordena os valores e funcao order mostra apenas os indices dos valores ordenados. Assim, posso usar a funcao order() para ordenar data.frames, matrizes e vetores
idx = order(iris$Sepal.Length) #indice das linhas ordenadas segundo o comprimento das sepalas
#compara com o original:
sum(iris$Sepal.Length[idx]==iris$Sepal.Length)==nrow(iris) #é FALSO porque em iris as linhas não estão originalmente ordenadas segundo o comprimento. 

#vamos mudar isso
novo.iris = iris[idx,] #pego o vetor de indices dos valores ordenados e uso na indexacao para ordenar o objeto original segunda a coluna escolhida
idx2 = order(novo.iris$Sepal.Length) #indice das linhas ordenadas segundo o comprimento das sepalas
#note que agora essa expressão é verdadeira, porque o original já está ordenado segundo essa coluna
sum(novo.iris$Sepal.Length[idx2]==novo.iris$Sepal.Length)==nrow(novo.iris) #é FALSO 


#AGORA ORDENANDO POR MULTIPLAS COLUNAS
idx = order(iris$Species,iris$Sepal.Length, decreasing=TRUE) #por especie e por sepala em ordem decrescente

#ordena segundo essas duas colunas
novo.iris = iris[idx,]
novo.iris[,c("Species","Sepal.Length")]

#para cada especie esta ordenado por sepala:
novo.iris[novo.iris$Species=="versicolor",]$Sepal.Length  
novo.iris[novo.iris$Species=="virginica",]$Sepal.Length  

```
